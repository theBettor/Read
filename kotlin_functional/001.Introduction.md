# 001. Introduction

> functional 부터는 번역하고 학습한 내용을 올립니다. 본격적인 내용은 002부터 시작됩니다.
> 

함수형 프로그래밍 : 

- 함수를 객체로 취급하는 것 : Function types, lambda expressions, function references
- 고차 함수 : Full support
- 데이터 불변성 : val support, default collections are read-only, copy in data classes
- using statements as expressions : if-else, try-catch, when statements are expressions
- lazy evaluation : lazy delegate
- 패턴 매칭 : when together with smart casting
- 재귀 함수 호출 : tailrec modifier

객체 지향적 접근 방식에서, 우리는 세계를 객체 집합으로 본다. 

대조적으로, 기능적 접근 방식에서, 우리는 세계를 함수 집합으로 본다. 

이 책에서는 함수형 프로그래밍의 핵심이라고 생각하는 함수형 프로그래밍의 핵심, 즉 함수를 객체로 사용하는 것에 집중할 것입니다.

## Why do we need to use functions as objects?

이것은 기능적 프로그래밍 기능이 구조되는 곳이다. 그것들은 우리가 쉽게 함수를 만들고 객체로 전달할 수 있게 해준다. 함수를 만들기 위해, 우리는 람다 표현식을 사용할 수 있다. 매개 변수가 기대하는 함수의 종류를 표현하기 위해 함수 유형을 사용할 수 있습니다. 이것이 우리가 람다 표현식과 함수 유형을 사용할 경우 우리의 코드가 보일 수 있는 모습입니다.

```kotlin
fun sum(a: Int, b: Int) = fold(a, b, 0, { acc, i -> acc + i })

fun product(a: Int, b: Int) = fold(a, b, 1, { acc, i -> acc * i })

fun fold(a: Int, b: Int, initial: Int, operation: (Int, Int) -> Int): Int {
    var acc = initial
    for (i in a..b) {
        acc = operation(acc, i)
    }
    return acc
}
```

함수형 프로그래머들은 오래전에 많은 반복적인 코드 패턴이 함수형 프로그래밍 기능의 도움으로 분리된 함수로 추출될 수 있다는 것을 알아차렸다. fold는 좋은 예이다. 그것의 보다 보편적인 형태는 수년 전에 정의되었고 오늘날에는 Kotlin 표준 도서관(stdlib)의 일부이다. 이것이 우리가 다음과 같은 방식으로 우리의 합계와 제품을 정의할 수 있는 이유입니다.

```kotlin
fun sum(a: Int, b: Int) = (a..b).fold(0) { acc, i -> acc + i }

fun product(a: Int, b: Int) = (a..b).fold(1) { acc, i -> acc * i }
```

그러나 함수 참조를 사용하는 경우 다음과 같은 방식으로 정의할 수도 있습니다.

```kotlin
fun sum(a: Int, b: Int) = (a..b).fold(0, Int::plus)
fun product(a: Int, b: Int) = (a..b).fold(1, Int::times)
```

컬렉션 처리 기능에 대해 잘 알고 있다면, 이터블에서 모든 숫자의 합계를 계산하는 것이 합계 방법으로 이루어질 수 있다는 것을 알 것입니다.

```kotlin
fun sum(a: Int, b: Int) = (a..b).sum()
fun product(a: Int, b: Int) = (a..b).fold(1, Int::times)
```

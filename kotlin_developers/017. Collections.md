Collections are one of the most important concepts in pro-
gramming. They are types that represent groups of elements.

In Kotlin, the most important collection types are:

- List, which represents an ordered collection of elements.
The same elements can occur multiple times. A list’s
elements can be accessed by indices (zero-based integer
numbers that reflect elements’ positions). An example
might be a list of songs in a queue: the order of the
songs is important, and each song can appear inmultiple
places.
- Set, which represents a collection of unique elements. It
reflects the mathematical abstraction of a set: a group
of objects without repetitions. Sets might not respect
element order (however, the default set used by Kotlin
does respect element order). An example might be a set
of winning numbers in a lottery: they must be unique,
but their order does not matter.
- Map (known as a dictionary in some other languages),
which represents a set of key-value pairs. Keys must be
unique, and each of them points to exactly one value.
Multiple keys can be associated with the same values.
    
    Maps are useful for expressing logical connections be-
    tween elements.
    

There are also arrays, which are typically considered a low-
level primitive used by other collections under the hood.

In this chapter, we will cover the most important topics re-
garding collections, starting from how they are organized,

how they are created, special kinds of collections, and how all
these kinds of collections are used in practice. This is a long
chapter, so let’s get started.

- **컬렉션**: 여러 원소의 묶음을 표현하는 타입.
- Kotlin의 핵심 컬렉션:
    - **List**: **순서 있음**, **중복 가능**, **인덱스 접근**. (예: 재생 대기열)
    - **Set**: **중복 없음**. 일반적으로 순서를 보장하지 않지만, **Kotlin 기본 Set은 순서를 보존**. (예: 로또 당첨 번호)
    - **Map**(= 사전): **키-값 쌍**. **키는 유일**, 하나의 키 → 하나의 값(여러 키가 같은 값 가리킬 수 있음). **요소 간 논리적 연결** 표현에 유용.
- **배열(Array)**: 보통 컬렉션들이 내부적으로 사용하는 **저수준 프리미티브**.
- 이 장에서는 컬렉션의 **조직(계층)**, **생성**, **특수 컬렉션**, **실전 사용법**을 다룸.

## 1. The hierarchy of interfaces

In Kotlin, a whole hierarchy of interfaces is used to represent
different kinds of collections. Take a look at the diagram
below.

![스크린샷 2025-09-12 오후 4.43.17.png](attachment:f1e704b5-c0c7-43e3-9648-0b3b7e0a99c5:스크린샷_2025-09-12_오후_4.43.17.png)

At the top of the hierarchy, there is Iterable, which represents
a sequence of elements that can be iterated over. We can
iterate over Iterable objects using a for-loop thanks to its
iterator method.

- 최상위는 **Iterable**: `for` 루프로 순회 가능한 **원소 시퀀스**.

```kotlin
interface Iterable<out T> {
    operator fun iterator(): Iterator<T> // for-루프를 가능케 하는 핵심 메서드
}
```

The next type is Collection, which represents a collection of

elements. Its methods are read-only (no methods for manip-
ulating the elements are available), so this interface does not

allow any modifications.

• 그다음 **Collection**: **읽기 전용** 컬렉션 공통 연산 제공(조작 메서드는 없음 → 수정 불가).

```kotlin
interface Collection<out E> : Iterable<E> {
    val size: Int
    fun isEmpty(): Boolean
    operator fun contains(element: E): Boolean
    override fun iterator(): Iterator<E>
    fun containsAll(elements: Collection<E>): Boolean
    // ✅ '읽기'에 관한 연산만 존재 (추가/삭제 없음)
}
```

- **List/Set만** `Collection` & `Iterable`의 **하위 타입**.
    
    **Map과 배열**은 이 계층 밖이지만, **for-루프로 순회는 가능**.
    
- 위 인터페이스들은 **읽기 전용**.
    
    변경이 필요하면 `MutableIterable` / `MutableCollection` / `MutableList` 등 **Mutable- 계열**이 **추가/삭제(clear, add, remove)** 같은 **변경 메서드**를 제공.
    

Notice that only List and Set are subtypes of Collection and

Iterable. Map and arrays are not part of this hierarchy; how-
ever, we can also iterate over them using a for-loop.

All the interfaces described so far are read-only, so they have
methods that allow what is inside to be read (like get, contains,
size) but not modified. MutableIterable, MutableCollection
and MutableList are sub-interfaces of, respectively, Iterable,
Collection and List, which add methods for modifying
elements (like remove, clear, add).
The actual classes used when we operate on collections are
platform-specific. For instance, if you create a list using the

listOf("A", "B") function on Kotlin/JVM version 1.7.20, the ac-
tual class is Arrays.ArrayList from the Java Standard Library;

however, if you use Kotlin/JS version 1.7.20, the actual class is
a JavaScript array. The point is to expect not a concrete class
but an object that represents a list (and therefore implements
a List interface). This is an application of a general idea: use

abstractions to make it easier to change the underlying rep-
resentations (e.g., for performance reasons) without pushing

breaking changes.

## 플랫폼 별 실제 구현 (요점)

- 실제 사용되는 클래스는 **플랫폼에 따라 달라짐**.
    - 예: Kotlin/JVM 1.7.20에서 `listOf("A", "B")` → **Java 표준 라이브러리의 `Arrays.ArrayList`**.
    - Kotlin/JS 1.7.20 → **JavaScript 배열**.
- 핵심 메시지: **구체 클래스에 기대지 말고**, “리스트”라는 **추상(인터페이스 `List`)**로 다뤄라.
    
    → 내부 표현을 바꿔도(성능 등 이유) **호환성을 해치지 않도록** 하는 일반 원칙.
    

## 2. Mutable vs read-only types

The distinction between mutable and read-only interfaces is
very important. For instance, the listOf function returns List,
which represents a read-only collection. List does not have
any functions that would allow its modification (functions 

like add or remove). This means a collection object cannot mu-
tate, but this doesn’t mean we cannot update a variable that

contains a collection.
It’s a similar story with Int or String. Both are immutable,
so they cannot change internally; however, we update their
values with operators like plus.

- **구분이 중요**: `listOf`는 **읽기 전용 `List`*를 반환 → `add/remove` 같은 **수정 메서드 없음**.
    
    → **컬렉션 객체 자체는 불변**이지만, **변수**에 **새 컬렉션**을 재할당하는 건 가능.
    
- `Int`/`String`처럼 **내부는 불변**이어도 `+` 등의 연산으로 **새 값을 만들어 변수에 대입**하는 것과 동일한 개념.
- **읽기 전용 컬렉션**도 `+` 연산 등으로 **새 컬렉션**을 만들어 **업데이트** 가능.
- 반면 `mutableListOf`가 만드는 **`MutableList`*는 **내부 수정(add/clear/remove)** 가능.
- **변환**: `toList()` ↔ `toMutableList()`로 상호 변환 가능.
    
    대부분은 `MutableList`가 **`List`의 서브타입**이라 **굳이 변환 없이** `List`로 사용할 수 있음.
    

```kotlin
fun main() {
    var a = 100
    a = a + 10
    a += 1
    println(a) // 111
    // ↑ 불변 Int지만 '새 값'을 만들어 변수에 재대입

    var str = "A"
    str = str + "B"
    str += "C"
    println(str) // ABC
    // ↑ String도 내부는 불변, 연산은 '새 String'을 반환
}
```

The same goes for read-only collections: we can use operators
to create a new collection with an updated value.

```kotlin
fun main() {
    var list = listOf("A", "B")  // 읽기 전용 List
    list = list + "C"            // ✅ 새 List를 만들어 재대입
    println(list)                 // [A, B, C]

    list = list + listOf("D", "E")
    println(list)                 // [A, B, C, D, E]

    list = listOf("Z") + list
    println(list)                 // [Z, A, B, C, D, E]
}
```

In contrast to read-only lists, mutable lists can be modified in-
ternally. So, if you create a collection using the mutableListOf

function, the result object is MutableList, which supports op-
erations like add, clear or remove.

```kotlin
fun main() {
    val mutable = mutableListOf("A", "B") // 가변 리스트
    mutable.add("C")                      // ✅ 내부 수정
    mutable.remove("A")                   // ✅ 내부 수정
    println(mutable)                      // [B, C]
}
```

You can easily transform between a mutable and a read-only
list with toList and toMutableList. However, you often do
not need to explicitly transform from a MutableList to a List.
MutableList is a subtype of List, so a MutableList can be used as
a List.
In the upcoming sections, we will see the most important
operators for modifying read-only collections, and methods
that can be used to modify mutable collections.

> 요점: “읽기 전용”은 객체 내부를 못 바꾼다는 뜻이지,
> 
> 
> 변수에 **새 컬렉션을 할당**해서 “업데이트처럼” 쓰는 건 가능.
> 

## 3. Creating collections

Most languages have support for a feature called a “collection

literal”, which is special syntax for creating a certain collec-
tion type based on the provided list of elements.

// JavaScript
const arr = ["A", "B"] // an array of strings
// Python
numbers = [1, 2, 3] // a list of numbers
names = {"Alex", "Barbara"} // a set of strings

In Kotlin, this role is performed by top-level functions. By
convention, their names start with the name of the type they
produce (starting from lower case) and the Of suffix. Here are
a few examples.

- 다른 언어의 **컬렉션 리터럴**(예: JS `[]`, Python `[]`/`{}`) 역할을, Kotlin은 **최상위 팩토리 함수**로 제공.
    
    **네이밍 관례**: 타입 소문자 + `Of` 접미사 (`listOf`, `setOf`, `mapOf`, …).
    
- `mapOf`는 **키-값 쌍**이 필요 → 보통 `Pair`를 만드는 `to`로 초기화.
- **컬렉션 변환**은 `toXxx` 계열 메서드(`toList`, `toMutableList`, `toSet`, …)로 수행.

```kotlin
fun main() {
    // We create `List` using `listOf` function.
    val list: List<String> = listOf("A", "B", "C") 

    // We create `MutableList` using `mutableListOf` function.
    val mutableList: MutableList<Int> = mutableListOf(1, 2, 3)

    // We create `Set` using `setOf` function.
    val set: Set<Double> = setOf(3.14, 7.11)

    // We create `MutableSet` using `mutableSetOf` function.
    val mutableSet: MutableSet<Char> = mutableSetOf('A', 'B')

    // We create `Map` using `mapOf` function.
    val map: Map<Char, String> =
        mapOf('A' to "Alex", 'B' to "Ben") // ← Pair는 'to'로 생성

    // We create `MutableMap` using `mutableMapOf` function.
    val mutableMap: MutableMap<Int, Char> =
        mutableMapOf(1 to 'A', 2 to 'B')

    // We create `Array` using `arrayOf` function.
    val array: Array<String> = arrayOf("Dukaj", "Sapkowski")

    // We create `IntArray` using `intArrayOf` function.
    val intArray: IntArray = intArrayOf(9, 8, 7)

    // We create `ArrayList` using `arrayListOf` function.
    val arrayList: ArrayList<String> = arrayListOf("M", "N")
}

```

To all these classes, we provide initial elements as arguments.
The only exception is map, which is a set of key-value pairs,
so we specify the initial pairs using Pair, which we typically
create using the to function (as explained in the chapter Data
classes).
We can also transform one collection into another. This can
often be done using amethod whose name is the type we want
to achieve, preceded by the to prefix.

```kotlin
fun main() {
    val list: List<Char> = listOf('A', 'B', 'C')

    val mutableList: MutableList<Char> = list.toMutableList() // List → MutableList
    val set: Set<Char> = mutableList.toSet()                  // MutableList → Set
    val mutableSet: MutableList<Char> = set.toMutableList()   // Set → MutableList

    val array: Array<Char> = mutableSet.toTypedArray()        // → Array<Char>
    val charArray: CharArray = array.toCharArray()            // Array → CharArray
    val list2: List<Char> = charArray.toList()                // CharArray → List
}
```

**팁**: `MutableList`는 `List`의 **서브타입**이므로,

“읽기 전용으로만 필요”하다면 **그대로 `List`처럼** 넘겨도 된다(명시 변환 불필요).

## 4. Lists

- **List**: 가장 기본 컬렉션. **순서가 있는 원소들의 집합**.
- `listOf` 결과 타입은 **`List<T>`(제네릭)**. 예: `List<String>`, `List<Int>`.
- **수정 방법 2가지**
    1. `var + 읽기 전용 List` → `+ / - / +=` 같은 **연산자로 새 리스트 생성**해 재대입.
    2. `val + MutableList` → `add / addAll / remove` 등 **내부 수정**.
    - `+=`를 읽기 전용 List에 쓰면 **새 컬렉션 생성 경고**(큰 리스트에서 성능 이슈 가능).
- **크기/비어있음**: `size`, `isEmpty()`.
- **인덱스 접근**: `list[i]`(= `get(i)`), 범위 밖이면 `IndexOutOfBoundsException`. 안전하게는 `getOrNull`, `getOrElse`.
- **검색/변경**: `indexOf`, `mutable[i] = ...`(= `set`).
- **포함 여부**: `contains`, `in` / `!in`.
- **반복**: `for (e in list) { ... }`
- `MutableList`는 `List`의 **서브타입** → 읽기 전용 API에도 그대로 사용 가능.

List is the most basic type of collection. You can treat it as
the default collection type. It represents an ordered list of
elements.

```kotlin
fun main() {
    val list = listOf("A", "B", "C")
    println(list) // [A, B, C]
}
```

List is a generic class. The result type of listOf is List<T>,
where T is the type of the elements in this list. Since we
have a list with string values in the code above, the type is

List<String>. More about generic classes in the chapter Gener-
ics.

```kotlin
fun main() {
    val list: List<String> = listOf("A", "B", "C")
    println(list) // [A, B, C]

    val ints: List<Int> = listOf(1, 2, 3)
    println(ints) // [1, 2, 3]
}
```

### Modifying lists

When you need to modify the elements of a list, you have two
options:

1. Use a read-only list in a var variable, and modify it using
operators like plus or minus.
2. Use a mutable list in a val variable, and modify it using
MutableList methods like add, addAll or remove.

```kotlin
fun main() {
    var list = listOf("A", "B")   // 읽기 전용 List를 var에 보관
    list = list + "C"             // ✅ 새 리스트 생성 후 재대입
    println(list)                 // [A, B, C]

    list = list + listOf("D", "E")
    println(list)                 // [A, B, C, D, E]

    list = listOf("Z") + list
    println(list)                 // [Z, A, B, C, D, E]

    list = list - "A"             // 원소 제거도 '새 리스트' 생성 방식
    println(list)                 // [Z, B, C, D, E]

    val mutable = mutableListOf("A", "B") // 가변 리스트를 val에 보관
    mutable.add("C")                       // ✅ 내부 수정
    println(mutable)                       // [A, B, C]

    mutable.addAll(listOf("D", "E"))
    println(mutable)                       // [A, B, C, D, E]

    mutable.add(0, "Z") // 첫 번째 인자는 인덱스
    println(mutable)     // [Z, A, B, C, D, E]

    mutable.remove("A")
    println(mutable)     // [Z, B, C, D, E]
}
```

> 메모: 읽기 전용 리스트에 += 를 쓰면 **새 컬렉션 생성** 경고(대용량 시 성능 주의).
> 
> 
> 내부 수정이 많다면 MutableList가 보통 더 효율적.
> 

Since the beginning of Kotlin, there have been discussions
about which of these two approaches should be preferred.
The first gives more freedom, but the second is considered
more efficient.

You can also use the += operator to add an element or a collec-
tion to a var variable that points to a read-only list, or to a val

variable that points to a mutable list.

```kotlin
fun main() {
    var list = listOf("A", "B")
    list += "C"                    // ⚠️ 새 리스트 생성(경고 가능)
    println(list)                  // [A, B, C]

    val mutable = mutableListOf("A", "B")
    mutable += "C"                 // ✅ 내부 수정으로 처리
    println(mutable)               // [A, B, C]
}
```

However, using += for read-only lists results in a warning that
a new collection has been created under the hood, which can
lead to performance issues when we are dealing with large
lists.

### Checking a list’s size or if it is empty

You can get the number of elements in a list using the size
property.

```kotlin
fun main() {
    val list = listOf("A", "B", "C")
    println(list.size)   // 3
}
```

A list is considered empty when its size is 0. You can also check
this using the isEmpty method.

```kotlin
fun main() {
    val list = listOf("A", "B", "C")
    println(list.size == 0) // false
    println(list.isEmpty()) // false

    val empty: Set<Int> = setOf()
    println(empty.size == 0) // true
    println(empty.isEmpty()) // true
}
```

### Lists and indices

Lists allow elements to be retrieved by their index, which is a
number that represents the element’s position. The index of
the first element is always 0, and each next element in the list
has the next index. You can imagine a list to be like an infinite
shelf for items, where there is a label with a number below
each item.

To get an element by an index, we use the box bracket. This
is a synonym of the get method. Both these methods throw an
IndexOutOfBoundsException when you try to get an element at an
index that does not exist.

```kotlin
fun main() {
    val list = listOf("A", "B")
    println(list[1])      // B
    println(list.get(1))  // B
    println(list[3])      // ❌ 런타임 에러: IndexOutOfBoundsException
}
```

If you are not sure if an index is correct, it is safer to use either
getOrNull, which returns null in the case of an incorrect index,
or getOrElse, which specifies the default value.

```kotlin
fun main() {
    val list = listOf("A", "B")
    println(list.getOrNull(1))         // B
    println(list.getOrElse(1) { "X" }) // B

    println(list.getOrNull(3))         // null
    println(list.getOrElse(3) { "X" }) // X
}
```

> 참고: `getOrPut`은 **`MutableMap` 전용**. 키가 없으면 생성해 넣고 반환 → 캐시 구현에 유용.
> 

There is also a useful functiongetOrPut, that can only be called
on MutableMap, that tries to find an element by key, and if it is
not there, it is creating it, adding it to the map and returning
it. This operation is useful when we use a map to cache some
values, so to keep values in local memory so that we do not
need to fetch or calculate them again.

```kotlin
fun main() {
    val map = mutableMapOf("A" to 1, "B" to 2)
    println(map.getOrPut("A") { 3 }) // 1 (이미 있었음)
    println(map.getOrPut("C") { 3 }) // 3 (없어서 넣고 반환)
    println(map) // {A=1, B=2, C=3}
}
```

You can find the index of an element using the indexOfmethod.
It returns -1 when there is no matching element in the list.

```kotlin
fun main() {
    val list = listOf("A", "B")
    println(list.indexOf("A")) // 0
    println(list.indexOf("B")) // 1
    println(list.indexOf("Z")) // -1 (없음)
}
```

In a mutable list, you can modify an element at a certain
index using the box bracket in an assignment, or using the set
method.

```kotlin
fun main() {
    val mutable = mutableListOf("A", "B", "C")
    mutable[1] = "X"        // 인덱스로 교체
    println(mutable)        // [A, X, C]

    mutable.set(1, "Y")     // set 메서드로도 동일
    println(mutable)        // [A, Y, C]
}
```

### Checking if a list contains an element

You can check if a list contains an element using the contains
method or the in operator.

```kotlin
fun main() {
    val letters = listOf("A", "B", "C")
    println(letters.contains("A")) // true
    println(letters.contains("Z")) // false
    println("A" in letters)        // true
    println("Z" in letters)        // false
}
```

You can also check whether a collection does not contain an
element using the !in operator.

```kotlin
fun main() {
    val letters = listOf("A", "B", "C")
    println("A" !in letters) // false
    println("Z" !in letters) // true
}
```

### Iterating over a list

You can iterate over a list using a for-loop. Just place the list
on the right side of in.

```kotlin
fun main() {
    val letters = listOf("A", "B", "C")
    for (letter in letters) {
        print(letter)
    }
}
```

> `MutableList`도 `List`를 구현하므로, 위 연산은 **가변 리스트에도 동일**하게 적용됩니다.
> 

Since MutableList implements List, all these operations can
also be used on mutable lists.
These are the most basic operations on lists. We will cover
more of them in the next book: Functional Kotlin.

## 5. Sets

- **언제 Set을 쓰나**
    1. **원소의 유일성**을 보장해야 할 때(중복 제거)
    2. **포함 여부 검사**를 자주 할 때(기본 Set은 해시 기반 → **평균 O(1)** 탐색, `hashCode` 구현에 의존)
- **리스트와의 차이**
    - Set은 **순서에 덜 민감**(일부 구현은 순서 미보장), **인덱스 접근 불가**
    - API는 유사하지만 “순서/인덱스” 관련 기능은 없음
- **생성 & 제네릭**: `setOf` → `Set<T>` 반환 (예: `Set<Char>`, `Set<Long>`)
- **수정 방법**
    - 읽기 전용 Set: `+ / -` 로 **새 Set**을 만들어 재대입
    - 가변 Set(`mutableSetOf`): `add / addAll / remove` 등 **내부 수정**
- **유일성 규칙**
    - **중복 값은 무시**되며, 동등성은 `==`(= `equals`) 기준
    - 일반 클래스는 서로 다른 인스턴스면 보통 **동등 아님**, `data class`는 **프로퍼티가 같으면 동등**
- **중복 제거 팁**: `list.toSet()`이 **가장 간단/효율적**
- **기본 연산**
    - 크기/비어있음: `size`, `isEmpty()`
    - 포함/비포함: `contains`, `in` / `!in`
    - 순회: `for (e in set) { ... }`

We use sets instead of lists when:

1. we want to ensure that elements in our collection are
unique (sets keep only unique elements),
2. we frequently look for an element in a collection (finding
elements in a set is much more efficient than doing so in
a list).

The default set is based on a hash table algorithm, which
makes finding an element with a properly implemented
hashCode really fast. This operation time does not depend on
the number of elements in the set (so has O(1) complexity).

Sets are quite similar to lists, which is why similar methods
are used to operate on them. However, sets do not treat order
as seriously as lists, and some kinds of sets do not respect
order at all. This is why we cannot get elements by index.
We create a set using the setOf function; then we specify its
values using arguments.

```kotlin
fun main() {
    val set = setOf('A', 'B', 'C')
    println(set) // [A, B, C]
}
```

Set is a generic class. The result type of setOf is Set<T>, where
T is the type of elements in this set. Since we have a set with
char values in the code above, the type is Set<Char>.

```kotlin
fun main() {
    val set: Set<Char> = setOf('A', 'B', 'C')
    println(set) // [A, B, C]

    val ints: Set<Long> = setOf(1L, 2L, 3L)
    println(ints) // [1, 2, 3]
}
```

### Modifying sets

You can add elements to a read-only set in the same way as to
a read-only list: using plus or minus.

**수정(읽기 전용 Set: 새 Set 생성 방식)**

```kotlin
fun main() {
    var set = setOf("A", "B")
    set = set + "C"
    println(set) // [A, B, C]

    set = set + setOf("D", "E")
    println(set) // [A, B, C, D, E]

    set = setOf("Z") + set
    println(set) // [Z, A, B, C, D, E]

    set = set - "A"
    println(set) // [Z, B, C, D, E]
}
```

You can also use a mutable set and its add, addAll or remove
methods.

**수정(가변 Set: 내부 수정 방식)**

```kotlin
fun main() {
    val mutable = mutableSetOf("A", "B")
    mutable.add("C")
    println(mutable) // [A, B, C]

    mutable.addAll(listOf("D", "E"))
    println(mutable) // [A, B, C, D, E]

    mutable.remove("B")
    println(mutable) // [A, C, D, E]
}

```

### Elements in a set are unique

Sets accept only unique elements. If elements repeat during
set creation, only the first occurrence will be present in the
set.

```kotlin
fun main() {
    val set = setOf("A", "B", "C", "B")
    println(set) // [A, B, C]  ← 중복 'B'는 제거됨
}
```

Adding an element that is equal to an element already present
in a set is ignored.

```kotlin
fun main() {
    val set = setOf("A", "B", "C")
    println(set + "D") // [A, B, C, D]
    println(set + "B") // [A, B, C]  ← 이미 있으므로 변화 없음

    val mutable = mutableSetOf("A", "B", "C")
    mutable.add("D")
    mutable.add("B")    // ← 이미 있으므로 무시
    println(mutable)    // [A, B, C, D]
}
```

Two elements are considered differentwhen comparing them
using the double equality sign returns false.

```kotlin
// by default, each object from a regular class is unique
class Cat(val name: String)

// if the data modifier is used,
// two instances with the same properties are equal
data class Dog(val name: String)

fun main() {
    val cat1 = Cat("Garfield")
    val cat2 = Cat("Garfield")
    println(cat1 == cat2)           // false
    println(setOf(cat1, cat2))      // [Cat@4eec7777, Cat@3b07d329]

    val dog1 = Dog("Rex")
    val dog2 = Dog("Rex")
    println(dog1 == dog2)           // true
    println(setOf(dog1, dog2))      // [Dog(name=Rex)]
}
```

The most efficient way to remove duplicates from a list is by
transforming it into a set.

```kotlin
fun main() {
    val names = listOf("Jake", "John", "Jake", "James", "Jan")
    println(names)           // [Jake, John, Jake, James, Jan]

    val unique = names.toSet()
    println(unique)          // [Jake, John, James, Jan]
}
```

### Checking a set’s size or if it is empty

You can always check the number of elements in a set using
the size property.

```kotlin
fun main() {
    val set = setOf('A', 'B', 'C')
    println(set.size) // 3
}
```

To check if a set is empty, you can compare its size to 0, or you
can use the isEmpty method.

```kotlin
fun main() {
    val set = setOf('A', 'B', 'C')
    println(set.size == 0) // false
    println(set.isEmpty()) // false

    val empty: Set<Int> = setOf()
    println(empty.size == 0) // true
    println(empty.isEmpty()) // true
}
```

### Checking if a set contains an element

You can check if a set contains a certain element by using the
contains method or the in operator. Both these options return
true if there is an element equal to the element you are looking
for in the set; otherwise, it returns false.

```kotlin
fun main() {
    val letters = setOf('A', 'B', 'C')
    println(letters.contains('A')) // true
    println(letters.contains('Z')) // false
    println('A' in letters)        // true
    println('Z' in letters)        // false
}
```

You can also check whether a set does not contain an element
using the !in operator.

```kotlin
fun main() {
    val letters = setOf("A", "B", "C")
    println("A" !in letters) // false
    println("Z" !in letters) // true
}
```

### Iterating over sets

You can iterate over a set using a for-loop. Just place the set on
the right side of in.

```kotlin
fun main() {
    val letters = setOf('A', 'B', 'C')
    for (letter in letters) {
        print(letter)
    }
}
```

> 메모: Set은 **인덱스 접근이 없고**, 구현 종류에 따라 **순서가 보장되지 않을 수 있음**.
> 
> 
> 기본 구현은 해시 기반(빠른 포함 검사), Kotlin 기본 Set은 삽입 순서를 보존하는 구현이 사용된다는 점도 기억해두면 좋아요.
> 

## 6. Maps

- **Map**: 키 → 값 연결(연관)을 저장.
    - 예) 사용자 ID → 사용자 객체, 도메인 → IP, 설정 이름 → 설정 데이터
- **제네릭**: `Map<K, V>` (키/값 타입은 달라도 됨)
- **빠른 조회**: 기본 Map은 **해시 테이블** 기반 → 적절한 `hashCode` 구현 시 **평균 O(1)** 조회
- **읽기 전용 vs 가변**
    - 읽기 전용 `Map`(예: `mapOf`)은 **추가/삭제 불가**, `+ / -`로 **새 Map**을 만들어 사용
    - 가변 `MutableMap`(예: `mutableMapOf`)은 `put`, `[]=`(대입), `remove`로 **내부 수정**
- **중복 키**: 같은 키를 넣으면 **기존 값이 교체**됨
- **기본 연산**: 조회 `[]/get`, 포함 `in/containsKey`, 크기 `size`, 순회 `for ((k,v) in map)`

We use maps to keep associations from keys to their values.
For instance:
• From user id to an object representing this user.
• From a website to its IP address.

- From a configuration name to data stored in this config-
uration.

**실사용 예 (캐시, 설정, 토큰 저장)**

```kotlin
class CachedApiArticleRepository(
    val articleApi: ArticleApi
) {
    // 가변 캐시: 키(String) → 컨텐츠(String)
    val articleCache: MutableMap<String, String> = mutableMapOf()

    fun getContent(key: String) =
        articleCache.getOrPut(key) {        // 키가 없으면 생성해서 넣고 반환
            articleApi.fetchContent(key)
        }
}

class DeliveryMethodsConfiguration(
    // 읽기 전용 설정 맵: 설정명(String) → DeliveryMethod
    val deliveryMethods: Map<String, DeliveryMethod>
)

class TokenRepository {
    private var tokenToUser: Map<String, User> = mapOf()

    fun getUser(token: String) = tokenToUser[token] // 조회는 OK(반환 타입은 User?)

    fun addToken(token: String, user: User) {
        // ⚠️ tokenToUser는 읽기 전용 Map이라 대입(변경) 불가.
        // 방법1) 가변으로 선언: MutableMap<String, User>
        // 방법2) 새 Map 재할당: tokenToUser = tokenToUser + (token to user)
        tokenToUser[token] = user
    }
}

```

You can create a map using the mapOf function and then use

key-value pairs as arguments to specify key-value associa-
tions. For instance, I might define a map that associates coun-
tries with their capitals. Pairs can be defined using a construc-
tor or the to function.

**생성(mapOf) — Pair는 보통 `to`로 만든다**

```kotlin
fun main() {
    val capitals = mapOf(
        "USA" to "Washington DC",
        "Poland" to "Warsaw",
    )
    // val capitals = mapOf(
    //     Pair("USA", "Washington DC"),
    //     Pair("Poland", "Warsaw"),
    // )
    println(capitals) // {USA=Washington DC, Poland=Warsaw}
}
```

Map is a generic class. The result type is Map<K, V>, where K is the
key type, and V is the value type. In the case of the map from
the capitals variable above, both the keys and the values are of
type String, so the map type is Map<String, String>. However,a
key does not need to be the same type as its value. Consider
a map with associations between letters and their positions
in the English alphabet, as in the example below. Its type is
Map<Char, Int> because its keys are characters and its values
are integers.

**타입(제네릭) 예시**

```kotlin
fun main() {
    val capitals: Map<String, String> = mapOf(
        "USA" to "Washington DC",
        "Poland" to "Warsaw",
    )
    println(capitals) // {USA=Washington DC, Poland=Warsaw}

    val alphabet: Map<Char, Int> = mapOf('A' to 1, 'B' to 2, 'C' to 3)
    println(alphabet) // {A=1, B=2, C=3}
}
```

### Finding a value by a key

To find a value by a key, you can use the get function or
box brackets with the key. For instance, to find the value 

for the key 'A' in the alphabet map, use alphabet.get('A') or
alphabet['A']. The result has a nullable value type, which is
Int? in this case. Why nullable? If the key you asked for is not
in the map, then null will be returned.

**키로 값 찾기(get / [])**

```kotlin
fun main() {
    val alphabet: Map<Char, Int> = mapOf('A' to 1, 'B' to 2, 'C' to 3)

    val number: Int? = alphabet['A']   // 값 타입은 nullable (없으면 null)
    println(number)                    // 1

    println(alphabet['B'])             // 2
    println(alphabet['&'])             // null
}
```

기본 Map은 해시 테이블 기반 →**빠른 키 조회(O(1))**

(단, 키 타입의 hashCode/equals 계약을 지켜야 함)

All the basic maps are optimized to make finding a value by a
key a very fast operation.

The defaultmap is based on a hash table algorithm, which
makes finding an element by key really fast (when this key
has a properly implemented hashCodemethod). This operation
time does not depend on the number of entries in the map
(so has O(1) complexity). For details about how this hash table
algorithm works, see Effective Kotlin Item 43: Respect the
contract of hashCode.

### Adding elements to a map

Just like a regular list or a regular set, a regular map is read-
only, so it does not have methods that would allow elements

to be added or removed. However, you can use the plus sign to
create a new map with new entries. If you add a pair to a map,
the result is a map with the new entry. If you add two maps
together, the result is a merge of these two maps.

**읽기 전용 Map: `+`/`-`로 새 Map 만들기**

```kotlin
fun main() {
    val map1 = mapOf('A' to "Alex", 'B' to "Bob")

    val map2 = map1 + ('C' to "Celina")  // 항목 추가된 새 Map
    println(map1) // {A=Alex, B=Bob}
    println(map2) // {A=Alex, B=Bob, C=Celina}

    val map3 = mapOf('D' to "Daniel", 'E' to "Ellen")
    val map4 = map2 + map3               // 두 Map 병합
    println(map3) // {D=Daniel, E=Ellen}
    println(map4) // {A=Alex, B=Bob, C=Celina, D=Daniel, E=Ellen}
}
```

Beware that duplicate keys are not allowed; so, when you add
a new value with an existing key, it replaces the old value.

**중복 키는 값 교체**

```kotlin
fun main() {
    val map1 = mapOf('A' to "Alex", 'B' to "Bob")
    val map2 = map1 + ('B' to "Barbara") // 'B' 값이 교체됨
    println(map1) // {A=Alex, B=Bob}
    println(map2) // {A=Alex, B=Barbara}
}
```

You can also remove a key from a map using the minus sign.

**키 제거(-)**

```kotlin
fun main() {
    val map1 = mapOf('A' to "Alex", 'B' to "Bob")
    val map2 = map1 - 'B'
    println(map1) // {A=Alex, B=Bob}
    println(map2) // {A=Alex}
}
```

### Checking if a map contains a key

You can check if yourmap contains a key using the in keyword
or the containsKey method.

**포함(키 존재)** 

```kotlin
fun main() {
    val map = mapOf('A' to "Alex", 'B' to "Bob")

    println('A' in map)            // true
    println(map.containsKey('A'))  // true

    println('Z' in map)            // false
    println(map.containsKey('Z'))  // false
}
```

### Checking map size

You can check how many entries you have in a map using the
size property.

**크기** 

```kotlin
fun main() {
    val map = mapOf('A' to "Alex", 'B' to "Bob")
    println(map.size) // 2
}
```

### Iterating over maps

You can iterate over a map using a for-loop. You iterate over
entries that contain key and value properties.

**순회**

```kotlin
fun main() {
    val map = mapOf('A' to "Alex", 'B' to "Bob")

    for (entry in map) {
        println("${entry.key} is for ${entry.value}")
    }
    // A is for Alex
    // B is for Bob
}
```

You can also destructure each entry into two variables. Kotlin

supports destructuring in a for-loop. Take a look at the example below.

```kotlin
fun main() {
    val map = mapOf('A' to "Alex", 'B' to "Bob")

    // 구조 분해로 키/값 바로 받기
    for ((letter, name) in map) {
        println("$letter is for $name")
    }
    // A is for Alex
    // B is for Bob
}
```

### Mutable maps - 내부 수정 메서드

You can create a mutable map using mutableMapOf. The result
type is MutableMap, which supports methods that modify this
object. Using it we can:
• add new entries to the map using the put method, or box
brackets and assignment,
• remove an entry by key using the remove method.

```kotlin
fun main() {
    val map: MutableMap<Char, String> = mutableMapOf('A' to "Alex", 'B' to "Bob")

    map.put('C', "Celina")  // 추가
    map['D'] = "Daria"      // 대입 문법으로도 추가/갱신
    println(map)            // {A=Alex, B=Bob, D=Daria, C=Celina}

    map.remove('B')         // 제거
    println(map)            // {A=Alex, D=Daria, C=Celina}
}
```

**읽기 전용 Map**은 `+/-`로 새 Map을 만들고, **가변 Map**은 `put / []= / remove`로 **제자리 수정**합니다.

## 7. Using arrays in practice

- **배열(Array)**: 연속된 메모리 블록에 원소를 저장 → **인덱스 접근 O(1)** 이 장점.
- 단점: **크기 고정**, **제한된 연산**, **인터페이스 미구현**, **toString/equals/hashCode 미적용(기본)**.
- 실무에선 `ArrayList` 등 컬렉션이 **내부적으로 배열을 활용**(그래서 인덱스 접근이 빠름).
    
    → **목록 작업은 보통 List/MutableList를 권장**, 배열은 **성능 최적화가 필요한 구간**에 한정.
    
- **생성/접근/수정/순회**: `arrayOf`, `arr[i]/get/set`, `size`, `for` 루프.

Array is a very basic data structure that strongly relates to
how memory is organized. Our computer’s memory is like a
big parking lot, where each place has a sequential number. An
array is like a reservation for a number of adherent spaces.
With such a reservation, it is really easy to iterate over the cars
you own. It is also easy to find a car with a specific index.

Let’s say that an array starts at position 1024 in your memory,
and you need to find the element at index 100 in the array.
You also know that each element takes 4 positions (an array
reserves constant space for its elements, which in most cases
is the size of the memory reference). This is an easy problem:

our element starts at the position 1024 + 100 * 4 = 1424. Ac-
cessing an element at a certain position is a very simple and

efficient operation, which is a big advantage of using arrays.

Using arrays directly is harder than using other kinds of col-
lections. They have a constant size, a limited number of oper-
ations, they do not implement any interface, and they do not

override the toString, equals or hashCode methods. However,
arrays are used by many other data structures under the hood.
For instance, when you use mutableListOf on Kotlin/JVM, the
result object is ArrayList, which keeps elements in an array.
This is why finding an element at an index in the default
list is so efficient. So, ArrayList has the advantages of arrays,
but it offers much more. Arrays have a constant size, so you
cannot add more elements than their size allows. When you
add an element to an ArrayList and its internal array is full
already, it creates a bigger one and fills it with the previous
values. We consider lists a preferred option to arrays, and we
restrict the usage of arrays to performance-critical parts of
our applications.
Arrays are also used by the default Set and Map that we use in
Kotlin. Both are based on a hash table algorithm that needs to
use an array to work efficiently.
Nevertheless, let’s see how arrays can be used directly. We
create an array using the arrayOf function. This creates an
instance of class Array and of type Array<T>, where T is the type
of the elements. To get an element at a certain index, we can
use box brackets or the get method. To modify an element at a
certain position, you can use box brackets or the set method.
You can also get an array’s size using the size property or by
iterating over the array using a for-loop.

**생성/접근/수정/순회**: `arrayOf`, `arr[i]/get/set`, `size`, `for` 루프.

```kotlin
fun main() {
    val arr: Array<String> = arrayOf("A", "B", "C")

    // 읽기
    println(arr[0])      // A
    println(arr.get(0))  // A
    println(arr[1])      // B

    // 쓰기
    arr[1] = "D"
    println(arr[1])      // D
    arr.set(2, "E")
    println(arr[2])      // E

    // 크기 / 순회
    println(arr.size)    // 3
    for (e in arr) {
        print(e)
    }
    // ADE
}
```

All the above operations are the same as for MutableList, but
this is where the list of basic array operations ends. Arrays do
not support equality, so two arrays with the same elements
are not considered equal. Another problem with arrays is that
their toString method, which is used to transform an object
into a String, does not print elements. It only prints the array
type and the hash of its memory reference.

배열은 **동등성/문자열화** 기본 지원이 약함(객체 참조 기준): `==`는 내용 비교가 아니라 **참조 비교**, `toString()`도 **타입@해시**만 출력.

```kotlin
fun main() {
    val arr1 = arrayOf("A", "B", "C")
    val arr2 = arrayOf("A", "B", "C")

    println(arr1 == arr2) // false  ← 동일 내용이어도 다른 배열(참조 비교)
    println(arr1)         // [Ljava.lang.String;@4f023edb
    println(arr2)         // [Ljava.lang.String;@3a71f4dd
}
```

To cheer up those who like using arrays, the Kotlin standard
library offers a number of extension functions that allow
many kinds of array transformations.

Notice that there is a plus method that allows a new element
to be added to an array. Just like the plus method on a list, it
does not modify the array but creates a new one with a larger
size.

표준 라이브러리의 **배열 확장 함수**로 여러 변환 지원. `+`는 **새 배열을 만들어 반환**

```kotlin
// JVM 구현 예시(개념 설명용)
operator fun <T> Array<T>.plus(element: T): Array<T> {
    val index = size
    val result = java.util.Arrays.copyOf(this, index + 1)
    result[index] = element
    return result
}

fun main() {
    val arr = arrayOf("A", "B", "C")
    println(arr.size)       // 3

    val arr2 = arr + "D"    // 새 배열 생성
    println(arr.size)       // 3
    println(arr2.size)      // 4
}
```

You can transform an array to a list or a set using the toList
and toSet methods. To transfer the other way around, use
toTypedArray.

**컬렉션 ↔ 배열 변환**: `toList`, `toSet`, `toTypedArray`.

```kotlin
fun main() {
    val arr1: Array<String> = arrayOf("A", "B", "C")
    val list: List<String> = arr1.toList()
    val arr2: Array<String> = list.toTypedArray()
    val set: Set<String> = arr2.toSet()
    val arr3: Array<String> = set.toTypedArray()
}

```

### Arrays of primitives

- `Int`, `Char` 같은 **값 타입(primitive)**은 **메모리/성능 최적화**된 전용 배열 제공:
    
    `IntArray`, `LongArray`, `DoubleArray`, `FloatArray`, `CharArray`, `BooleanArray`, `ShortArray`, `ByteArray`.
    
- 생성 방법:
    1. `xxxArrayOf(...)`
    2. 컬렉션에서 `toXxxArray()` 변환

Some kinds of Kotlin value types, like Int or Char, can be
represented in a more basic way than a regular object. This
form is known as a primitive and is a Kotlin optimization
that does not affect the usage of values; however, it makes

primitive values take less memory and their use more effi-
cient. The problem is that primitives cannot be kept in regular

collections, but we can store them in special arrays. For each
value that has a primitive form, there is a dedicated array type.
These are:

- IntArray, which represents an array of primitive Int val-
ues.
- LongArray, which represents an array of primitive Long
values.
•DoubleArray, which represents an array of primitive
Double values.
• FloatArray, which represents an array of primitive Float
values.
• CharArray, which represents an array of primitive Char
values.
• BooleanArray, which represents an array of primitive
Boolean values.
- ShortArray, which represents an array of primitive Short
values.
• ByteArray, which represents an array of primitive Byte
values.

Each of these arrays can be created in two ways:

- Using the xxxOf function and initial elements as argu-
ments, where xxx is the decapitalized name of the ar-
ray. For example, to create DoubleArray, you can use the

doubleArrayOf function with arguments of type Double.

- By transforming another kind of collection into an ar-
ray of primitives using the toXXX method, where XXX is

the name of the array. For instance, you can transform
List<Boolean> into BooleanArray using the toBooleanArray
method.

```kotlin
fun main() {
    val doubles: DoubleArray = doubleArrayOf(2.71, 3.14, 9.8)
    val chars: CharArray = charArrayOf('X', 'Y', 'Z')

    val accepts: List<Boolean> = listOf(true, false, true)
    val acceptsArr: BooleanArray = accepts.toBooleanArray()

    val ints: Set<Int> = setOf(2, 4, 8, 10)
    val intsArr: IntArray = ints.toIntArray()
}
```

보통 실무에서는 **드물게 사용**(주로 **성능/메모리 최적화** 목적).

Arrays of primitives are not used often in most real-life
projects. They are generally treated as low-level performance
or memory use optimizations.

### Vararg parameters and array functions

- `vararg` 파라미터는 함수 내부에서 **배열(Array)** 로 다뤄짐.
- `listOf`, `setOf` 같은 팩토리 함수도 `vararg`로 임의 개수의 인자를 받음.
- 배열을 `vararg`에 **전개**하려면 (spread) 사용.

As mentioned in the chapter Functions, we can use the vararg
modifier for a parameter to make it accept any number of
arguments. This modifier turns a parameter into an array.
Consider the markdownList function from the example below.
Its lines parameter has String type specified, but since it has
the modifier vararg, the actual type of lines is Array<String>.
This is why we can iterate over it using a for loop.

```kotlin
fun markdownList(vararg lines: String): String {
    // lines 의 실제 타입은 Array<String>
    var str = ""
    for ((i, line) in lines.withIndex()) {
        str += " * $line"
        if (i != lines.size) {
            str += "\n"
        }
    }
    return str
}

fun main() {
    print(markdownList("A", "B", "C"))
    // * A
    // * B
    // * C
}
```

The basic functions used to create collections, like listOf or
setOf, can have any number of arguments because they use the
vararg modifier.

```kotlin
fun <T> listOf(vararg elements: T): List<T> =
    if (elements.size > 0) elements.asList() else emptyList()

fun <T> setOf(vararg elements: T): Set<T> =
    if (elements.size > 0) elements.toSet() else emptySet()
```

You can also spread an array into vararg arguments using the

* symbol.

```kotlin
fun main() {
    val arr = arrayOf("B", "C")
    print(markdownList("A", *arr, "D"))
    // * A
    // * B
    // * C
    // * D
}
```

### 8. Summary

In this chapter we’ve seen the most important kinds of Kotlin
collections and their typical use-cases:
• List represents an ordered collection of elements. It is
the most basic way to keep a collection of elements.
• Set represents a collection of unique elements. We use
it when we want to make sure that elements in our
collection are unique, or when we often need to look for
a certain element.

- Map is a set of key-value pairs. We use it to keep associa-
tions from keys to values.

Arrays are rarely used directly in Kotlin as we prefer to use
other kinds of collections.

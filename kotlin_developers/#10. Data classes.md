In Kotlin, we say that all classes inherit from the Any super-
class, which is at the top of the class hierarchy49. Methods

defined in Any can be called on all objects. These methods are:
â€¢ equals - used when two objects are compared using ==, `ê°ì²´ ë¹„êµ ì‹œ ì‚¬ìš©`
â€¢ hashCode - used by collections that use the hash table
algorithm, `í•´ì‹œ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ëŠ” ì»¬ë ‰ì…˜ì—ì„œ ì‚¬ìš©`
â€¢ toString - used to represent an object as a string, e.g., in
a string template or the print function. `ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ í‘œí˜„í•  ë•Œ ì‚¬ìš©`
Thanks to these methods, we can represent any object as a
string or check the equality of any two objects.

```kotlin
// Any formal definition
open class Any {
	open operator fun equals(other: Any?): Boolean
	open fun hashCode(): Int
	open fun toString(): String
}

class A // Implicitly inherits from Any

fun main() {
	val a = A()
	a.equals(a)
	a == a
	a.hashCode()
	a.toString()
	println(a)
}
```

Truth be told, Any is represented as a class, but
it should actually be considered the head of the 

type hierarchy, but with some special functions.
Consider the fact that Any is also the supertype of all
interfaces, even though interfaces cannot inherit
from classes.

So Any is an analog to Object in Java, JavaScript or C#.
There is no direct analog in C++.

The default implementations of equals, hashCode, and toString
are strongly based on the objectâ€™s address in memory. The

equals method returns true only when the address of both ob-
jects is the same,whichmeans the same object is on both sides.

The hashCode method typically transforms an address into a
number. toString produces a string that starts with the class
name, then the at sign â€œ@â€, then the unsigned hexadecimal
representation of the hash code of the object.

```kotlin
class A

fun main() {
	val a1 = A()
	val a2 = A()
	println(a1.equals(a1)) // true
	println(a1.equals(a2)) // false
	// or
	println(a1 == a1) // true
	println(a1 == a2) // false
	println(a1.hashCode()) // Example: 149928006
	println(a2.hashCode()) // Example: 713338599
	println(a1.toString()) // Example: A@8efb846
	println(a2.toString()) // Example: A@2a84aee7
	// or
	println(a1) // Example: A@8efb846
	println(a2) // Example: A@2a84aee7
}
```

- *`equals(a1, a2)`*ëŠ” ë‘ ê°ì²´ë¥¼ ë¹„êµí•˜ëŠ” ë©”ì„œë“œë¡œ, ê°ì²´ **a1**ê³¼ **a2**ì˜ ì£¼ì†Œê°€ ë‹¤ë¥´ë©´ `false`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
- *`hashCode()`*ëŠ” ê°ì²´ì˜ ì£¼ì†Œë¥¼ **í•´ì‹œê°’**ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
- *`toString()`*ì€ ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ í‘œí˜„í•  ë•Œ ì‚¬ìš©ë˜ë©°, ê¸°ë³¸ì ìœ¼ë¡œ **í´ë˜ìŠ¤ ì´ë¦„ + "@" + í•´ì‹œì½”ë“œ**ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

By overriding these methods, we can decide how a class
should behave. Consider the following class A, which is equal to other instances of the same class and returns a constant
hash code and string representation.

```kotlin
class A {
	override fun equals(other: Any?): Boolean = other is A
	override fun hashCode(): Int = 123
	override fun toString(): String = "A()"
}

fun main() {
	val a1 = A()
	val a2 = A()
	println(a1.equals(a1)) // true
	println(a1.equals(a2)) // true
	// or
	println(a1 == a1) // true
	println(a1 == a2) // true
	println(a1.hashCode()) // 123
	println(a2.hashCode()) // 123
	println(a1.toString()) // A()
	println(a2.toString()) // A()
	// or
	println(a1) // A()
	println(a2) // A()
}
```

- `class A`ì—ì„œ **`equals()`, `hashCode()`, `toString()` ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¼ì´ë“œ**í•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” ì´ ë©”ì„œë“œë“¤ì´ **`Any` í´ë˜ìŠ¤ì—ì„œ `open`ìœ¼ë¡œ ì •ì˜**ë˜ì–´ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
- *`Any` í´ë˜ìŠ¤ëŠ” `open`*ìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´ **ëª¨ë“  í´ë˜ìŠ¤ëŠ” `Any`ë¥¼ ìƒì†**ë°›ê³ , `Any`ì—ì„œ ì œê³µí•˜ëŠ” **ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¼ì´ë“œ**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **`class A`ëŠ” `open`ì´ ì•„ë‹ˆì–´ë„ `Any` í´ë˜ìŠ¤ì˜ ë©”ì„œë“œëŠ” ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥**í•©ë‹ˆë‹¤.

ë”°ë¼ì„œ **`Any`ì˜ ë©”ì„œë“œëŠ” `open`ìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´ì„œ ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥**í•˜ë©°, **`class A`ì—ì„œ ì´ë¥¼ ì˜¤ë²„ë¼ì´ë“œ**í•  ìˆ˜ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤!

Iâ€™ve dedicated separate items in the Effective Kotlin book to
implementing a custom equals and hashCode50, but in practice
we rarely need to do that. As it turns out, in modern projects
we almost solely operate on only two kinds of objects:

- Active objects, like services, controllers, repositories,
etc. Such classes donâ€™t need to override any methods
from Any because the default behavior is perfect for
them.
â€¢ Data model class objects, which represent bundles of
data. For such objects, we use the data modifier, which
overrides the toString, equals, and hashCode methods.
The data modifier also implements the methods copy
and componentN (component1, component2, etc.), which are
not inherited and cannot be modified.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

val player = Player(0, "Gecko", 9999)
```

### ğŸ§© ë°ì´í„° í´ë˜ìŠ¤ì˜ íŠ¹ì§•

1. **ìë™ ì˜¤ë²„ë¼ì´ë”©**: `equals()`, `hashCode()`, `toString()` ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.
2. **`copy()` ë©”ì„œë“œ**: ê°ì²´ì˜ ë³µì‚¬ë¥¼ ì‰½ê²Œ í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.
3. **`componentN()` ë©”ì„œë“œ**: ê° í”„ë¡œí¼í‹°ë¥¼ ì‰½ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

Letâ€™s discuss the aforementioned implicit data class methods
and the differences between regular class behavior and data
class behavior.

```kotlin
data class Player(
    val id: Int,
    val name: String,
    val points: Int
)

fun main() {
    val player1 = Player(1, "John", 100)
    val player2 = player1.copy(id = 2, name = "Alex") // ë³µì‚¬í•´ì„œ ìƒˆ ê°ì²´ ìƒì„±

    println(player1) // Player(id=1, name=John, points=100)
    println(player2) // Player(id=2, name=Alex, points=100)

    // componentN()ì„ ì‚¬ìš©í•˜ì—¬ í”„ë¡œí¼í‹° ì ‘ê·¼
    val (id, name, points) = player2
    println("$name has $points points") // Alex has 100 points
}

```

- *`copy()`*ëŠ” ê°ì²´ë¥¼ ë³µì‚¬í•˜ë©´ì„œ ì¼ë¶€ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- *`componentN()`*ì€ ë°ì´í„° í´ë˜ìŠ¤ì˜ ê° í”„ë¡œí¼í‹°ì— ì ‘ê·¼í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.

## âœ… **`Any`ì™€ `Data Class` ì°¨ì´ì  ìš”ì•½**

| í•­ëª© | `Any` | `Data Class` |
| --- | --- | --- |
| **ê¸°ë³¸ ë©”ì„œë“œ** | `equals()`, `hashCode()`, `toString()`ì„ **ê¸°ë³¸ ì œê³µ**í•˜ë©°, **ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥** | `equals()`, `hashCode()`, `toString()`ì„ **ìë™ìœ¼ë¡œ ì˜¤ë²„ë¼ì´ë“œ** |
| **ì£¼ìš” ì‚¬ìš©** | **ëª¨ë“  í´ë˜ìŠ¤ì˜ ìµœìƒìœ„ í´ë˜ìŠ¤**, ëª¨ë“  ê°ì²´ëŠ” **`Any`**ë¥¼ ìƒì† | **ë°ì´í„° ëª¨ë¸ì„ ìœ„í•œ í´ë˜ìŠ¤** |
| **ì¶”ê°€ ë©”ì„œë“œ** | **ì—†ìŒ** | `copy()`, `componentN()` ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ ì œê³µ |

## 1. Transforming to a string

The default toString transformation produces a string that
starts with the class name, then the at sign â€œ@â€, and then the
unsigned hexadecimal representation of the hash code of the
object. The purpose of this is to display the class name and to
determine whether two strings represent the same object or
not.

This type of class is so popular that in Java it is common

practice to auto-generate equals, hashCode, and toString in In-
telliJ or using the Lombok library.

```kotlin
class FakeUserRepository

fun main() {
	val repository1 = FakeUserRepository()
	val repository2 = FakeUserRepository()
	println(repository1) // e.g. FakeUserRepository@8efb846
	println(repository1) // e.g. FakeUserRepository@8efb846
	println(repository2) // e.g. FakeUserRepository@2a84aee7
}
```

ì´ ë©”ì„œë“œëŠ” ê°ì²´ë¥¼ ë¬¸ìì—´ë¡œ í‘œí˜„í•  ë•Œ ì‚¬ìš©ë˜ë©°, **ê°™ì€ ê°ì²´ì¸ì§€ ë‹¤ë¥¸ ê°ì²´ì¸ì§€ë¥¼ í™•ì¸í•˜ëŠ” ë°** ìœ ìš©í•©ë‹ˆë‹¤.

With the data modifier, the compiler generates a toString
that displays the class name and then pairs with the name
and value for each primary constructor property. We assume
that data classes are represented by their primary constructor
properties, so all these properties, together with their values,
are displayed during a transformation to a string. This is
useful for logging and debugging.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	val player = Player(0, "Gecko", 9999)
	println(player)
	// Player(id=0, name=Gecko, points=9999)
	println("Player: $player")
	// Player: Player(id=0, name=Gecko, points=9999)
}
```

Kotlinì—ì„œëŠ” **ë¬¸ìì—´ í…œí”Œë¦¿**ì´ë‚˜ **`println()`** í•¨ìˆ˜ê°€ **ê°ì²´ë¥¼ ì¶œë ¥í•  ë•Œ** ê°ì²´ì˜ **`toString()`** ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ê°ì²´ë¥¼ **ë¬¸ìì—´ë¡œ ë³€í™˜**í•©ë‹ˆë‹¤.

- Kotlinì—ì„œ ë¬¸ìì—´ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ë©´ **`$player`** ë¶€ë¶„ì´ **`player.toString()`*ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.
- ì¦‰, **`player.toString()`*ì´ í˜¸ì¶œë˜ì–´ `Player(id=0, name=Gecko, points=9999)`ê°€ ë¬¸ìì—´ì— ì‚½ì…ë˜ê³ , `"Player: Player(id=0, name=Gecko, points=9999)"`ë¼ëŠ” ë¬¸ìì—´ì´ ì¶œë ¥ë©ë‹ˆë‹¤.

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2025-08-12 á„‹á…©á„’á…® 4.22.34.png](attachment:05ecb16b-947a-4a95-ad2b-0edd39981205:á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º_2025-08-12_á„‹á…©á„’á…®_4.22.34.png)

## 2. Objects equality

In Kotlin, we check the equality of two objects using ==, which
uses the equals method from Any. So, this method decides if
two objects should be considered equal or not. By default,
two different instances are never equal. This is perfect for
active objects, i.e., objects that work independently of other
instances of the same class and possibly have a protected
mutable state.

```kotlin
class FakeUserRepository

fun main() {
	val repository1 = FakeUserRepository()
	val repository2 = FakeUserRepository()
	println(repository1 == repository1) // true
	println(repository1 == repository2) // false
}
```

Classes with the data modifier represent bundles of data; they
are considered equal to other instances if:
â€¢ both are of the same class,
â€¢ their primary constructor property values are equal.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)
fun main() {
	val player = Player(0, "Gecko", 9999)
	println(player == Player(0, "Gecko", 9999)) // true
	println(player == Player(0, "Ross", 9999)) // false
}
```

This is what a simplified implementation of the equals method
generated by the data modifier for the Player class looks like:

```kotlin
override fun equals(other: Any?): Boolean = other is Player &&
other.id == this.id &&
other.name == this.name &&
other.points == this.points
```

Implementing a custom equals is described in Effec-
tive Kotlin, Item 42: Respect the contract of equals.

## 3. Hash code

Another method from Any is hashCode, which is used to trans-
form an object into an Int. With a hashCode method, the object

instance can be stored in the hash table data structure imple-
mentations that are part of many popular classes, including

HashSet and HashMap. The most important rule of the hashCode
implementation is that it should:
â€¢ be consistent with equals, so it should return the same
Int for equal objects, and it must always return the same
hash code for the same object.
â€¢ spread objects as uniformly as possible in the range of all
possible Int values.
The default hashCode is based on an objectâ€™s address inmemory.
The hashCode generated by the data modifier is based on the
hash codes of this objectâ€™s primary constructor properties. In
both cases, the same number is returned for equal objects.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
	println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
	println(Player(0, "Ross", 9999).hashCode()) // 79159602
}
```

To learn more about the hash table algorithm and implement-
ing a custom hashCode method, see Effective Kotlin, Item 41:

Respect the contract of hashCode.

### ìë™ ìƒì„±ëœ `hashCode()` ë©”ì„œë“œ ì˜ˆì‹œ

`data class`ì—ì„œ ìë™ìœ¼ë¡œ ìƒì„±ë˜ëŠ” **`hashCode()`** ë©”ì„œë“œëŠ” ë³´í†µ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```kotlin

override fun hashCode(): Int {
    var result = id
    result = 31 * result + name.hashCode()
    result = 31 * result + points
    return result
}

```

- `hashCode()` ë©”ì„œë“œëŠ” **`id`, `name`, `points`*ì˜ í•´ì‹œ ì½”ë“œ ê°’ì„ ì‚¬ìš©í•˜ì—¬ **ê°ì²´ì˜ ê³ ìœ í•œ í•´ì‹œ ì½”ë“œ**ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

### **`hashCode()`ì™€ `equals()`ì˜ ê³„ì•½**

`hashCode()`ì™€ **`equals()`**ëŠ” **ê³„ì•½ì„ ë”°ë¼ì•¼** í•©ë‹ˆë‹¤. **`equals()`**ê°€ `true`ë¥¼ ë°˜í™˜í•˜ëŠ” ê°ì²´ëŠ” **ë°˜ë“œì‹œ ë™ì¼í•œ `hashCode()`**ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ê·œì¹™ì„ ì§€í‚¤ì§€ ì•Šìœ¼ë©´, ê°ì²´ë¥¼ **`HashSet`**, **`HashMap`** ê°™ì€ ìë£Œ êµ¬ì¡°ì—ì„œ ì œëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.

---

### **ê²°ë¡  ë° ìš”ì•½**

- *`hashCode()`*ëŠ” **ê°ì²´ë¥¼ `Int`ë¡œ ë³€í™˜**í•˜ëŠ” ë©”ì„œë“œë¡œ, **í•´ì‹œ í…Œì´ë¸”** ìë£Œ êµ¬ì¡°ì—ì„œ ê°ì²´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
- *`data class`*ëŠ” **ì£¼ ìƒì„±ì í”„ë¡œí¼í‹°**ë¥¼ ê¸°ë°˜ìœ¼ë¡œ **ìë™ìœ¼ë¡œ `hashCode()`** ë©”ì„œë“œë¥¼ ìƒì„±í•˜ë©°, ê°ì²´ ë¹„êµ ë° í•´ì‹œ ê°’ì„ ê³„ì‚°í•  ë•Œ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
- *`equals()`*ì™€ **`hashCode()`*ëŠ” **ë™ì¼í•œ ê°ì²´**ë¥¼ íŒë‹¨í•  ë•Œ ì¼ê´€ë˜ê²Œ ë™ì‘í•´ì•¼ í•©ë‹ˆë‹¤.

---

### âœ… í•œ ì¤„ ìš”ì•½

> **hashCode()**ëŠ” ê°ì²´ë¥¼ Int ê°’ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë©”ì„œë“œë¡œ, **data class**ì—ì„œ ì£¼ ìƒì„±ìì˜ í”„ë¡œí¼í‹°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìë™ìœ¼ë¡œ ìƒì„±ë˜ë©°, **equals()**ì™€ í•¨ê»˜ ì¼ê´€ëœ ê°ì²´ ë¹„êµë¥¼ ì œê³µí•©ë‹ˆë‹¤.
> 

## 4. Copying objects

Another method generated by the data modifier is copy, which
is used to create a new instance of a class but with a concrete
modification. The idea is very simple: it is a function with
parameters for each primary constructor property, but each
of these parameters has a default value, i.e., the current value
of the associated property.

```kotlin
// This is how copy generated by data modifier
// for Person class looks like under the hood
fun copy(
	id: Int = this.id,
	name: String = this.name,
	points: Int = this.points
) = Player(id, name, points)
```

This means we can call copy with no parameters to make a
copy of our object with no modifications, but we can also
specify new values for the properties we want to change.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)
fun main() {
	val p = Player(0, "Gecko", 9999)
	println(p.copy()) // Player(id=0, name=Gecko, points=9999)
	println(p.copy(id = 1, name = "New name"))
	// Player(id=1, name=New name, points=9999)
	println(p.copy(points = p.points + 1))
	// Player(id=0, name=Gecko, points=10000)
}
```

Note that copy creates a shallow copy of an object; so, if our
object holds a mutable state, a change in one object will be a
change in all its copies too.

```kotlin
data class StudentGrades(
	val studentId: String,
	// Code smell: Avoid using mutable objects in data classes
	val grades: MutableList<Int>
)

fun main() {
	val grades1 = StudentGrades("1", mutableListOf()) // grades1 ìƒì„±
	val grades2 = grades1.copy(studentId = "2") // grades1ì„ ë³µì‚¬í•˜ì—¬ grades2 ìƒì„±

	println(grades1) // Grades(studentId=1, grades=[])
	println(grades2) // Grades(studentId=2, grades=[])
	grades1.grades.add(5)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[5])
	// grades1.grades.add(5)ë¥¼ ì‹¤í–‰í•˜ë©´ grades1ì˜ **grades** ë¦¬ìŠ¤íŠ¸ì— 5ê°€ ì¶”ê°€ë©ë‹ˆë‹¤. 
	// í•˜ì§€ë§Œ grades1ê³¼ grades2ëŠ” ë™ì¼í•œ **MutableList** ê°ì²´ë¥¼ ì°¸ì¡°í•˜ê³  ìˆìœ¼ë¯€ë¡œ, grades2ì˜ **grades**ì—ë„ 5ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.
	grades2.grades.add(1)
	println(grades1) // Grades(studentId=1, grades=[5, 1])
	println(grades2) // Grades(studentId=2, grades=[5, 1])
	// grades2.grades.add(1)ì„ í˜¸ì¶œí•˜ë©´, 
	// grades2ì˜ grades ë¦¬ìŠ¤íŠ¸ì— 1ì´ ì¶”ê°€ë©ë‹ˆë‹¤. 
	// ê°™ì€ ë¦¬ìŠ¤íŠ¸ ê°ì²´ë¥¼ ì°¸ì¡°í•˜ê³  ìˆê¸° ë•Œë¬¸ì—, grades1ì˜ **grades**ì—ë„ 1ì´ ì¶”ê°€ë©ë‹ˆë‹¤.
}
```

`copy()` ë©”ì„œë“œëŠ” **ì–•ì€ ë³µì‚¬**(shallow copy)ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì¦‰, **ê°ì²´ê°€ ì°¸ì¡°í•˜ëŠ” ê°€ë³€ ê°ì²´ëŠ” ë³µì‚¬ë˜ì§€ ì•Šê³ , ì°¸ì¡°ë§Œ ë³µì‚¬**ë©ë‹ˆë‹¤. ë”°ë¼ì„œ **ê°€ë³€ ìƒíƒœ**ë¥¼ ê°€ì§„ ê°ì²´ëŠ” **ë³µì‚¬ë³¸ì—ì„œë„ ë™ì¼í•œ ìƒíƒœë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤**.

**`grades`**ëŠ” ê°€ë³€ ê°ì²´(MutableList)ì´ê¸° ë•Œë¬¸ì—, **`grades1`**ì—ì„œ ë³€ê²½ëœ ì‚¬í•­ì´ **`grades2`**ì—ë„ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤.

ì´ë¡œ ì¸í•´ **`grades1`**ê³¼ **`grades2`**ëŠ” **`grades`** ë¦¬ìŠ¤íŠ¸ì˜ **ê°™ì€ ì°¸ì¡°ë¥¼ ê³µìœ **í•˜ê²Œ ë©ë‹ˆë‹¤. ì´ë•Œ `grades1`ì˜ **`grades`**ëŠ” **ë¹ˆ `MutableList`**ì…ë‹ˆë‹¤.

### **`copy()`ì™€ ì–•ì€ ë³µì‚¬**

- *`copy()`*ëŠ” **ì–•ì€ ë³µì‚¬**ë¥¼ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì—, ë‚´ë¶€ì˜ **ê°€ë³€ ê°ì²´**(ì˜ˆ: `MutableList`)ëŠ” ë³µì‚¬ë˜ì§€ ì•Šê³  **ì°¸ì¡°ë§Œ ë³µì‚¬**ë©ë‹ˆë‹¤. ì´ë¡œ ì¸í•´ **í•œ ê°ì²´ì—ì„œ ê°€ë³€ ìƒíƒœë¥¼ ë³€ê²½í•˜ë©´ ë‹¤ë¥¸ ê°ì²´ì—ë„ ì˜í–¥ì„ ë¯¸ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤**.

Kotlinì—ì„œ **ì–•ì€ ë³µì‚¬**ëŠ” **`copy()`** ë©”ì„œë“œë¥¼ í†µí•´ ìë™ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë©°, **ê¹Šì€ ë³µì‚¬**ëŠ” í•„ìš”ì— ë”°ë¼ **ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„**í•´ì•¼ í•©ë‹ˆë‹¤.

We do not have this problem when we use copy for immutable

classes, i.e., classes with only val properties that hold im-
mutable values. copy was introduced as special support for

immutability (for details, see Effective Kotlin, Item 1: Limit
mutability).

```kotlin
data class StudentGrades(
	val studentId: String,
	val grades: List<Int>  // ë¶ˆë³€ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©
)

fun main() {
	var grades1 = StudentGrades("1", listOf())
	var grades2 = grades1.copy(studentId = "2")
	println(grades1) // Grades(studentId=1, grades=[])
	println(grades2) // Grades(studentId=2, grades=[])
	grades1 = grades1.copy(grades = grades1.grades + 5)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[])
	grades2 = grades2.copy(grades = grades2.grades + 1)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[1])
}
```

Notice that data classes are unsuitable for objects that must
maintain invariant constraints on mutable properties. For
example, in the User example below, the class would not be
able to guarantee that the name and surname values are not
blank if these variables were mutable (so, defined with var).
Data classes are perfectly fit for immutable properties, whose
constraints might be checked during the creation of these
objects. In the example below, we can be sure that the name and
surname values are not blank in an instance of User.

```kotlin
data class User(
	val name: String,
	val surname: String,
) {
	init {
		require(name.isNotBlank())
		// throws exception if name is blank
		require(surname.isNotBlank())
		// throws exception if surname is blank
	}
}
```

### 1. **`data class`ê°€ ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ê°’ì„ ë‹¤ë£° ë•Œ ìœ ìš©í•œ ì´ìœ **

`data class`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ **ë¶ˆë³€ì„±(immutability)**ì„ ì—¼ë‘ì— ë‘ê³  ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤. `data class`ëŠ” ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§‘ë‹ˆë‹¤:

- **`val` í”„ë¡œí¼í‹°**: `data class`ì˜ ì£¼ ìƒì„±ìëŠ” **ê¸°ë³¸ì ìœ¼ë¡œ `val` í”„ë¡œí¼í‹°**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ í”„ë¡œí¼í‹°ëŠ” **ì½ê¸° ì „ìš©**ì´ë©°, í•œ ë²ˆ ì´ˆê¸°í™”ëœ ê°’ì€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ `data class`ëŠ” **ë¶ˆë³€ ê°ì²´**ë¡œ ì‘ì—…í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.
- **ìë™ ìƒì„±ëœ ë©”ì„œë“œ**: `data class`ëŠ” **`equals()``, **`hashCode()`*, **`toString()`** ë“±ì˜ ë©”ì„œë“œë¥¼ **ìë™ìœ¼ë¡œ ìƒì„±**í•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œë“¤ì€ ê°ì²´ê°€ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê²½ìš° (ë¶ˆë³€ì„±) ì™„ë²½í•˜ê²Œ ë™ì‘í•˜ì—¬, ë¹„êµ ë° ë¬¸ìì—´ ë³€í™˜ì„ ì‰½ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **`copy()` ë©”ì„œë“œ**: `data class`ëŠ” **`copy()`** ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬, ê°ì²´ì˜ **ë³µì‚¬ë³¸ì„ ë§Œë“¤ë˜ ì¼ë¶€ ì†ì„±ë§Œ ë³€ê²½**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë¶ˆë³€ ê°ì²´ì—ì„œ ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³ ë„ ìƒˆë¡œìš´ ê°’ì„ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤.

ë”°ë¼ì„œ **`data class`ëŠ” ë¶ˆë³€ ë°ì´í„°ë¥¼ ë‹¤ë£° ë•Œ ë§¤ìš° ìœ ìš©**í•˜ë©°, **ìƒíƒœ ë³€ê²½ì„ ìµœì†Œí™”**í•˜ë©´ì„œ **ê°ì²´ë¥¼ ë‹¤ë£¨ê¸° ìš©ì´**í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.

### ì˜ˆì‹œ: ë¶ˆë³€ ë°ì´í„°ë¥¼ ë‹¤ë£° ë•Œ ìœ ìš©í•œ `data class`

```kotlin
kotlin
ë³µì‚¬
data class Player(
    val id: Int,
    val name: String,
    val points: Int
)

fun main() {
    val player = Player(1, "Gecko", 9999)
    println(player)  // Player(id=1, name=Gecko, points=9999)

    // copy()ë¡œ ìƒˆë¡œìš´ ê°ì²´ ìƒì„±
    val newPlayer = player.copy(name = "Alex")
    println(newPlayer)  // Player(id=1, name=Alex, points=9999)
}

```

ìœ„ì™€ ê°™ì€ ì˜ˆì‹œì—ì„œ `Player`ëŠ” **ë¶ˆë³€ ê°ì²´**ì´ë©°, **`copy()`** ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ **ìƒˆë¡œìš´ ê°ì²´ë¥¼ ë§Œë“¤ë˜, ê¸°ì¡´ ê°ì²´ëŠ” ë³€ê²½í•˜ì§€** ì•ŠìŠµë‹ˆë‹¤. ì´ì²˜ëŸ¼ `data class`ëŠ” **ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ë°ì´í„°**ë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### 2. **ê°€ë³€ ê°ì²´ê°€ í•„ìš”í•œ ê²½ìš°, `init` ë¸”ë¡ ì‚¬ìš©**

ë§ìŠµë‹ˆë‹¤! `data class` ë‚´ì—ì„œ **ê°€ë³€ ê°ì²´**ë¥¼ í¬í•¨í•  í•„ìš”ê°€ ìˆì„ ê²½ìš°, **`init` ë¸”ë¡**ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ìƒì„± ì‹œ íŠ¹ì • ê²€ì¦ì´ë‚˜ ì´ˆê¸°í™” ì‘ì—…ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `data class`ëŠ” **`val`**ë¡œ ë¶ˆë³€ í”„ë¡œí¼í‹°ë¥¼ ë§ì´ ì‚¬ìš©í•˜ì§€ë§Œ, ë§Œì•½ **ê°€ë³€ ê°ì²´**(ì˜ˆ: `MutableList`, `MutableMap`)ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤ë©´ **`init` ë¸”ë¡**ì—ì„œ ì´ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì˜ˆì‹œ: `init` ë¸”ë¡ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°

```kotlin
kotlin
ë³µì‚¬
data class StudentGrades(
    val studentId: String,
    val grades: MutableList<Int> = mutableListOf()  // ê°€ë³€ ê°ì²´
) {
    init {
        // gradesê°€ ë¹„ì–´ìˆìœ¼ë©´ ê¸°ë³¸ ê°’ì„ ì¶”ê°€
        if (grades.isEmpty()) {
            grades.add(0)
        }
    }
}

fun main() {
    val student = StudentGrades("1")
    println(student)  // StudentGrades(studentId=1, grades=[0])

    student.grades.add(5)
    println(student)  // StudentGrades(studentId=1, grades=[0, 5])
}

```

### ì •ë¦¬

- **`data class`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¶ˆë³€ ë°ì´í„°ë¥¼ ë‹¤ë£° ë•Œ ìœ ìš©**í•©ë‹ˆë‹¤. **`val` í”„ë¡œí¼í‹°**ì™€ **ìë™ ìƒì„±ëœ ë©”ì„œë“œ** ë•ë¶„ì— **ë¶ˆë³€ì„±**ì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **ê°€ë³€ ê°ì²´ê°€ í•„ìš”í•œ ê²½ìš°**, **`init` ë¸”ë¡**ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ìƒì„± ì‹œ ì´ˆê¸°í™”ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ì´ë¥¼ í†µí•´ **ë¶ˆë³€ì„±**ì„ ì§€í‚¤ë©´ì„œ í•„ìš”í•œ ê°’ì„ ì¶”ê°€í•˜ê±°ë‚˜ ê²€ì¦í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 5. Destructuring

Kotlin supports a feature called position-based destructuring,
which lets us assign multiple variables to components of a
single object. For that, we place our variable names in round
brackets.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	val player = Player(0, "Gecko", 9999)
	val (id, name, pts) = player
	println(id) // 0
	println(name) // Gecko
	println(pts) // 9999
}
```

- ì´ë•Œ, **êµ¬ì¡° ë¶„í•´ëŠ” ë³€ìˆ˜ì˜ ìˆœì„œ**ì— ë§ì¶° ê°’ì„ í• ë‹¹í•©ë‹ˆë‹¤.
- *`data class`*ì—ì„œëŠ” **`componentN`** ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ê° **ì†ì„± ê°’ì„** **ìˆœì„œëŒ€ë¡œ ë°˜í™˜**í•©ë‹ˆë‹¤.

This mechanism relies on position, not names. The object
on the right side of the equality sign needs to provide the
functions component1, component2, etc., and the variables are
assigned to the results of these methods.

```kotlin
val (id, name, pts) = player
// is compiled to
val id: Int = player.component1()
val name: String = player.component2()
val pts: Int = player.component3()
```

**`component1()`**, **`component2()`**, **`component3()`** ë©”ì„œë“œëŠ” **`data class`**ì˜ **ì£¼ ìƒì„±ì**ì— ì •ì˜ëœ **ê° í”„ë¡œí¼í‹°**ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œë“¤ì€ **ìˆœì„œëŒ€ë¡œ** ìƒì„±ë˜ë©°, `component1`ì€ ì²« ë²ˆì§¸ í”„ë¡œí¼í‹°ì¸ **`id`**ë¥¼ ë°˜í™˜í•˜ê³ , `component2`ëŠ” **`name`**ì„ ë°˜í™˜í•˜ë©°, `component3`ëŠ” **`points`**ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

### **`data class`ì™€ `componentN` ë©”ì„œë“œ**

Kotlinì—ì„œ **`data class`**ëŠ” **ì£¼ ìƒì„±ìì˜ í”„ë¡œí¼í‹°**ë¥¼ ê¸°ë°˜ìœ¼ë¡œ **ìë™ìœ¼ë¡œ `componentN()` ë©”ì„œë“œë¥¼ ìƒì„±**í•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œëŠ” ê° í”„ë¡œí¼í‹°ì— ëŒ€ì‘í•˜ëŠ” ê°’ì„ ë°˜í™˜í•˜ë©°, **êµ¬ì¡° ë¶„í•´**ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

### **`data class`ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ì´ìœ **

`data class`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ **`toString()`**, **`equals()`**, **`hashCode()`**, **`copy()`**, ê·¸ë¦¬ê³  **`componentN()`** ë©”ì„œë“œë¥¼ **ìë™ìœ¼ë¡œ ìƒì„±**í•©ë‹ˆë‹¤. **êµ¬ì¡° ë¶„í•´**ëŠ” ê·¸ ì¤‘ í•˜ë‚˜ë¡œ, ê°ì²´ë¥¼ **ì—¬ëŸ¬ ë³€ìˆ˜ì— ë‚˜ëˆ„ì–´ í• ë‹¹í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥**ì…ë‹ˆë‹¤.

ë”°ë¼ì„œ, **êµ¬ì¡° ë¶„í•´ê°€ í•„ìš”í•œ ê²½ìš°**ì—ëŠ” **`data class`**ë¥¼ ì‚¬ìš©í•˜ë©´ **ìë™ìœ¼ë¡œ í•„ìš”í•œ ë©”ì„œë“œë“¤ì´ ìƒì„±**ë˜ì–´ í¸ë¦¬í•©ë‹ˆë‹¤.

### **ì •ë¦¬**

- *`data class`*ëŠ” **êµ¬ì¡° ë¶„í•´**ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ **`componentN()` ë©”ì„œë“œ**ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
- êµ¬ì¡° ë¶„í•´ëŠ” **`==` ì—°ì‚°ì**ë¡œ **ê°ì²´ ë¹„êµ**í•  ë•Œì²˜ëŸ¼ ê°ì²´ì˜ **í”„ë¡œí¼í‹° ìˆœì„œëŒ€ë¡œ ê°’**ì„ ì¶”ì¶œí•´ **ì—¬ëŸ¬ ë³€ìˆ˜ì— í• ë‹¹**í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.
- *`data class`*ëŠ” **ë¶ˆë³€ ë°ì´í„°**ë¥¼ ì²˜ë¦¬í•  ë•Œ **í¸ë¦¬í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°**, **êµ¬ì¡° ë¶„í•´** ì™¸ì—ë„ **ìë™ ìƒì„±ë˜ëŠ” ë©”ì„œë“œë“¤**ì„ í™œìš©í•˜ì—¬ ì½”ë“œì˜ íš¨ìœ¨ì„±ì„ ë†’ì…ë‹ˆë‹¤.

This code works because the data modifier generates
componentN functions for each primary constructor parameter,
according to their order in the constructor.

These are currently all the functionalities that the data mod-
ifier provides. Donâ€™t use it if you donâ€™t need toString, equals, 

hashCode, copy or destructuring. If you need some of these func-
tionalities for a class representing a bundle of data, use the

data modifier instead of implementing the methods yourself.

## 6. When and how should we use destructuring?

Position-based destructuring has pros and cons. Its biggest
advantage is that we can name variables however we want,
so we can use names like country and city in the example
below. We can also destructure anything we want as long
as it provides componentN functions. This includes List and
Map.Entry, both of which have componentN functions defined as
extensions:

```kotlin
fun main() {
	val visited = listOf("Spain", "Morocco", "India")
	val (first, second, third) = visited
	println("$first $second $third")
	// Spain Morocco India
	val trip = mapOf(
	"Spain" to "Gran Canaria",
	"Morocco" to "Taghazout",
	"India" to "Rishikesh"
)

for ((country, city) in trip) {
	println("We loved $city in $country")
	// We loved Gran Canaria in Spain
	// We loved Taghazout in Morocco
	// We loved Rishikesh in India
	}
}
```

### ì¥ì :

- **ë³€ìˆ˜ ì´ë¦„ì„ ììœ ë¡­ê²Œ ì§€ì •**í•  ìˆ˜ ìˆì–´ ì§ê´€ì ì¸ ë³€ìˆ˜ ì´ë¦„ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **`componentN()` í•¨ìˆ˜**ë§Œ ìˆìœ¼ë©´ **ì–´ë–¤ ê°ì²´ë“  ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤**. ì˜ˆë¥¼ ë“¤ì–´, `List`ë‚˜ `Map.Entry`ë„ **`componentN()` í•¨ìˆ˜**ê°€ í™•ì¥ í•¨ìˆ˜ë¡œ ì œê³µë˜ê¸° ë•Œë¬¸ì—, ì´ë¥¼ ì´ìš©í•˜ì—¬ êµ¬ì¡° ë¶„í•´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

On the other hand, position-based destructuring is danger-
ous. We need to adjust every destructuring when the order

or number of elements in a data class changes. When we use
this feature, it is very easy to introduce errors into our code by
changing the order of the primary constructorâ€™s properties.

```kotlin
data class FullName(
	val firstName: String,
	val secondName: String,
	val lastName: String
)

val elon = FullName("Elon", "Reeve", "Musk")
val (name, surname) = elon
print("It is $name $surname!") // It is Elon Reeve!
```

ìœ„ì™€ ê°™ì€ ê²½ìš°ì—ëŠ” **`firstName`**ê³¼ **`secondName`**ì— í• ë‹¹ë˜ê³ , **`lastName`**ì€ í• ë‹¹ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ, í• ë‹¹ë˜ì§€ ì•Šì€ ê°’ì€ **ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë˜ë¯€ë¡œ** ì£¼ì˜ê°€ í•„ìš”.

We need to be careful with destructuring. It is useful to use
the same names as data class primary constructor properties.
In the case of an incorrect order, an IntelliJ/Android Studio
warningwill be shown. Itmight even be useful to upgrade this
warning to an error.

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2025-08-12 á„‹á…©á„’á…® 9.27.41.png](attachment:b41ceb91-d08c-42ac-a230-5fce227a9087:á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º_2025-08-12_á„‹á…©á„’á…®_9.27.41.png)

Destructuring a single value in lambda is very confusing,

especially since parentheses around arguments in lambda ex-
pressions are either optional or required in some languages.

```kotlin
data class User(
	val name: String,
	val surname: String,
)

fun main() {
	val users = listOf(
	User("Nicola", "Corti")
	)
	users.forEach { u -> println(u) }
	// User(name=Nicola, surname=Corti)
	users.forEach { (u) -> println(u) }
	// Nicola
}
```

- ì²« ë²ˆì§¸ **`forEach`*ì—ì„œëŠ” `u`ê°€ `User` ê°ì²´ ì „ì²´ë¥¼ ì°¸ì¡°í•˜ê³  ì¶œë ¥ë©ë‹ˆë‹¤. **ì¶œë ¥**: `User(name=Nicola, surname=Corti)`
- ë‘ ë²ˆì§¸ **`forEach`*ì—ì„œëŠ” **êµ¬ì¡° ë¶„í•´**ë¥¼ ì‚¬ìš©í•˜ì—¬ **`User` ê°ì²´ì˜ `name`ê³¼ `surname`ì„** **ë¶„í•´**í•˜ì—¬ `name`ë§Œ ì¶œë ¥í•©ë‹ˆë‹¤. **ì¶œë ¥**: `Nicola`

ì´ ì˜ˆì‹œì—ì„œ `u`ë¥¼ **ê´„í˜¸ë¡œ ê°ì‹¸ëŠ”** ê²ƒì€ **ëŒë‹¤ì‹ì—ì„œ êµ¬ì¡° ë¶„í•´**ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. **`(u)`**ëŠ” **`User` ê°ì²´ì˜ `name` ì†ì„±**ë§Œì„ ì°¸ì¡°í•˜ê²Œ ë©ë‹ˆë‹¤.

**êµ¬ì¡° ë¶„í•´**ì—ì„œ **ê´„í˜¸ ì•ˆì— `u`** í•˜ë‚˜ë§Œ ìˆëŠ” ê²½ìš°, **`User` ê°ì²´ì˜ ì²« ë²ˆì§¸ ì†ì„±ë§Œ** ë¶„ë¦¬í•˜ì—¬ ë³€ìˆ˜ `u`ì— í• ë‹¹ë©ë‹ˆë‹¤.

- ì¦‰, **`name`ë§Œ `u`ì— í• ë‹¹**ë˜ë©°, **`surname`ì€ í• ë‹¹ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤**.

```kotlin
users.forEach { (name, surname) -> println(name) }  // nameë§Œ ì¶œë ¥
users.forEach { (_, surname) -> println(surname) }  // surnameë§Œ ì¶œë ¥

```

## 7. Data class limitations

The idea behind data classes is that they represent a bundle
of data; their constructors allow us to specify all this data,
and we can access it through destructuring or by copying
them to another instance with the copy method. This is why
only primary constructor properties are considered by the
methods defined in data classes.

```kotlin
data class Dog(
	val name: String,
) {
	// Bad practice, avoid mutable properties in data classes
	var trained = false
}

fun main() {
	val d1 = Dog("Cookie")
	d1.trained = true
	println(d1) // Dog(name=Cookie)
	// so nothing about trained property
	val d2 = d1.copy()
	println(d1.trained) // true
	println(d2.trained) // false
	// so trained value not copied
}
```

- **ì£¼ ìƒì„±ì ì†ì„±**(ì˜ˆ: `name`)ì€ **`data class` ë©”ì„œë“œì—ì„œ ê³ ë ¤**ë˜ì§€ë§Œ, **í´ë˜ìŠ¤ ë³¸ë¬¸ ì†ì„±**(ì˜ˆ: `trained`)ì€ **ë³µì‚¬ë˜ì§€ ì•Šìœ¼ë©° `toString()`ì—ë„ í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤**.
- *`trained`*ëŠ” **`copy()`** ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ë³µì‚¬ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, `d1`ê³¼ `d2`ëŠ” **`trained` ê°’**ì´ ë‹¤ë¥´ê²Œ ì¶œë ¥ë©ë‹ˆë‹¤.
- **ë°ì´í„° í´ë˜ìŠ¤ì—ì„œëŠ” ì£¼ ìƒì„±ìì˜ ì†ì„±ë§Œ ì¤‘ìš”í•œ ì˜ë¯¸ë¥¼ ê°–ê³ , ê·¸ ì™¸ì˜ ì†ì„±ì€ ë¬´ì‹œë©ë‹ˆë‹¤**.

Data classes are supposed to keep all the essential properties
in their primary constructor. Inside the body, we should only

keep redundant immutable properties, which means proper-
ties whose value is distinctly calculated from primary con-
structor properties, like fullName, which is calculated from

name and surname. Such values are also ignored by data class 

methods, but their value will always be correct because it will
be calculated when a new object is created.

```kotlin
data class FullName(
	val name: String,
	val surname: String,
) {
	val fullName = "$name $surname"
}

fun main() {
	val d1 = FullName("Cookie", "MoskaÅ‚a")
	println(d1.fullName) // Cookie MoskaÅ‚a
	println(d1) // FullName(name=Cookie, surname=MoskaÅ‚a)
	val d2 = d1.copy()
	println(d2.fullName) // Cookie MoskaÅ‚a
	println(d2) // FullName(name=Cookie, surname=MoskaÅ‚a)
}
```

**ì£¼ ìƒì„±ì**ì— ì†í•˜ì§€ ì•ŠëŠ” ì†ì„±ì€ **ë³µì‚¬(copy)**ì™€ ê°™ì€ **`data class` ë©”ì„œë“œ**ì—ì„œ ë¬´ì‹œë©ë‹ˆë‹¤. ì´ì™€ ê°™ì€ ì†ì„±ì€ **ë¶ˆë³€(immutable)**ì´ì–´ì•¼ í•˜ë©°, **ì£¼ ìƒì„±ì ì†ì„±**ìœ¼ë¡œ ê³„ì‚°ëœ ê°’ë§Œ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.

- *`fullName`*ì€ **ì£¼ ìƒì„±ì ì†ì„±**ì¸ **`name`*ê³¼ **`surname`*ì„ **ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ëœ ë¶ˆë³€ ê°’**ì…ë‹ˆë‹¤.
- ë°ì´í„° í´ë˜ìŠ¤ ë©”ì„œë“œëŠ” **ì£¼ ìƒì„±ì ì†ì„±ë§Œ**ì„ ê³ ë ¤í•˜ì§€ë§Œ, **`fullName`** ì†ì„±ì€ **ë³µì‚¬(copy)** ì‹œì—ë„ **ì˜¬ë°”ë¥´ê²Œ ê³„ì‚°**ë©ë‹ˆë‹¤.

**ë°ì´í„° í´ë˜ìŠ¤ëŠ” `final`ì´ì–´ì•¼ í•˜ë¯€ë¡œ ìƒì† ë¶ˆê°€**

You should also remember that data classes must be final and
so cannot be used as a super-type for inheritance.

### **ë³¸ë¬¸ ì†ì„±ì„ ì •ì˜í•´ì•¼ í•  ê²½ìš°:**

**ë³¸ë¬¸ ì†ì„±**ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ëŠ” ì£¼ë¡œ **ê³„ì‚°ëœ ê°’**ì„ ì €ì¥í•˜ê±°ë‚˜, **ë¶ˆë³€ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ì¶”ê°€ì ì¸ ê³„ì‚°**ì´ í•„ìš”í•œ ê²½ìš°ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, **`fullName`**ê³¼ ê°™ì´ **ì£¼ ìƒì„±ì ì†ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ê³„ì‚°ëœ ê°’**ì„ ì €ì¥í•˜ê³ ì í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### ì˜ˆì‹œ 1: ê³„ì‚°ëœ ê°’ì„ ì €ì¥í•˜ê¸°

```kotlin
kotlin
ë³µì‚¬
data class Person(
    val firstName: String,
    val lastName: String
) {
    // ê³„ì‚°ëœ ì†ì„±
    val fullName = "$firstName $lastName"
}

fun main() {
    val person = Person("John", "Doe")
    println(person.fullName) // John Doe
    println(person) // Person(firstName=John, lastName=Doe)
}

```

ì´ ì˜ˆì‹œì—ì„œ **`fullName`**ì€ **ì£¼ ìƒì„±ì ì†ì„±**ì¸ **`firstName`**ê³¼ **`lastName`**ì„ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ëœ ê°’ì…ë‹ˆë‹¤. ì´ì™€ ê°™ì€ ì†ì„±ì€ **ë¶ˆë³€**ì´ë©°, **ë³µì‚¬(copy)** ì‹œ ìë™ìœ¼ë¡œ **ë‹¤ì‹œ ê³„ì‚°**ë©ë‹ˆë‹¤.

### ì˜ˆì‹œ 2: ì¶”ê°€ì ì¸ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì €ì¥í•˜ê¸°

```kotlin
kotlin
ë³µì‚¬
data class Rectangle(
    val width: Int,
    val height: Int
) {
    // ê³„ì‚°ëœ ì†ì„±
    val area: Int = width * height
}

fun main() {
    val rect = Rectangle(10, 5)
    println(rect.area)  // 50
}

```

ì—¬ê¸°ì„œ **`area`**ëŠ” **`width`**ì™€ **`height`**ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ëœ ê°’ì…ë‹ˆë‹¤. **`area`**ëŠ” **ì£¼ ìƒì„±ì ì†ì„±**ì´ ì•„ë‹ˆì§€ë§Œ, ë°ì´í„° í´ë˜ìŠ¤ë¡œ **`toString()`**ì´ë‚˜ **`copy()`**ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ **`area`**ë¥¼ ê°ì²´ë¥¼ ë‹¤ë£° ë•Œ í•„ìš”ë¡œ í•  ê²½ìš° **ë³¸ë¬¸ ì†ì„±ìœ¼ë¡œ ì •ì˜**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### **ë³¸ë¬¸ ì†ì„±ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ì´ìœ :**

1. **ê³„ì‚°ëœ ê°’**ì„ ë‹¤ë£° ë•Œ: **ì£¼ ìƒì„±ì ì†ì„±**ë§Œìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ì—†ëŠ” ê³„ì‚°ëœ ì†ì„±ì„ ë‹¤ë£° ë•Œ ë³¸ë¬¸ ì†ì„±ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ **`fullName`**, **`area`*ì™€ ê°™ì´ **ì£¼ ìƒì„±ì ì†ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ë˜ëŠ” ê°’**ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
2. **ë¶ˆë³€ ë°ì´í„° í´ë˜ìŠ¤**ì˜ ì†ì„±ìœ¼ë¡œ, ì£¼ ìƒì„±ì ì†ì„±ë§Œìœ¼ë¡œëŠ” ë‹¤ë£° ìˆ˜ ì—†ëŠ” ê°’ì„ ì €ì¥í•˜ê³  ì‹¶ì„ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.
3. **ë°ì´í„° í´ë˜ìŠ¤ì˜ íŠ¹ì„±ìƒ, ì£¼ ìƒì„±ì ì†ì„±** ì™¸ì˜ **ì¶”ê°€ ì†ì„±**ì´ í•„ìš”í•  ê²½ìš°, ë³¸ë¬¸ ì†ì„±ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### **`data class`ì—ì„œ ë³¸ë¬¸ ì†ì„± ì‚¬ìš©ì˜ í•œê³„:**

- **`toString()`, `copy()`, `equals()`** ë©”ì„œë“œì—ì„œëŠ” **ë³¸ë¬¸ ì†ì„±ì´ ë¬´ì‹œ**ë©ë‹ˆë‹¤. ì¦‰, **ë³¸ë¬¸ ì†ì„±ì€ ì£¼ ìƒì„±ì ì†ì„±ì— ë¹„í•´ ê´€ë¦¬ê°€ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤**.
- **ë°ì´í„° í´ë˜ìŠ¤ì˜ ëª©ì ì€** **ì£¼ ìƒì„±ì ì†ì„±**ì— ëŒ€í•œ ë°ì´í„° ìº¡ìŠí™”ì´ë¯€ë¡œ **ë³¸ë¬¸ ì†ì„±ì€ ë³´ì¡°ì ì¸ ì—­í• **ë§Œ í•˜ë„ë¡ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

## 8. Prefer data classes instead of tuples

Data classes offer more than what is generally provided by
tuples. Historically, they replaced tuples in Kotlin since they
are considered better practice52. The only tuples that are left
are Pair and Triple, but these are data classes under the hood:

```kotlin
data class Pair<out A, out B>(
	val first: A,
	val second: B
) : Serializable {
	override fun toString(): String =
		"($first, $second)"
}

data class Triple<out A, out B, out C>(
	val first: A,
	val second: B,
	val third: C
) : Serializable {
	override fun toString(): String =
		"($first, $second, $third)"
}
```

Kotlin had support for tuples when it was still in the
beta version. We were able to define a tuple by brackets and
a set of types, like (Int, String, String, Long). What we
achieved behaved the same as data classes in the end, but it
was far less readable. Can you guess what type this set of types
represents? It can be anything. Using tuples is tempting, but
using data classes is nearly always better. This is why tuples
were removed, and only Pair and Triple are left.

The easiest way to create a Pair is by using the to function.
This is a generic infix extension function, defined as follows
(we will discuss both generic and extension functions in later
chapters).

```kotlin
infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```

Thanks to the infix modifier, a method can be used by placing
its name between arguments, as the infix name suggests. The
result Pair is typed, so the result type from the "ABC" to 123
expression is Pair<String, Int>.

```kotlin
fun main() {
	val p1: Pair<String, Int> = "ABC" to 123
	println(p1) // (ABC, 123)
	val p2 = 'A' to 3.14
	// the type of p2 is Pair<Char, Double>
	println(p2) // (A, 123)
	val p3 = true to false
	// the type of p3 is Pair<Boolean, Boolean>
	println(p3) // (true, false)
}
```

**`to`** í•¨ìˆ˜ëŠ” **ë‘ ê°’ì„ í•˜ë‚˜ì˜ íŠœí”Œë¡œ ë¬¶ì–´ì£¼ëŠ” ì—­í• **ì„ í•˜ë©°, **`Pair`** ë˜ëŠ” **`Triple`**ê³¼ ê°™ì€ ë°ì´í„° í´ë˜ìŠ¤ íƒ€ì…ìœ¼ë¡œ ë¬¶ì–´ì¤ë‹ˆë‹¤.

These tuples remain because they are very useful for local
purposes, like:

â€¢ When we immediately name values:

```kotlin
val (description, color) = when {
	degrees < 5 -> "cold" to Color.BLUE
	degrees < 23 -> "mild" to Color.YELLOW
	else -> "hot" to Color.RED
}
```

- To represent an aggregate that is not known in advance,
as is commonly the case in standard library functions:

```kotlin
val (odd, even) = numbers.partition { it % 2 == 1 }
val map = mapOf(1 to "San Francisco", 2 to "Amsterdam")
```

ì—¬ê¸°ì„œ **`to`**ëŠ” **`Pair`**ë¥¼ ìƒì„±í•˜ê³ , ì´ **`Pair`**ëŠ” **`Map.Entry`**ì™€ ìœ ì‚¬í•˜ê²Œ í‚¤ì™€ ê°’ì„ ë¬¶ì–´ì„œ ì €ì¥í•©ë‹ˆë‹¤.

In other cases, we prefer data classes. Take a look at an exam-
ple: letâ€™s say that we need a function that parses a full name

into a name and a surname. One might represent this name
and surname as a Pair<String, String>:

```kotlin
fun String.parseName(): Pair<String, String>? {
	val indexOfLastSpace = this.trim().lastIndexOf(' ')
	if (indexOfLastSpace < 0) return null
	val firstName = this.take(indexOfLastSpace)
	val lastName = this.drop(indexOfLastSpace)
	return Pair(firstName, lastName)
}
// Usage
fun main() {
	val fullName = "Marcin MoskaÅ‚a"
	val (firstName, lastName) = fullName.parseName() ?: return
}
```

ì´ ì˜ˆì‹œì—ì„œ **`Pair`**ëŠ” **`firstName`**ê³¼ **`lastName`**ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤. í•˜ì§€ë§Œ **`Pair<String, String>`**ì„ ì‚¬ìš©í•˜ë©´ **ìˆœì„œê°€ í˜¼ë™**ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, **`lastName`**ì´ **`firstName`**ë³´ë‹¤ ë¨¼ì € ì˜¬ ìˆ˜ ìˆë‹¤ëŠ” ì˜¤í•´ë¥¼ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

The problem is that when someone reads this code, it is not
clear that Pair<String, String> represents a full name.What is
more, it is not clear what the order of the values is, therefore
someone might think that the surname goes first:

```kotlin
val fullName = "Marcin MoskaÅ‚a"
val (lastName, firstName) = fullName.parseName() ?: return
print("His name is $firstName") // His name is MoskaÅ‚a
```

To make usage safer and the function easier to read, we should
use a data class instead:

```kotlin
data class FullName(
	val firstName: String,
	val lastName: String
)

fun String.parseName(): FullName? {
	val indexOfLastSpace = this.trim().lastIndexOf(' ')
	if (indexOfLastSpace < 0) return null
	val firstName = this.take(indexOfLastSpace)
	val lastName = this.drop(indexOfLastSpace)
	return FullName(firstName, lastName)
}

// Usage
fun main() {
	val fullName = "Marcin MoskaÅ‚a"
	val (firstName, lastName) = fullName.parseName() ?: return
	print("His name is $firstName $lastName")
	// His name is Marcin MoskaÅ‚a
}
```

### **`data class`ì˜ ì¥ì :**

- **ëª…í™•í•œ ë°˜í™˜ íƒ€ì…**: í•¨ìˆ˜ê°€ ë¬´ì—‡ì„ ë°˜í™˜í•˜ëŠ”ì§€ í•œ ëˆˆì— ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **ë³µì¡í•œ íƒ€ì…ì˜ ìˆ¨ì€ ì˜ë¯¸ ì œê±°**: **`Pair`*ì²˜ëŸ¼ íŠœí”Œì„ ì‚¬ìš©í•˜ë©´ **ê°’ì˜ ì˜ë¯¸**ê°€ ë¶ˆë¶„ëª…í•˜ì§€ë§Œ, **`data class`*ë¥¼ ì‚¬ìš©í•˜ë©´ ê° ê°’ì˜ ì˜ë¯¸ê°€ ëª…í™•í•´ì§‘ë‹ˆë‹¤.
- **ì •ì  ê²€ì‚¬**: IntelliJì—ì„œëŠ” **êµ¬ì¡° ë¶„í•´ ì‹œ ì´ë¦„ì´ ë°”ë€Œë©´ ê²½ê³ **ë¥¼ í‘œì‹œí•˜ì—¬, ì‹¤ìˆ˜ë¥¼ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

This costs nearly nothing and improves the function signifi-
cantly:

- The return type of this function is more clear.
â€¢ The return type is shorter and easier to pass forward.
â€¢ If a user destructures variables with correct names but
in incorrect positions, a warning will be displayed in
IntelliJ.
If you donâ€™t want this class in a wider scope, you can restrict
its visibility. It can even be private if you only need to use it for
some local processing in a single file or class. It is worth using
data classes instead of tuples. Classes are cheap in Kotlin, so
donâ€™t be afraid to use them in your projects.

## 9. Summary

In this chapter, weâ€™ve learned about Any, which is a superclass
of all classes.Weâ€™ve also learned aboutmethods defined by Any:
equals, hashCode, and toString. Weâ€™ve also learned that there

are two primary types of objects. Regular objects are consid-
ered unique and do not expose their details. Data class objects,

which we made using the data modifier, represent bundles of
data (we keep them in primary constructor properties). They
are equal when they hold the same data. When transformed
to a string, they print all their data. They additionally support
destructuring and making a copy with the copy method. Two
generic data classes in Kotlin stdlib are Pair and Triple, but
(apart from certain cases) we prefer to use custom data classes 

instead of these. Also, for the sake of safety, when we destruc-
ture a data class, we prefer to match the variable names with

the parameter names.
Now, letâ€™smove on to a topic dedicated to special Kotlin syntax
that lets us create objects without defining a class.

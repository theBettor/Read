In Kotlin, we can add an element to a list using the + oper-
ator. In the same way, we can add two strings together. We

can check if a collection contains an element using the in
operator. We can also add, subtract or multiply elements of
type BigDecimal, which is a JVM class that is used to represent
possibly big numbers with unlimited precision.

- Kotlin은 **연산자 오버로딩**을 통해, 특정 메서드 시그니처(이름+파라미터)에 `operator`를 붙이면 **연산자 문법**(+, -, in, [], .. 등)으로 호출할 수 있다.
- 예: `list + "C"`, `"A" in list`, `BigDecimal` 간 사칙/비교, 등.

```kotlin
import java.math.BigDecimal

fun main() {
    val list: List<String> = listOf("A", "B")
    val newList: List<String> = list + "C"
    println(newList) // [A, B, C]

    val str1: String = "AB"
    val str2: String = "CD"
    val str3: String = str1 + str2
    println(str3) // ABCD

    println("A" in list) // true
    println("C" in list) // false

    val money1: BigDecimal = BigDecimal("12.50")
    val money2: BigDecimal = BigDecimal("3.50")
    val money3: BigDecimal = money1 * money2
    println(money3) // 43.7500
}

```

Using operators between objects is possible thanks to the

Kotlin feature called operator overloading, which allows spe-
cial kinds of methods to be defined that can be used as opera-
tors. Let’s see this in a custom class example.

### 1. An example of operator overloading

Let’s say that you need to represent complex numbers in your

application. These are special kinds of numbers in mathe-
matics that are represented by two parts: real and imaginary.

Complex numbers are useful for a variety of kinds of calcula-
tions in physics and engineering.

```kotlin
data class Complex(val real: Double, val imaginary: Double)
```

In mathematics, there is a range of operations that we can do
on complex numbers. For instance, you can add two complex

numbers or subtract a complex number from another com-
plex number. This is done using the + and - operators. There-
fore, it is reasonable that we should support these operators

for our Complex class. To support the + operator, we need to
define a method that has an operator modifier that is called
plus and a single parameter. To support the - operator, we
need to define a method that has an operator modifier called
minus and a single parameter.

## 1) 오퍼레이터 오버로딩 예시 (Complex)

- `plus`, `minus`에 `operator`를 붙여 `+`, 로 사용할 수 있다.
    
    (`a + b` ↔ `a.plus(b)`, `a - b` ↔ `a.minus(b)`)
    

```kotlin
data class Complex(val real: Double, val imaginary: Double) {
    operator fun plus(another: Complex) = Complex(
        real + another.real,
        imaginary + another.imaginary
    )
    operator fun minus(another: Complex) = Complex(
        real = real - another.real,
        imaginary = imaginary - another.imaginary
    )
}

// example usage
fun main() {
    val c1 = Complex(1.0, 2.0)
    val c2 = Complex(2.0, 3.0)
    println(c1 + c2) // Complex(real=3.0, imaginary=5.0)
    println(c2 - c1) // Complex(real=1.0, imaginary=1.0)
}

```

Using the + and- operators is equivalent to calling the plus and
minus functions. These two can be used interchangeably.

```kotlin
c1 + c2 // under the hood is c1.plus(c2)
c1 - c2 // under the hood is c1.minus(c2)
```

Kotlin defines a concrete set of operators, for each of which

there is a specific name and a number of supported argu-
ments. Additionally, all operators need to be a method (so,

either a member function or an extension function), and
these methods need the operator modifier.
Well-used operators can help us improve our code readability
as much as poorly used operators can harm it76. Let’s discuss
all the Kotlin operators.

### 2. Arithmetic operators

Let’s start with arithmetic operators, like plus or times. These
are easiest for the Kotlin compiler because it just needs to
transform the left column to the right.

Notice that % translates to rem, which is a short form of
“remainder”. This operator returns the remainder left over
when one operand is divided by a second operand, so it is
similar to the modulo operation.

This operator was previously called mod, which comes

from “modulo”, but this name is now deprecated. In math-
ematics, both the remainder and the modulo operations act

the same for positive numbers, but the difference lies in
negative numbers. The result of -5 remainder 4 is -1, because -
5 = 4 * (-1) + (-1). The result of -5modulo 4 is 3, because -5 = 4 * (-2) + 3. Kotlin’s % operator implements the behavior of remainder,
which is why its name needed to be changed from mod to rem.

## 2) 산술 연산자 & 나머지(`rem`)

- `%`는 **remainder(나머지)** 동작이며, 음수에서 **mod와 결과가 다를 수 있음**(Kotlin은 remainder 채택).
- 범위 생성 연산자 `..`, 개방 끝 범위 `..<`도 제공.

```kotlin
fun main() {
    println(13 % 4)  // 1
    println(7 % 4)   // 3
    println(1 % 4)   // 1
    println(0 % 4)   // 0
    println(-1 % 4)  // -1
    println(-5 % 4)  // -1
    println(-7 % 4)  // -3
}
```

It is also worth mentioning .. and ..< operators, that are
used to create ranges. We can use them between integers to
create IntRange, over which we can iterate in for-loop. We can
also use those operators between any values that implement
Comparable interface, to define a range by extremes of this
range.

```kotlin
fun main() {
    val intRange: IntRange = 1..10
    val comparableRange: ClosedRange<String> = "A".."Z"
    val openEndRange: OpenEndRange<Double> = 1.0..<2.0
}
```

### 3. The in operator

One of my favorite operators is in. The expression a in b
translates to b.contains(a). There is also !in, which translates
to negation.

There are a few ways to use this operator. Firstly, for collec-
tions, instead of checking if a list contains an element, you can

check if the element is in the list.

## 3) `in` / `!in` 연산자

- `"x in c"` ↔ `c.contains(x)`로 변환. **가독성 향상**.
- 컬렉션/범위(Comparable 기반 `ClosedRange`)에 자주 사용.

```kotlin
fun main() {
    val letters = setOf("A", "B", "C")
    println("A" in letters)           // true
    println("D" in letters)           // false
    println(5 in 1..10)               // true
    println(11 in 1..10)              // false
}

```

Why would you do that? Primarily for readability. Would you
ask “Does the fridge contain a beer?” or “Is there a beer in
the fridge?”? Using the in operator gives us the possibility to
choose.
We also often use the in operator together with ranges. The
expression 1..10 produces an object of type IntRange, which
has a contains method. This is why you can use in and a range
to check if a number is in this range.

```kotlin
fun main() {
println(5 in 1..10) // true
println(11 in 1..10) // false
}
```

You can make a range from any objects that are comparable,
and the result ClosedRange also has a contains method. This is 

why you can use a range check for any objects that are compa-
rable, such as big numbers or objects representing time.

```kotlin
import java.math.BigDecimal
import java.time.LocalDateTime

fun main() {
    val amount = BigDecimal("42.80")
    val minPrice = BigDecimal("5.00")
    val maxPrice = BigDecimal("100.00")
    val correctPrice = amount in minPrice..maxPrice
    println(correctPrice) // true

    val now = LocalDateTime.now()
    val actionStarts = LocalDateTime.of(1410, 7, 15, 0, 0)
    val actionEnds = actionStarts.plusDays(1)
    println(now in actionStarts..actionEnds) // false
}

```

### 4. The iterator operator

You can use for-loop to iterate over any object that has an
iterator operator method. Every object that implements an
Iterable interface must support the iterator method.

```kotlin
public interface Iterable<out T> {
/**
* Returns an iterator over the elements of this object.
*/
public operator fun iterator(): Iterator<T>
}
```

You can define objects that can be iterated over, but do not im-
plement Iterable interface. Map is a great example. It does not

implement the Iterable interface, yet you can iterate over it
using a for-loop. How so? It is thanks to the iterator operator,
which is defined as an extension function in Kotlin stdlib.

## 4) `iterator` 연산자 (for 루프 가능 조건)

- `for (x in y)`는 내부적으로 `y.iterator()`를 호출.
- `Iterable`은 `operator fun iterator()`를 가진다. `Map`은 **확장 함수**로 iterator를 제공.

```kotlin
// Part of Kotlin standard library
inline operator fun <K, V>
Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> =
    entries.iterator()

fun main() {
    val map = mapOf('a' to "Alex", 'b' to "Bob")
    for ((letter, name) in map) {
        println("$letter like in $name")
    }
    // a like in Alex
    // b like in Bob
}

```

To better understand how a for-loop works, consider the code
below.

```kotlin
fun main() {
for (e in Tree()) {
// body
}
}
class Tree {
operator fun iterator(): Iterator<String> = ...
}
```

Under the hood, a for-loop is compiled into bytecode that uses
a while-loop to iterate over the object’s iterator, as presented
in the snippet below.

```kotlin
fun main() {
val iterator = Tree().iterator()
while (iterator.hasNext()) {
val e = iterator.next()
// body
}
}
```

### 5. The equality and inequality operators

## 5) 동등/부등 연산자

- **구조적 동등성**: `==` ↔ `equals`(널 안전 변환 포함). 커스텀 클래스에서 `equals` 오버라이드 가능.
- **참조 동등성**: `===`(동일 객체 레퍼런스인지), 오버로딩 불가.

In Kotlin, there are two types of equality:
• Structural equality - checked with the equals method
or the == operator (and its negated counterpart !=). a
== b translates to a.equals(b) when a is not nullable,
otherwise it translates to a?.equals(b) ?: (b === null).

Structural equality is generally preferred over referen-
tial equality. The equals method can be overridden in

custom class.
• Referential equality - checked with the === operator
(and its negated counterpart !==); returns true when
both sides point to the same object. === and !== (identity
checks) are not overloadable.
Since equals is implemented in Any, which is the superclass of
every class, we can check the equality of any two objects.

### 6. Comparison operators

Some classes have natural order, which is the order that is
used by default when we compare two instances of a given
class. Numbers are a good example: 10 is a smaller number 

than 100. There is a popular Java convention that classes with
natural order should implement a Comparable interface, which
requires the compareTo method, which is used to compare two
objects.

```kotlin
public interface Comparable<in T> {
/**
* Compares this object with the specified object for
* order. Returns zero if this object is equal to the
* specified [other] object, a negative number if it's
* less than [other], or a positive number if it's
* greater than [other].
*/
public operator fun compareTo(other: T): Int
}
```

As a result, there is a convention that we should compare
two objects using the compareTo method. However, using the
compareTo method directly is not very intuitive. Let’s say that
you see a.compareTo(b) > 0 in code. What does it mean? Kotlin
simplifies this by making compareTo an operator that can be
replaced with intuitive mathematical comparison operators:

>, <, >=, and <=.

I often use comparison operators to compare amounts kept in
objects of type BigDecimal or BigInteger.

## 6) 비교 연산자(>, <, >=, <=)

- `Comparable`의 `compareTo`를 **연산자**로 노출.
- `BigDecimal`, `LocalDateTime` 등에서도 직관적으로 비교 가능.

```kotlin
import java.math.BigDecimal

fun main() {
    val amount1 = BigDecimal("42.80")
    val amount2 = BigDecimal("5.00")
    println(amount1 > amount2)   // true
    println(amount1 >= amount2)  // true
    println(amount1 < amount2)   // false
    println(amount1 <= amount2)  // false
}

```

I also like to compare time references the same way.

```kotlin
import java.time.LocalDateTime

fun main() {
    val now = LocalDateTime.now()
    val actionStarts = LocalDateTime.of(2010, 10, 20, 0, 0)
    val actionEnds = actionStarts.plusDays(1)
    println(now > actionStarts)
    println(now <= actionStarts)
    println(now < actionEnds)
    println(now >= actionEnds)
}

```

### 7. The indexed access operator

In programming, there are two popular conventions for get-
ting or setting elements in collections. The first uses box

brackets, while the second uses the get and set methods. In
Java, we use the first convention for arrays and the second
one for other kinds of collections. In Kotlin, both conventions
can be used interchangeably because the get and set methods
are operators that can be used with box brackets.

## 7) 인덱스 접근 연산자 `[]` (get/set)

- `x[y]` ↔ `x.get(y)`, `x[y] = v` ↔ `x.set(y, v)`로 변환.
- 맵/리스트 등에서 자연스럽게 사용.

```kotlin
fun main() {
    val mutableList = mutableListOf("A", "B", "C")
    println(mutableList[1])  // B
    mutableList[2] = "D"
    println(mutableList)     // [A, B, D]

    val animalFood = mutableMapOf(
        "Dog" to "Meat",
        "Goat" to "Grass"
    )
    println(animalFood["Dog"]) // Meat
    animalFood["Cat"] = "Meat"
    println(animalFood["Cat"]) // Meat
}

```

Square brackets are translated to get and set calls with appro-
priate numbers of arguments. Variants of get and set func-
tions with more arguments might be used by data processing

libraries. For instance, you could have an object that repre-
sents a table and use box brackets with two arguments: x and

y coordinates.

### 8. Augmented assignments

When we set a new value for a variable, this new value is
often based on its previous value. For instance, we might
want to add a value to the previous one. For this, augmented 

When we set a new value for a variable, this new value is
often based on its previous value. For instance, we might
want to add a value to the previous one. For this, augmented 

assignments were introduced. For example, a += b is a
shorter notation of a = a + b. There are similar notations
for other arithmetic operations.

I am not sure which language introduced augmented as-
signments first, but they are even supported by languages as

old as C.

Notice that augmented assignments can be used for all types
that support the appropriate arithmetic operation, including
lists or strings. Such augmented assignments need a variable

to be read-write, namely var, and the result of the mathemati-
cal operation must have a proper type (to translate a += b to a

= a + b, the variable a needs to be var, and a + b needs to be a
subtype of type a).

## 8) 복합 대입(증강 대입) `+=`, `=`

- `a += b` ↔ 보통 `a = a + b` 변환(읽기 전용 컬렉션/문자열 등은 **새 객체** 생성).
- **가변 컬렉션**에선 `plusAssign`/`minusAssign`로 **제자리 수정**.

```kotlin
fun main() {
    var str = "ABC"
    str += "D" // str = str + "D"
    println(str) // ABCD

    var l = listOf("A", "B", "C")
    l += "D" // l = l + "D" (새 리스트)
    println(l) // [A, B, C, D]
}

```

Augmented assignments can be used in another way: to mod-
ify a mutable object. For instance, we can use += to add an

element to a mutable list. In such a case, a += b translates to
a.plusAssign(b).

```kotlin
fun main() {
    val names = mutableListOf("Jake", "Ben")
    names += "Jon" // plusAssign → 내부 수정
    names -= "Ben" // minusAssign → 내부 수정
    println(names) // [Jake, Jon]

    val tools = mutableMapOf(
        "Grass" to "Lawnmower",
        "Nail" to "Hammer"
    )
    tools += "Screw" to "Screwdriver" // 항목 추가
    tools -= "Grass"                  // 항목 제거
    println(tools) // {Nail=Hammer, Screw=Screwdriver}
}

```

If both kinds of augmented assignment can be applied, Kotlin
chooses to modify a mutable object by default.

### 9. Unary prefix operators

A plus, minus, or negation in front of a single value is also an
operator. Operators that are used with only a single value are 

called unary operators. Kotlin supports operator overload-
ing for the following unary operators:

Unary operators are used with only a single value
(operand). Operators used with two values are known as
binary operators; however, since most operators are binary,
this type is often treated as the default. Operators used with
three values are known as ternary operators. Since there
is only one ternary operator in mainstream programming
languages, namely the conditional operator, it is often
referred as the ternary operator.

Here is an example of overloading the unaryMinus operator.

## 9) 단항(prefix) 연산자

- `unaryPlus`, `unaryMinus`, `not` 등 **피연산자 1개**. 오버로딩 가능.

```kotlin
data class Point(val x: Int, val y: Int)
operator fun Point.unaryMinus() = Point(-x, -y)

fun main() {
    val point = Point(10, 20)
    println(-point) // Point(x=-10, y=-20)
}

```

The unaryPlus operator is often used as part of Kotlin DSLs,
which are described in detail in the next book of this series,
Functional Kotlin.

### 10. Increment and decrement

As part of many algorithms used in older languages, we often
needed to add or subtract the value 1 from a variable, which

is why increment and decrement were invented. The ++ oper-
ator is used to add 1 to a variable; so, if a is an integer, then a++ 

translates to a = a + 1. The -- operator is used to subtract 1
from a variable; so, if a is an integer, then a-- translates to a =
a - 1.
Both increment and decrement can be used before or after
a variable, and this determines the value returned by this
operation.

- If you use ++ before a variable, it is called pre-increment;
it increments the variable and then returns the result of
this operation.
• If you use ++ after a variable, it is called post-increment;
it increments the variable but then returns the value
before the operation.
• If you use --before a variable, it is calledpre-decrement;
it decrements the variable and then returns the result of
this operation.
• If you use -- after a variable, it is called post-decrement;
it decrements the variable but then returns the value
before the operation.

## 10) 증감 연산자 `++`, `-`

- `a++`, `-a` 등(전위/후위에 따라 **반환값**이 다름).
- `inc`/`dec` 기반으로 오버로딩 가능(실무에선 드묾).

```kotlin
fun main() {
    var i = 10
    println(i++) // 10  (후위: 먼저 반환, 나중 증가)
    println(i)   // 11
    println(++i) // 12  (전위: 먼저 증가, 그 결과 반환)
    println(i)   // 12

    i = 10
    println(i--) // 10
    println(i)   // 9
    println(--i) // 8
    println(i)   // 8
}

```

Based on the inc and dec methods, Kotlin supports incre-
ment and decrement overloading, which should increment or

decrement a custom object. I have never seen this capability
used in practice, so I think it is enough to know that it exists.

### 11. The invoke operator

Objects with the invoke operator can be called like functions,
so with parentheses straight after the variable representing
this object. Calling an object translates to the invoke method
call with the same arguments.

The invoke operator is used for objects that represent func-
tions, such as lambda expressions or UseCases objects from

Clean Architecture.

## 11) `invoke` 연산자 (함수처럼 호출)

- `operator fun invoke(...)`가 있으면 **객체()** 형태로 호출 가능.
- 람다/UseCase 등 “호출 가능한 객체” 패턴에 사용.

```kotlin
class CheerUseCase {
    operator fun invoke(who: String) {
        println("Hello, $who")
    }
}

fun main() {
    val hello = {
        println("Hello")
    }
    hello() // Hello

    val cheerUseCase = CheerUseCase()
    cheerUseCase("Reader") // Hello, Reader
}

```

### 12. Precedence

What is the result of the expression 1 + 2 * 3? The answer is 7,
not 9, because in mathematics we multiply before adding. We
say that multiplication has higher precedence than addition.

Precedence is also extremely important in programming be-
cause when the compiler evaluates an expression such as 1 +

2 == 3, it needs to know if it should first add1 to 2, or compare 2
and 3. The following table compares the precedence of all the
operators, including those that can be overloaded and those
that cannot.

On the basis of this table, can you predict what the following
code will print?

## 12) 연산자 **우선순위**

- `1 + 2 * 3 == 7` 과 같이 **우선순위**가 다르므로 해석이 달라질 수 있음.
- 퍼즐: `println(-1.plus(1))` 의 결과는? → **2**
    - 이유: (단항)는 `plus` 호출 **이후** 적용. `(-1)`로 괄호를 써야 0이 됨.

```kotlin
fun main() {
	println(-1.plus(1)) // -2
}
```

This is a popular Kotlin puzzle. The answer is -2, not 0, be-
cause a single minus in front of a function is an operator

whose precedence is lower than an explicit plus method call.
So, we first call the method and then call unaryMinus on the
result, therefore we change from 2 to -2. To use -1 literally,
wrap it with parentheses.

```kotlin
fun main() {
	println((-1).plus(1)) // 0
}
```

### 13. Summary

We use a lot of operators in Kotlin, many of which can be over-
loaded. This can be used to improve our code’s readability.

From the cognitive standpoint, using an intuitive operator
can be a huge improvement over using methods everywhere.
Therefore, iit’s good to know what options are available and
to be open to using operators defined by Kotlin stdlib, but it’s
also good to be able to define our own operators.

In this chapter, weâ€™re going to introduce the concept of enum

classes. Letâ€™s start with an example. Suppose that youâ€™re im-
plementing a payment method that has to support three pos-
sible options: cash payment, card payment, and bank transfer.

The most basic way to represent a fixed set of values in Kotlin
is an enum class. Inside its body, we list all the values, divided
by a comma. We name values using UPPER_SNAKE_CASE
notation (e.g., BANK_TRANSFER). Enum class elements can be
referenced by the enum name, followed by a dot, and then the
value name (e.g., PaymentOption.CASH). All values are typed as
the enum class type.

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun printOption(option: PaymentOption) {
    println(option)
}

fun main() {
    val option: PaymentOption = PaymentOption.CARD
    println(option)      // CARD
    printOption(option)  // CARD
}
```

- ê°’ ì°¸ì¡°: `PaymentOption.CASH`
- í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜/ë¦¬í„´íƒ€ì…ì—ë„ ì‚¬ìš© ê°€ëŠ¥.

Each enum class has the following companion object
elements:

- entries property, which keeps a list of all the values of
this enum class. It is a modern replacement of the values
    
    function, that returns an array of elements.
    
- valueOf function, which parses a string into a value
matching its name (this is case-sensitive) or throws an
exception.

entries property was introduced in Kotlin 1.9, so in
projects using older versions of Kotlin you need to use values
instead.

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun main() {
		val option: PaymentOption = PaymentOption.valueOf("TRANSFER")
		// val option = PaymentOption.valueOf("TRANSFER") ìœ„ì™€ ê°™ìŒ
		println(option)
		println("All options: ")
		val paymentOptions: List<PaymentOption> =
		PaymentOption.entries
		for (paymentOption in paymentOptions) {
			println(paymentOption)
		}
}
		// TRANSFER
		// All options:
		// CASH
		// CARD
		// TRANSFER
```

- `PaymentOption.valueOf("TRANSFER")` â†’ ë¬¸ìì—´ì„ enum ê°’ìœ¼ë¡œ ë³€í™˜. (ëŒ€ì†Œë¬¸ì êµ¬ë¶„, ì—†ìœ¼ë©´ ì˜ˆì™¸ ë°œìƒ)
- `PaymentOption.entries` â†’ ëª¨ë“  enum ê°’ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜ (Kotlin 1.9+)

Instead of these methods, we can also use the top-level
enumValues and enumValueOf functions.

```kotlin
enum class PaymentOption {
		CASH,
		CARD,
		TRANSFER,
}

fun main() {
		val option = enumValueOf<PaymentOption>("TRANSFER")
		println(option)
		println("All options: ")
		val paymentOptions = enumValues<PaymentOption>()
		for (paymentOption in paymentOptions) {
			println(paymentOption)
		}
}
		// TRANSFER
		// All options:
		// CASH
		// CARD
		// TRANSFER
```

Kotlinì—ì„œëŠ” `entries` / `valueOf` ê°™ì€ **enum í´ë˜ìŠ¤ì˜ companion í•¨ìˆ˜** ë§ê³ ë„, **ì „ì—­(top-level) ì œë„¤ë¦­ í•¨ìˆ˜**ë¡œ enum ê°’ì„ ë‹¤ë£¨ëŠ” ë„êµ¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

1. enumValueOf<T>(name: String): T
    - ë¬¸ìì—´ì„ enum ê°’ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    - ì œë„¤ë¦­ íƒ€ì… `<T>`ë¡œ ì–´ë–¤ enum í´ë˜ìŠ¤ì¸ì§€ ì§€ì •í•´ì•¼ í•¨.
    - ë§¤ì¹­ë˜ëŠ” ì´ë¦„ì´ ì—†ê±°ë‚˜ ëŒ€ì†Œë¬¸ìê°€ ë‹¤ë¥´ë©´ `IllegalArgumentException` ë°œìƒ.

1. enumValues<T>(): Array<T>
    - í•´ë‹¹ enum íƒ€ì…ì˜ **ëª¨ë“  ê°’ì„ ë°°ì—´(Array)** ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
    - ì´í›„ `for` ë¬¸, `toList()` ë“±ì„ í†µí•´ ìˆœíšŒí•˜ê±°ë‚˜ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. ì •ë¦¬
    - **ìµœì‹  Kotlin 1.9+ í”„ë¡œì íŠ¸** â†’ `entries` ê¶Œì¥.
    - **ë²„ì „ í˜¸í™˜ì„±ì„ ì‹ ê²½ ì“¸ ë•Œ** â†’ `enumValues`, `enumValueOf` ì‚¬ìš©.

As you can see, enum elements keep their values in order. This
order is important. Each enum value has two properties:
â€¢ name - the name of this value,
â€¢ ordinal - the position of this value (starting from 0).

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun main() {
val option = PaymentOption.TRANSFER
println(option.name) // TRANSFER
println(option.ordinal) // 2
}
```

- **`name`** â†’ enum ìƒìˆ˜ ì´ë¦„ (`"TRANSFER"`)
- **`ordinal`** â†’ ì •ì˜ëœ ìˆœì„œ(0ë¶€í„° ì‹œì‘)
- **`toString`**, **`equals`**, **`hashCode`**, **`compareTo`** (ìˆœì„œëŠ” ì„ ì–¸ëœ ìˆœì„œ ê¸°ë°˜)

Each enum class is a subclass of the abstract class Enum. This
superclass guarantees the name and ordinal properties. Enum
classes have properties that implement toString, equals, and
hashCode, but, unlike data classes, they also have compareTo
(their natural order is the order of the elements in the body).
Enum values can be used inside when-conditions. Moreover,
there is no need to use the else-branch when all possible enum
values are covered.

```kotlin
fun transactionFee(paymentOption: PaymentOption): Double =
    when (paymentOption) {
        PaymentOption.CASH -> 0.0
        PaymentOption.CARD,
        PaymentOption.TRANSFER -> 0.05
    }

```

- enum ê°’ì€ `when` ì¡°ê±´ì—ì„œ ì‚¬ìš©í•˜ê¸° ë§¤ìš° í¸ë¦¬í•©ë‹ˆë‹¤.
- **ëª¨ë“  enum ê°’**ì„ ì»¤ë²„í•˜ë©´ `else` ë¶„ê¸° í•„ìš” ì—†ìŒ.

Enum classes are very convenient because they can be easily
parsed or stringified. They are a popular way to represent a
finite set of possible values.

## 1. Data in enum values

In Kotlin, each enum value can hold a state. It is possible to
define a primary constructor for an enum class, and then each
value needs to specify its data next to its name. It is the best
practice that enum values should always be immutable, so
their state should never change.

```kotlin
import java.math.BigDecimal

enum class PaymentOption(val commission: BigDecimal) {
    CASH(BigDecimal.ONE),
    CARD(BigDecimal.TEN),
    TRANSFER(BigDecimal.ZERO)
}

fun main() {
    println(PaymentOption.CARD.commission)     // 10
    println(PaymentOption.TRANSFER.commission) // 0
    
    val paymentOption: PaymentOption = PaymentOption.entries.random()
    println(paymentOption.commission) // 0, 1, or 10
}

```

- Enum í´ë˜ìŠ¤ëŠ” **ì£¼ ìƒì„±ì(primary constructor)** ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŒ.
- ê° enum ê°’ì€ ìƒì„±ìì˜ ì¸ì ê°’ì„ ì§€ì •í•´ì•¼ í•¨.
- ê´€ë¡€: enum ê°’ì˜ ìƒíƒœëŠ” **ë¶ˆë³€(immutable)** ì´ì–´ì•¼ í•¨.

ğŸ‘‰ ì´ëŸ° ì‹ìœ¼ë¡œ enum ê°’ì— **ì¶”ê°€ ì†ì„±(commission)**ì„ ë„£ì–´ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 2. Enum classes with custom methods

Kotlin enums can have abstract methods whose implementa-
tions are item-specific.When we define them, the enum class

itself needs to define an abstract method, and each item must
override it:

```kotlin
enum class PaymentOption {
    CASH {
        override fun startPayment(transaction: Transaction) {
            showCashPaymentInfo(transaction)
        }
    },
    CARD {
        override fun startPayment(transaction: Transaction) {
            moveToCardPaymentPage(transaction)
        }
    },
    TRANSFER {
        override fun startPayment(transaction: Transaction) {
            showMoneyTransferInfo()
            setupPaymentWatcher(transaction)
        }
    };

    abstract fun startPayment(transaction: Transaction)
}
```

- ì¶”ìƒ ë©”ì„œë“œë„ ì •ì˜í•  ìˆ˜ ìˆëŠ”ë°, ìœ„ì²˜ëŸ¼ ê° enum ê°’ì´ ìì‹ ë§Œì˜ êµ¬í˜„ì„ ì œê³µí•´ì•¼í•¨.
- ê° enum ê°’ë§ˆë‹¤ ì„œë¡œ ë‹¤ë¥¸ ë™ì‘ì„ ë„£ì„ ìˆ˜ ìˆì§€ë§Œ, ì‹¤ë¬´ì—ì„œëŠ” í•¨ìˆ˜í˜• ìƒì„±ì ë§¤ê°œë³€ìˆ˜ë‚˜ í™•ì¥í•¨ìˆ˜ë¥¼ ì„ í˜¸í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ. (enum ê°’ì´ ì§€ë‚˜ì¹˜ê²Œ ë¬´ê±°ì›Œì§€ëŠ”ê±¸ ë°©ì§€)

This option is not popular as we generally prefer using func-
tional primary constructor parameters or extension func-
tions.

## 3. Summary

Enum classes are a convenient way to represent a concrete
set of possible values. Each value has the properties name and
ordinal (position). We can get an array of all values using the
values companion object function or the enumValues top-level
function. We can also parse an enum value from String using

the valueOf companion object function or the enumValueOf top-
level function.

In the next chapter, we will talk about sealed classes, which
are often treated as similar to enums but represent completely
different and evenmore powerful abstractions. Sealed classes

can form a closed hierarchy of classes, whereas enums repre-
sent only a set of constant values.

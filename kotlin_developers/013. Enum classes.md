In this chapter, we’re going to introduce the concept of enum

classes. Let’s start with an example. Suppose that you’re im-
plementing a payment method that has to support three pos-
sible options: cash payment, card payment, and bank transfer.

The most basic way to represent a fixed set of values in Kotlin
is an enum class. Inside its body, we list all the values, divided
by a comma. We name values using UPPER_SNAKE_CASE
notation (e.g., BANK_TRANSFER). Enum class elements can be
referenced by the enum name, followed by a dot, and then the
value name (e.g., PaymentOption.CASH). All values are typed as
the enum class type.

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun printOption(option: PaymentOption) {
    println(option)
}

fun main() {
    val option: PaymentOption = PaymentOption.CARD
    println(option)      // CARD
    printOption(option)  // CARD
}
```

- 값 참조: `PaymentOption.CASH`
- 함수 매개변수/리턴타입에도 사용 가능.

Each enum class has the following companion object
elements:

- entries property, which keeps a list of all the values of
this enum class. It is a modern replacement of the values
    
    function, that returns an array of elements.
    
- valueOf function, which parses a string into a value
matching its name (this is case-sensitive) or throws an
exception.

entries property was introduced in Kotlin 1.9, so in
projects using older versions of Kotlin you need to use values
instead.

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun main() {
		val option: PaymentOption = PaymentOption.valueOf("TRANSFER")
		// val option = PaymentOption.valueOf("TRANSFER") 위와 같음
		println(option)
		println("All options: ")
		val paymentOptions: List<PaymentOption> =
		PaymentOption.entries
		for (paymentOption in paymentOptions) {
			println(paymentOption)
		}
}
		// TRANSFER
		// All options:
		// CASH
		// CARD
		// TRANSFER
```

- `PaymentOption.valueOf("TRANSFER")` → 문자열을 enum 값으로 변환. (대소문자 구분, 없으면 예외 발생)
- `PaymentOption.entries` → 모든 enum 값 리스트 반환 (Kotlin 1.9+)

Instead of these methods, we can also use the top-level
enumValues and enumValueOf functions.

```kotlin
enum class PaymentOption {
		CASH,
		CARD,
		TRANSFER,
}

fun main() {
		val option = enumValueOf<PaymentOption>("TRANSFER")
		println(option)
		println("All options: ")
		val paymentOptions = enumValues<PaymentOption>()
		for (paymentOption in paymentOptions) {
			println(paymentOption)
		}
}
		// TRANSFER
		// All options:
		// CASH
		// CARD
		// TRANSFER
```

Kotlin에서는 `entries` / `valueOf` 같은 **enum 클래스의 companion 함수** 말고도, **전역(top-level) 제네릭 함수**로 enum 값을 다루는 도구를 제공합니다.

1. enumValueOf<T>(name: String): T
    - 문자열을 enum 값으로 변환합니다.
    - 제네릭 타입 `<T>`로 어떤 enum 클래스인지 지정해야 함.
    - 매칭되는 이름이 없거나 대소문자가 다르면 `IllegalArgumentException` 발생.

1. enumValues<T>(): Array<T>
    - 해당 enum 타입의 **모든 값을 배열(Array)** 로 반환합니다.
    - 이후 `for` 문, `toList()` 등을 통해 순회하거나 리스트로 변환할 수 있습니다.

1. 정리
    - **최신 Kotlin 1.9+ 프로젝트** → `entries` 권장.
    - **버전 호환성을 신경 쓸 때** → `enumValues`, `enumValueOf` 사용.

As you can see, enum elements keep their values in order. This
order is important. Each enum value has two properties:
• name - the name of this value,
• ordinal - the position of this value (starting from 0).

```kotlin
enum class PaymentOption {
    CASH,
    CARD,
    TRANSFER,
}

fun main() {
val option = PaymentOption.TRANSFER
println(option.name) // TRANSFER
println(option.ordinal) // 2
}
```

- **`name`** → enum 상수 이름 (`"TRANSFER"`)
- **`ordinal`** → 정의된 순서(0부터 시작)
- **`toString`**, **`equals`**, **`hashCode`**, **`compareTo`** (순서는 선언된 순서 기반)

Each enum class is a subclass of the abstract class Enum. This
superclass guarantees the name and ordinal properties. Enum
classes have properties that implement toString, equals, and
hashCode, but, unlike data classes, they also have compareTo
(their natural order is the order of the elements in the body).
Enum values can be used inside when-conditions. Moreover,
there is no need to use the else-branch when all possible enum
values are covered.

```kotlin
fun transactionFee(paymentOption: PaymentOption): Double =
    when (paymentOption) {
        PaymentOption.CASH -> 0.0
        PaymentOption.CARD,
        PaymentOption.TRANSFER -> 0.05
    }

```

- enum 값은 `when` 조건에서 사용하기 매우 편리합니다.
- **모든 enum 값**을 커버하면 `else` 분기 필요 없음.

Enum classes are very convenient because they can be easily
parsed or stringified. They are a popular way to represent a
finite set of possible values.

## 1. Data in enum values

In Kotlin, each enum value can hold a state. It is possible to
define a primary constructor for an enum class, and then each
value needs to specify its data next to its name. It is the best
practice that enum values should always be immutable, so
their state should never change.

```kotlin
import java.math.BigDecimal

enum class PaymentOption(val commission: BigDecimal) {
    CASH(BigDecimal.ONE),
    CARD(BigDecimal.TEN),
    TRANSFER(BigDecimal.ZERO)
}

fun main() {
    println(PaymentOption.CARD.commission)     // 10
    println(PaymentOption.TRANSFER.commission) // 0
    
    val paymentOption: PaymentOption = PaymentOption.entries.random()
    println(paymentOption.commission) // 0, 1, or 10
}

```

- Enum 클래스는 **주 생성자(primary constructor)** 를 가질 수 있음.
- 각 enum 값은 생성자의 인자 값을 지정해야 함.
- 관례: enum 값의 상태는 **불변(immutable)** 이어야 함.

👉 이런 식으로 enum 값에 **추가 속성(commission)**을 넣어 관리할 수 있습니다.

## 2. Enum classes with custom methods

Kotlin enums can have abstract methods whose implementa-
tions are item-specific.When we define them, the enum class

itself needs to define an abstract method, and each item must
override it:

```kotlin
enum class PaymentOption {
    CASH {
        override fun startPayment(transaction: Transaction) {
            showCashPaymentInfo(transaction)
        }
    },
    CARD {
        override fun startPayment(transaction: Transaction) {
            moveToCardPaymentPage(transaction)
        }
    },
    TRANSFER {
        override fun startPayment(transaction: Transaction) {
            showMoneyTransferInfo()
            setupPaymentWatcher(transaction)
        }
    };

    abstract fun startPayment(transaction: Transaction)
}
```

- 추상 메서드도 정의할 수 있는데, 위처럼 각 enum 값이 자신만의 구현을 제공해야함.
- 각 enum 값마다 서로 다른 동작을 넣을 수 있지만, 실무에서는 함수형 생성자 매개변수나 확장함수를 선호하는 경우가 많음. (enum 값이 지나치게 무거워지는걸 방지)

This option is not popular as we generally prefer using func-
tional primary constructor parameters or extension func-
tions.

## 3. Summary

Enum classes are a convenient way to represent a concrete
set of possible values. Each value has the properties name and
ordinal (position). We can get an array of all values using the
values companion object function or the enumValues top-level
function. We can also parse an enum value from String using

the valueOf companion object function or the enumValueOf top-
level function.

In the next chapter, we will talk about sealed classes, which
are often treated as similar to enums but represent completely
different and evenmore powerful abstractions. Sealed classes

can form a closed hierarchy of classes, whereas enums repre-
sent only a set of constant values.

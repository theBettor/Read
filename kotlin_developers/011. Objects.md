What is an object? This is the question I often start this section
with inmyworkshops, and I generally get an instant response,
â€œAn instance of a classâ€. That is right, but how do we create
objects? One way is easy: using constructors.

```kotlin
class A
// Using a constructor to create an object
val a = A()
```

ê°ì²´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ â€œí´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤â€ë¼ê³  ì •ì˜í•˜ê³ , ìœ„ì²˜ëŸ¼ ê¸°ë³¸ì ìœ¼ë¡œ ìƒì„±ìë¥¼ ì´ìš©í•´ì„œ ë§Œë“¤ì–´ì§€ì§€ë§Œ, 2ê°€ì§€ ì¶”ê°€ì ì¸ ë°©ë²•ì´ ìˆë‹¤.

However, this is not the only way. In Kotlin, we can also create
objects using object expression and object declaration. Letâ€™s
discuss these two options.

## 1. Object expressions

To create an empty object using an expression, we use the
object keyword and braces. This syntax for creating objects is
known as object expression.

```kotlin
val instance = object {}
```

`object {}` êµ¬ë¬¸ì„ ì‚¬ìš©í•´ **ìµëª… ê°ì²´(anonymous object)**ë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. 

An empty object extends no classes (except for Any, which is
extended by all objects in Kotlin), implements no interfaces,
and has nothing inside its body. Nevertheless, it is useful. Its
power lies in its uniqueness: such an object equals nothing
else but itself. Therefore, it is perfectly suited to be used as
some kind of token or synchronization lock.

```kotlin
class Box {
	var value: Any? = NOT_SET
	fun initialized() = value != NOT_SET
	
	companion object {
		private val NOT_SET = object {}
	}
}

private val LOCK = object {}
fun synchronizedOperation() = synchronized(LOCK) {
	// ...
}
```

- **object {}ë¥¼ ë¹„ì›Œë‘ë©´** Anyë§Œ ìƒì†í•˜ëŠ” ê¸°ë³¸í˜• ë¹ˆ ê°ì²´ê°€ ëœë‹¤.
- **object {} ì•ˆì— ë©¤ë²„Â·ìƒì†Â·ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì„ ì¶”ê°€í•  ìˆ˜ë„ ìˆë‹¤.**

An empty object can also be created with the constructor of
Any, so Any() is an alternative to object {}.

```kotlin
private val NOT_SET = Any()
```

However, objects created with an object expression do not

need to be empty. They can have bodies, extend classes, im-
plement interfaces, etc. The syntax is the same as for classes,

but object declarations use the object keyword instead of class
and should not define the name or constructor.

```kotlin
data class User(val name: String)

interface UserProducer {
	fun produce(): User
}

fun printUser(producer: UserProducer) {
	println(producer.produce())
}

fun main() {
	val user = User("Jake")
	val producer = object : UserProducer {
	override fun produce(): User = user
	}
	printUser(producer) // User(name=Jake)
}
```

In a local scope, object expressions define an anonymous
type that wonâ€™t work outside the class where it is defined.
This means the non-inherited members of object expressions
are accessible only when an anonymous object is declared
in a local or class-private scope; otherwise, the object is just
an opaque Any type, or the type of the class or interface it
inherits from. This makes non-inherited members of object
expressions hard to use in real-life projects.

```kotlin
class Robot {
	// Possible, but rarely useful
	// prefer regular member properties instead
	private val point = object {
		var x = 0
		var y = 0
	}
	fun moveUp() {
	point.y += 10
}

fun show() {
	println("(${point.x}, ${point.y})")
	}
}

fun main() {
	val robot = Robot()
	robot.show() // (0, 0)
	robot.moveUp()
	robot.show() // (0, 10)
	val point = object {
	var x = 0
	var y = 0
}

println(point.x) // 0
point.y = 10
println(point.y) // 10
}
```

- **ë¡œì»¬ ë²”ìœ„**(í•¨ìˆ˜ ë‚´ë¶€, private ì†ì„± ë“±)ì—ì„œ ë§Œë“  ê²½ìš° â†’ í•´ë‹¹ ë²”ìœ„ ë‚´ì—ì„œë§Œ **ìµëª… íƒ€ì…**ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥.
- **ê³µê°œ(public) ë²”ìœ„**ì—ì„œ ë§Œë“  ê²½ìš° â†’ íƒ€ì…ì´ `Any` ë˜ëŠ” êµ¬í˜„í•œ í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ìœ¼ë¡œë§Œ ë³´ì„ â†’ **ë¹„ìƒì† ë©¤ë²„ ì‚¬ìš© ë¶ˆê°€**.

In practice, object expressions are used as an alternative
to Java anonymous classes, i.e., when we need to create a
watcher or a listener with multiple handler methods.

```kotlin
taskNameView.addTextChangedListener(object : TextWatcher {
    override fun afterTextChanged(editable: Editable?) { /* ... */ }
    override fun beforeTextChanged(text: CharSequence?, start: Int, count: Int, after: Int) { /* ... */ }
    override fun onTextChanged(text: CharSequence?, start: Int, before: Int, count: Int) { /* ... */ }
})
```

Object expressionì€ Javaì˜ **ìµëª… í´ë˜ìŠ¤** ëŒ€ì²´ ìš©ë„ë¡œ ë§ì´ ì”€. ëŒ€í‘œì ìœ¼ë¡œ **ë¦¬ìŠ¤ë„ˆ(listener)**, **ì½œë°±(callback)** êµ¬í˜„ ì‹œ ì‚¬ìš©.

Note that â€œobject expressionâ€ is a better name than â€œanony-mous classâ€ since this is an expression that produces an object.

## ğŸ’¡ Object Expression í•µì‹¬ ì •ë¦¬

1. **ì •ì˜**
    
    `object {}` ë¬¸ë²•ì„ ì‚¬ìš©í•´ **ìµëª… ê°ì²´(anonymous object)**ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
    
    Javaì˜ ìµëª… í´ë˜ìŠ¤ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, **í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ê°ì²´ë¥¼ ë°”ë¡œ ìƒì„±í•˜ëŠ” í‘œí˜„ì‹**ì´ë¼ëŠ” ì ì´ ë‹¤ë¥´ë‹¤.
    
2. **ë¹ˆ ê°ì²´ì™€ í™•ì¥ ê°€ëŠ¥ì„±**
    
    `object {}`ë¥¼ **ë¹„ì›Œë‘ë©´** `Any`ë§Œ ìƒì†í•˜ëŠ” **ê¸°ë³¸í˜• ë¹ˆ ê°ì²´**ê°€ ëœë‹¤.
    
    í•˜ì§€ë§Œ ì¤‘ê´„í˜¸ ì•ˆì— **ë©¤ë²„ë¥¼ ì¶”ê°€**í•˜ê±°ë‚˜, **í´ë˜ìŠ¤ë¥¼ ìƒì†**í•˜ê±°ë‚˜, **ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„**í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•˜ë‹¤.
    
3. **ì´ë¦„ê³¼ ìƒì„±ì ì—†ìŒ**
    
    Object expressionì€ **ì´ë¦„(name)ê³¼ ìƒì„±ì(constructor)**ë¥¼ ì •ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤.
    
    - **ë¡œì»¬ ë²”ìœ„**ë‚˜ **private ë²”ìœ„**ì—ì„œ ìƒì„±í•œ ê²½ìš° â†’ í•´ë‹¹ ìµëª… íƒ€ì…ì˜ ë©¤ë²„ì— ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥.
    - **public ë²”ìœ„**ì—ì„œ ìƒì„±í•œ ê²½ìš° â†’ `Any` íƒ€ì…ì´ë‚˜ ìƒì†Â·êµ¬í˜„í•œ íƒ€ì…ìœ¼ë¡œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë©°, ë¹„ìƒì† ë©¤ë²„ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
4. **í™œìš© ì˜ˆì‹œ**
    
    ë‚´ìš©ì´ ì—†ëŠ” ë¹ˆ ê°ì²´ë¼ë„ **ìœ ì¼ì„±(uniqueness)**ì„ ê°€ì§€ë¯€ë¡œ,
    
    - í† í°(token)ì´ë‚˜ **ë™ê¸°í™” ë½(lock)**
    - ë¦¬ìŠ¤ë„ˆ(listener), ì½œë°±(callback), Watcher ë“±ì˜ **ê°„ë‹¨ ê°ì²´ ìƒì„±**

## 2. Object declaration

If we take an object expression and give it a name, we get an
object declaration. This structure also creates a single object,
but this object is not anonymous: it has a name that can be
used to reference it.

```kotlin
object Point {
	var x = 0
	var y = 0
}

fun main() {
	println(Point.x) // 0
	Point.y = 10
	println(Point.y) // 10
	val p = Point
	p.x = 20
	println(Point.x) // 20
	println(Point.y) // 10
}
```

Object expression(ìµëª… ê°ì²´)ê³¼ ë‹¬ë¦¬ **ì´ë¦„**ì´ ìˆì–´ ì½”ë“œ ì–´ë””ì„œë“  ì°¸ì¡°í•  ìˆ˜ ìˆê³ , ì„ ì–¸ ì‹œì ì— í´ë˜ìŠ¤ì™€ ê·¸ í´ë˜ìŠ¤ì˜ **ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤**(ì‹±ê¸€í„´)ë¥¼ ë™ì‹œì— ìƒì„±í•œë‹¤.

Kotlinì—ì„œ ì‹±ê¸€í„´ì€ ë³„ë„ íŒ¨í„´ êµ¬í˜„ ì—†ì´ `object` ì„ ì–¸ë§Œìœ¼ë¡œ ê°€ëŠ¥í•˜ê³ , ê°ì²´ëŠ” ì˜¤ì§ **í•˜ë‚˜ë§Œ** ì¡´ì¬í•˜ë©°, ëª¨ë“  ì ‘ê·¼ì€ ì´ ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í†µí•´ ì´ë£¨ì–´ì§„ë‹¤.

Object declaration is an implementation of a singleton pat-
tern, so this declaration creates a classwith a single instance.

Whenever we want to use this class, we need to operate on this
single instance. Object declarations support all the features
that classes support; for example, they can extend classes or
implement interfaces.

A programming pattern where a class is implemented
such that it can have only one instance.

```kotlin
data class User(val name: String)

interface UserProducer {
	fun produce(): User
}

object FakeUserProducer : UserProducer {
	override fun produce(): User = User("fake")
}

fun setUserProducer(producer: UserProducer) {
	println(producer.produce())
}

fun main() {
	setUserProducer(FakeUserProducer) // User(name=fake)
}
```

í™œìš© ì‚¬ë¡€

- ì „ì—­ì—ì„œ ê³µìœ í•´ì•¼ í•˜ëŠ” **ê³µí†µ ê°ì²´**
- ìƒíƒœë¥¼ í•˜ë‚˜ë¡œ ìœ ì§€í•´ì•¼ í•˜ëŠ” **ì„¤ì • ê°ì²´**
- ì¬ì‚¬ìš© ê°€ëŠ¥í•œ **ì „ì—­ ìœ í‹¸ë¦¬í‹°**ë‚˜ **Mock ê°ì²´**

## ğŸ“Œ Object Expression vs Object Declaration ë¹„êµ

| êµ¬ë¶„ | Object Expression | Object Declaration |
| --- | --- | --- |
| ì´ë¦„ | ì—†ìŒ(ìµëª…) | ìˆìŒ |
| ìƒì„± ì‹œì  | í˜¸ì¶œë  ë•Œë§ˆë‹¤ ìƒˆ ê°ì²´ ìƒì„± | ìµœì´ˆ ë¡œë“œ ì‹œ ë‹¨ì¼ ê°ì²´ ìƒì„± |
| ì¸ìŠ¤í„´ìŠ¤ ê°œìˆ˜ | ì—¬ëŸ¬ ê°œ ê°€ëŠ¥ | ë‹¨ í•˜ë‚˜(ì‹±ê¸€í„´) |
| ì‚¬ìš© ë²”ìœ„ | ìƒì„±ëœ ë²”ìœ„ì— ë”°ë¼ ì œí•œ | ì–´ë””ì„œë“  ì ‘ê·¼ ê°€ëŠ¥ |
| ì£¼ ì‚¬ìš©ì²˜ | ì½œë°±, ë¦¬ìŠ¤ë„ˆ, ì„ì‹œ ê°ì²´ | ì „ì—­ ìƒíƒœ, ì„¤ì •, ì‹±ê¸€í„´ ì„œë¹„ìŠ¤ |

## 3. Companion objects

When I reflect on the times when I worked as a Java devel-
oper, I remember discussions about what features should be

introduced into that language. A common idea I often heard
was introducing inheritance for static elements. In the end,
inheritance is very important in Java, so why canâ€™t we use it
for static elements? Kotlin has addressed this problem with
companion objects; however, to make that possible, it first
needed to eliminate actual static elements, i.e., elements that
are called on classes, not on objects.

```java
// Java
class User {
	// Static element definition
	public static User empty() {
		return new User();
	}
}

// Static element usage
User user = User.empty()
```

Yes, we donâ€™t have static elements in Kotlin, but we donâ€™t need
them because we use object declarations instead. If we define
an object declaration in a class, it is static by default (just
like classes defined inside classes), so we can directly call its
elements.

```kotlin
// Kotlin
class User {
	object Producer {
		fun empty() = User()
	}
}

// Usage
val user: User = User.Producer.empty()
```

- Javaì—ëŠ” `static` ë©¤ë²„ê°€ ìˆì§€ë§Œ **ìƒì† ë¶ˆê°€ëŠ¥**.
- Kotlinì€ ì•„ì˜ˆ `static` í‚¤ì›Œë“œ ëŒ€ì‹  **ê°ì²´ ì§€í–¥ì  ëŒ€ì•ˆ**ì¸ **companion object**ë¥¼ ë„ì….
- **companion object**ëŠ” í´ë˜ìŠ¤ ì•ˆì— ì •ì˜ëœ **ì´ë¦„ ìˆëŠ” ë‹¨ì¼ ê°ì²´**ë¡œ, í•´ë‹¹ í´ë˜ìŠ¤ì˜ ì •ì  ë©¤ë²„ì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

- **ì •ì  ë©¤ë²„ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ** í˜¸ì¶œ ì‹œ ë°˜ë“œì‹œ `User.Producer.empty()`ì²˜ëŸ¼ **object ì´ë¦„**ì„ ê±°ì³ì•¼ í•¨.
- í´ë˜ìŠ¤ ë‚´ë¶€ì˜ ì¼ë°˜ `object`ëŠ” **staticì²˜ëŸ¼ ë™ì‘**í•˜ì§€ë§Œ, ë¬¸ë²•ìƒ í˜¸ì¶œì´ ì¡°ê¸ˆ ë²ˆê±°ë¡œì›€.

This is not as convenient as static elements, but we can im-
prove it. If we use the companion keyword before an object

declaration defined inside a class, then we can call these
object methods implicitly â€œon the classâ€.

```kotlin
class User {
	companion object Producer {
		fun empty() = User()
	}
}

// Usage
val user: User = User.empty()
// or
val user: User = User.Producer.empty()
```

- `companion` í‚¤ì›Œë“œë¥¼ ë¶™ì´ë©´ **í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ ê°€ëŠ¥**.
- ì´ë¦„ì„ ìƒëµí•˜ë©´ ê¸°ë³¸ ì´ë¦„ì€ `Companion`.
- 

- `companion` í‚¤ì›Œë“œë¥¼ ë¶™ì´ë©´ **í´ë˜ìŠ¤ ì´ë¦„ì—ì„œ ë°”ë¡œ í˜¸ì¶œ ê°€ëŠ¥** (`User.empty()`).
- ì‚¬ì‹¤ìƒ Javaì˜ `static` ë©”ì„œë“œ í˜¸ì¶œê³¼ ê±°ì˜ ë™ì¼í•œ ë¬¸ë²•ì  í¸ì˜ ì œê³µ.
- ì—¬ì „íˆ ê°ì²´ì´ë¯€ë¡œ, **ìƒì†**ì´ë‚˜ **ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„**ì´ ê°€ëŠ¥.
- í´ë˜ìŠ¤ë‹¹ **í•˜ë‚˜ë§Œ** ì¡´ì¬í•  ìˆ˜ ìˆìŒ.
- í´ë˜ìŠ¤ ë¡œë“œ ì‹œ ìƒì„±ë˜ì–´ **ì‹±ê¸€í„´**ì²˜ëŸ¼ ì‚¬ìš©ë¨.

Objects with the companion modifier, also known as compan-
ion objects, do not need an explicit name. Their default name

is Companion.

```kotlin
class User {
	companion object {
		fun empty() = User()
	}
}

// Usage
val user: User = User.empty()
// or
val user: User = User.Companion.empty()
```

**íŠ¹ì§•**

- ì´ë¦„ ì—†ëŠ” companion object â†’ ê¸°ë³¸ ì´ë¦„ì€ `Companion`.
- í˜¸ì¶œ ì‹œ `User.empty()`ê°€ ê°€ì¥ ì¼ë°˜ì ì´ë©°, `User.Companion.empty()`ë„ ê°€ëŠ¥.
- í´ë˜ìŠ¤ë‹¹ 1ê°œë§Œ ê°€ëŠ¥.
- ì´ë¦„ì„ ì•ˆ ë¶™ì´ëŠ” ê²½ìš°ê°€ ë³´í¸ì ì´ë©°, ê¼­ í•„ìš”í•  ë•Œë§Œ `Companion`ìœ¼ë¡œ ì ‘ê·¼.

## ğŸ“Œ ë¹„êµ í‘œ

| êµ¬ë¶„ | í´ë˜ìŠ¤ ë‚´ë¶€ object | companion object (ì´ë¦„ ìˆìŒ) | companion object (ì´ë¦„ ì—†ìŒ) |
| --- | --- | --- | --- |
| ìƒì„± ì‹œì  | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ |
| í˜¸ì¶œ ë°©ì‹ | `User.Producer.method()` | `User.method()` ë˜ëŠ” `User.Producer.method()` | `User.method()` ë˜ëŠ” `User.Companion.method()` |
| ì´ë¦„ í•„ìˆ˜ ì—¬ë¶€ | í•„ìˆ˜ | ì„ íƒ(ë¶™ì´ë©´ í˜¸ì¶œ ê°€ëŠ¥) | ê¸°ë³¸ ì´ë¦„ `Companion` |
| ê°œìˆ˜ ì œí•œ | ì—†ìŒ | í´ë˜ìŠ¤ë‹¹ 1ê°œ | í´ë˜ìŠ¤ë‹¹ 1ê°œ |
| ì‚¬ìš© ì˜ë„ | í´ë˜ìŠ¤ ë‚´ë¶€ ì •ì  ê°ì²´ | í´ë˜ìŠ¤ ì •ì  ë©¤ë²„ + ìƒì†/êµ¬í˜„ | ê°€ì¥ ë‹¨ìˆœí•œ companion í˜•íƒœ |
| ìƒì†/ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ | ê°€ëŠ¥ | ê°€ëŠ¥ | ê°€ëŠ¥ |

---

ì´ë ‡ê²Œ ë³´ë©´

- **1ë²ˆ**ì€ í˜¸ì¶œì´ ê¸¸ê³ , ì •ì  ë©¤ë²„ ì—­í• ì€ í•˜ì§€ë§Œ í¸ì˜ì„±ì´ ë–¨ì–´ì§.
- **2ë²ˆ**ì€ staticê³¼ ìœ ì‚¬í•œ í˜¸ì¶œ + object ì´ë¦„ í˜¸ì¶œ ëª¨ë‘ ê°€ëŠ¥.
- **3ë²ˆ**ì€ ê°€ì¥ ê°„ë‹¨í•˜ê³  í”íˆ ì“°ì´ëŠ” í˜•íƒœ.

This is how we achieved a syntax that is nearly as convenient
as static elements. The only inconvenience is that we must
locate all the â€œstaticâ€ elements inside a single object (there can
be only one companion object in a class). This is a limitation,
but we have something in return: companion objects are
objects, so they can extend classes or implement interfaces.
Let me show you an example. Letâ€™s say that you represent
money in different currencies using different classes like USD,
EUR, or PLN. For convenience, each of these defines from builder
functions, which simplify object creation.

```kotlin
import java.math.BigDecimal
import java.math.MathContext
import java.math.RoundingMode.HALF_EVEN

abstract class Money(
	val amount: BigDecimal,
	val currency: String
)

class USD(amount: BigDecimal) : Money(amount, "USD") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): USD =
		USD(amount.toBigDecimal(MATH))
		fun from(amount: Double): USD =
		USD(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): USD =
		USD(amount.toBigDecimal(MATH))
	}
}

class EUR(amount: BigDecimal) : Money(amount, "EUR") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): EUR =
		EUR(amount.toBigDecimal(MATH))
		fun from(amount: Double): EUR =
		EUR(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): EUR =
		EUR(amount.toBigDecimal(MATH))
	}
}

class PLN(amount: BigDecimal) : Money(amount, "PLN") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): PLN =
		PLN(amount.toBigDecimal(MATH))
		fun from(amount: Double): PLN =
		PLN(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): PLN =
		PLN(amount.toBigDecimal(MATH))
	}
}

fun main() {
	val eur: EUR = EUR.from("12.00")
	val pln: PLN = PLN.from(20)
	val usd: USD = USD.from(32.5)
}
```

The repetitive functions for creating objects from different
types can be extracted into an abstract MoneyMaker class, which
can be extended by companion objects of different currencies.
This class can offer a range of methods to create a currency.
This way, we use companion object inheritance to extract a
pattern that is common to all companion objects of classes
that represent money.

```kotlin
import java.math.BigDecimal
import java.math.MathContext
import java.math.RoundingMode.HALF_EVEN

abstract class Money(
	val amount: BigDecimal,
	val currency: String
)

abstract class MoneyMaker<Currency : Money> {
	private val MATH = MathContext(2, HALF_EVEN)
	abstract fun from(amount: BigDecimal): Currency
	fun from(amount: Int): Currency =
	from(amount.toBigDecimal(MATH))
	fun from(amount: Double): Currency =
	from(amount.toBigDecimal(MATH))
	@Throws(NumberFormatException::class)
	fun from(amount: String): Currency =
	from(amount.toBigDecimal(MATH))
}

class USD(amount: BigDecimal) : Money(amount, "USD") {
	companion object : MoneyMaker<USD>() {
	override fun from(amount: BigDecimal): USD =
	USD(amount)
	}
}

class EUR(amount: BigDecimal) : Money(amount, "EUR") {
	companion object : MoneyMaker<EUR>() {
	override fun from(amount: BigDecimal): EUR =
	EUR(amount)
	}
}

class PLN(amount: BigDecimal) : Money(amount, "PLN") {
	companion object : MoneyMaker<PLN>() {
	override fun from(amount: BigDecimal): PLN =
	PLN(amount)
	}
}

fun main() {
	val eur: EUR = EUR.from("12.00")
	val pln: PLN = PLN.from(20)
	val usd: USD = USD.from(32.5)
}
```

Our community is still learning how to use these capabilities,
but you can already find plenty of examples in projects and libraries. Here are a few interesting examples:

```kotlin
// Using companion object inheritance for logging
// from the Kotlin Logging framework
class FooWithLogging {
	fun bar(item: Item) {
	logger.info { "Item $item" }
	// Logger comes from the companion object
	}
	companion object : KLogging()
	// companion inherits logger property
}

// Android-specific example of using an abstract factory
// for companion object
class MainActivity : Activity() {
	//...
	// Using companion object as a factory
	companion object : ActivityFactory() {
		override fun getIntent(context: Context): Intent =
		Intent(context, MainActivity::class.java)
	}
}

abstract class ActivityFactory {
	abstract fun getIntent(context: Context): Intent
		fun start(context: Context) {
			val intent = getIntent(context)
			context.startActivity(intent)
		}
		fun startForResult(activity: Activity, requestCode: Int) {
			val intent = getIntent(activity)
			activity.startActivityForResult(intent, requestCode)
		}
}

// Usage of all the members of the companion ActivityFactory
val intent = MainActivity.getIntent(context)
MainActivity.start(context)
MainActivity.startForResult(activity, requestCode)

// In contexts on Kotlin Coroutines, companion objects are
// used as keys to identify contexts
data class CoroutineName(
	val name: String
) : AbstractCoroutineContextElement(CoroutineName) {

	// Companion object is a key
	companion object Key : CoroutineContext.Key<CoroutineName>
	override fun toString(): String = "CoroutineName($name)"
}

// Finding a context by key
val name1 = context[CoroutineName] // Yes, this is a companion
// You can also refer to companion objects by its name
val name2 = context[CoroutineName.Key]
```

Do not treat them as best practices but rather as examples
ofwhat youmight dowith the fact that companion objects can
inherit from classes and implement interfaces.

### ì¥ì ê³¼ ì œí•œ

- **ì¥ì **
    - ì •ì  ë©¤ë²„ì™€ ìœ ì‚¬í•œ í¸ë¦¬í•œ í˜¸ì¶œ ë°©ì‹.
    - ê°ì²´ì´ë¯€ë¡œ ìƒì†Â·ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ ê°€ëŠ¥.
- **ì œí•œ**
    - í´ë˜ìŠ¤ë‹¹ 1ê°œë§Œ ì •ì˜ ê°€ëŠ¥.
    - ëª¨ë“  "ì •ì " ìš”ì†Œë¥¼ í•´ë‹¹ companion objectì— ëª¨ì•„ì•¼ í•¨.

## #1. staticì´ë€? ìë°”ê¸°ì¤€

- ë³´í†µ ìš°ë¦¬ê°€ í´ë˜ìŠ¤ë¥¼ ë§Œë“ ë‹¤ë©´, ì„¤ê³„ë„(í´ë˜ìŠ¤)ë¡œë¶€í„° ì—¬ëŸ¬ê°œì˜ ê°ì²´(ì¸ìŠ¤í„´ìŠ¤)ë¥¼ ì°ì–´ë‚¼ ìˆ˜ ìˆë‹¤.
- ê·¸ëŸ°ë° ê°€ë”ì€ ëª¨ë“  ê°ì²´ê°€ ê³µí†µìœ¼ë¡œ ì“°ëŠ” ë³€ìˆ˜ë‚˜ í•¨ìˆ˜ê°€ í•„ìš”í•˜ë‹¤. â€œìš°ë¦¬ íšŒì‚¬ì˜ ëŒ€í‘œ ì „í™”ë²ˆí˜¸â€ â†’ ì§ì› ê°ì²´ë¥¼ 100ê°œ ë§Œë“¤ì–´ë„ ì „í™”ë²ˆí˜¸ëŠ” í•˜ë‚˜.
- ì´ëŸ°ê±¸ ìë°”ì—ì„œëŠ” staticì´ë¼ê³  ë¶€ë¥¸ë‹¤. â†’ í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥(Company.phoneNumber).

```java
class Company {
    public static String phoneNumber = "010-1234-5678";
    public static void printHello() {
        System.out.println("Hello from company!");
    }
}

public class Main {
    public static void main(String[] args) {
        Company.printHello(); // ê°ì²´ ì•ˆ ë§Œë“¤ê³  í˜¸ì¶œ ê°€ëŠ¥
        System.out.println(Company.phoneNumber);
    }
}

```

- staticì€ í´ë˜ìŠ¤ì— ì†í•˜ê³ , ê°ì²´ì— ì†í•˜ì§€ ì•ŠëŠ”ë‹¤.
- ë©”ëª¨ë¦¬ì— ë”± í•œë²ˆë§Œ ë§Œë“¤ì–´ì§„ë‹¤.

## #2. Kotlinì€ ì™œ staticì´ ì—†ì„ê¹Œ?

Kotlinì€ ëª¨ë“ ê²Œ ê°ì²´ë¼ëŠ” ì² í•™ì„ ë”°ë¥´ê¸° ë•Œë¬¸ì—, Javaì²˜ëŸ¼ â€œê°ì²´ ì—†ì´ í˜¸ì¶œí•˜ëŠ” staticâ€ ëŒ€ì‹  object ì„ ì–¸ì„ ì‚¬ìš©. object ì„ ì–¸ë„ ë”± í•œë²ˆë§Œ ë§Œë“¤ì–´ì§€ëŠ” ê°ì²´ â†’ ì‚¬ì‹¤ìƒ staticì²˜ëŸ¼ ë™ì‘.

## #3. Object ì„ ì–¸

```kotlin
object Logger {
    fun log(msg: String) {
        println("Log: $msg")
    }
}

fun main() {
    Logger.log("Start program") // ê°ì²´ ì—†ì´ ë°”ë¡œ í˜¸ì¶œ
}

```

- íŠ¹ì§•: **ì´ë¦„ ìˆëŠ” ë‹¨ì¼ ê°ì²´** (ì‹±ê¸€í„´).
- í´ë˜ìŠ¤ ë°–ì— ë‘ë©´ ì „ì—­ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥.
- í´ë˜ìŠ¤ ì•ˆì— ë„£ìœ¼ë©´ Java static ë©¤ë²„ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥ (`User.Producer.method()`).

## #4. Companion Object

- í´ë˜ìŠ¤ ì•ˆì— ìˆëŠ” **íŠ¹ë³„í•œ object**.
- **í´ë˜ìŠ¤ ì´ë¦„**ìœ¼ë¡œ ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ì–´ì£¼ëŠ” object.

```kotlin
class User {
    companion object {
        fun empty() = User()
    }
}

fun main() {
    val u1 = User.empty()          // OK
    val u2 = User.Companion.empty() // ê¸°ë³¸ ì´ë¦„ 'Companion'
}

```

- í´ë˜ìŠ¤ë‹¹ **í•˜ë‚˜ë§Œ** ì¡´ì¬ ê°€ëŠ¥.
- Javaì˜ staticê³¼ ë¹„ìŠ·í•˜ê²Œ ì“°ì´ì§€ë§Œ, **ìƒì†Â·ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„** ê°€ëŠ¥ â†’ staticë³´ë‹¤ ê°•ë ¥.
- íŒ©í† ë¦¬ ë©”ì„œë“œ, ê³µí†µ ìƒìˆ˜, ì „ì—­ ì„¤ì • ë“±ì— ë§ì´ ì‚¬ìš©.

---

static : í´ë˜ìŠ¤ ìˆ˜ì¤€ì—ì„œ ê³µìœ ë˜ëŠ” ë©¤ë²„ë¥¼ ë§Œë“¤ê¸° ìœ„í•¨.

ëª¨ë“  ê°ì²´ê°€ í•˜ë‚˜ì˜ ê°’(ë˜ëŠ” í•¨ìˆ˜)ì„ ê³µìœ .

ê¸°ë³¸ ë©¤ë²„(ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜) : ê°ì²´ë§ˆë‹¤ ë”°ë¡œ ì¡´ì¬. ì§ì› ê°ì²´ 100ê°œë©´ ì „í™”ë²ˆí˜¸ë„ 100ê°œ.

static ë©¤ë²„ : í´ë˜ìŠ¤ì›¨ ê·€ì† â†’ ê°ì²´ ìˆ˜ì™€ ìƒê´€ì—†ì´ í•˜ë‚˜ë§Œ ì¡´ì¬.

ë©”ëª¨ë¦¬ ì ˆì•½ / ê³µí†µ ë¡œì§ / ê°ì²´ì—†ì´ ì ‘ê·¼ ê°€ëŠ¥(Company.phoneNumber: í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ)

```java
public class Employee {
    // âœ… ëª¨ë“  ì§ì›ì´ ê³µìœ í•˜ëŠ” ëŒ€í‘œ ì „í™”ë²ˆí˜¸
    public static String companyPhoneNumber = "02-1234-5678";

    private String name;
    private String position;

    public Employee(String name, String position) {
        this.name = name;
        this.position = position;
    }

    public void printInfo() {
        System.out.println(name + " (" + position + "), ëŒ€í‘œë²ˆí˜¸: " + companyPhoneNumber);
    }

    // âœ… íšŒì‚¬ ëŒ€í‘œë²ˆí˜¸ ë³€ê²½ (ê°ì²´ ì—†ì´ í˜¸ì¶œ ê°€ëŠ¥)
    public static void changeCompanyPhone(String newNumber) {
        companyPhoneNumber = newNumber;
    }

    public static void main(String[] args) {
        Employee e1 = new Employee("Alice", "Manager");
        Employee e2 = new Employee("Bob", "Developer");

        e1.printInfo(); // Alice (Manager), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678
        e2.printInfo(); // Bob (Developer), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678

        // íšŒì‚¬ ëŒ€í‘œë²ˆí˜¸ ë³€ê²½
        Employee.changeCompanyPhone("02-9999-8888");

        // ëª¨ë“  ì§ì›ì´ ë³€ê²½ëœ ë²ˆí˜¸ë¥¼ ì°¸ì¡°
        e1.printInfo(); // Alice (Manager), ëŒ€í‘œë²ˆí˜¸: 02-9999-8888
        e2.printInfo(); // Bob (Developer), ëŒ€í‘œë²ˆí˜¸: 02-9999-8888
    }
}

```

- `static`ì€ **í´ë˜ìŠ¤ì— ì†í•˜ëŠ” ê°’**ì„ ë§Œë“¤ì–´ì„œ ëª¨ë“  ê°ì²´ê°€ ê³µìœ í•  ìˆ˜ ìˆê²Œ í•œë‹¤.
- ëŒ€í‘œ ì „í™”ë²ˆí˜¸, ì„¸ìœ¨, ì „ì—­ ì¹´ìš´í„°, íšŒì‚¬ ì •ì±… ê°™ì€ **ë³€í•˜ì§€ ì•Šê±°ë‚˜ ì „ì—­ì ìœ¼ë¡œ ë™ì¼í•œ ë°ì´í„°**ì— ì í•©í•˜ë‹¤.
- ê°ì²´ë¥¼ ë§Œë“¤ì§€ ì•Šê³ ë„ í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆì–´ í¸ë¦¬í•˜ë‹¤.

```java
// ì „ì—­ ì‹±ê¸€í„´: íšŒì‚¬ ê³µí†µ ì •ì±…(ëŒ€í‘œë²ˆí˜¸)
object Company {
    var phoneNumber: String = "02-1234-5678"
    fun changePhone(newNumber: String) {
        phoneNumber = newNumber
    }
}

class Employee(
    private val name: String,
    private val position: String
) {
    fun printInfo() {
        println("$name ($position), ëŒ€í‘œë²ˆí˜¸: ${Company.phoneNumber}")
    }
}

fun main() {
    val e1 = Employee("Alice", "Manager")
    val e2 = Employee("Bob", "Developer")

    e1.printInfo() // Alice (Manager), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678
    e2.printInfo() // Bob (Developer), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678

    // íšŒì‚¬ ëŒ€í‘œë²ˆí˜¸ ë³€ê²½ (ê°ì²´ ì—†ì´, ì „ì—­ objectë¡œ)
    Company.changePhone("02-9999-8888")

    e1.printInfo() // ... 02-9999-8888
    e2.printInfo() // ... 02-9999-8888
}

```

- **ì—¬ëŸ¬ í´ë˜ìŠ¤ê°€ ê°™ì€ ì „ì—­ ì •ì±…/ë¦¬ì†ŒìŠ¤**ë¥¼ ê³µìœ í•  ë•Œ (ì˜ˆ: ë¡œê±°, ì„¤ì •, ì¹´ìš´í„°, ìºì‹œ, API í‚¤ ê´€ë¦¬ì ë“±).
- â€œíšŒì‚¬â€ì²˜ëŸ¼ **ë„ë©”ì¸ ê°œë…ìœ¼ë¡œ ë…ë¦½ ê°ì²´**ë¥¼ ë¶„ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ.

```java
class Employee(
    private val name: String,
    private val position: String
) {
    fun printInfo() {
        println("$name ($position), ëŒ€í‘œë²ˆí˜¸: $companyPhoneNumber")
    }

    companion object {
        var companyPhoneNumber: String = "02-1234-5678"

        fun changeCompanyPhone(newNumber: String) {
            companyPhoneNumber = newNumber
        }
    }
}

fun main() {
    val e1 = Employee("Alice", "Manager")
    val e2 = Employee("Bob", "Developer")

    e1.printInfo() // Alice (Manager), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678
    e2.printInfo() // Bob (Developer), ëŒ€í‘œë²ˆí˜¸: 02-1234-5678

    // í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ (ì •ì ì²˜ëŸ¼ ë³´ì„)
    Employee.changeCompanyPhone("02-9999-8888")

    e1.printInfo() // ... 02-9999-8888
    e2.printInfo() // ... 02-9999-8888
}

```

- **ê·¸ í´ë˜ìŠ¤ì— ì†í•œ ì •ì  ë©¤ë²„**ì²˜ëŸ¼ ë³´ì´ê²Œ í•˜ê³  ì‹¶ì„ ë•Œ.
- íŒ©í† ë¦¬ ë©”ì„œë“œ(`Employee.from(...)`), ìƒìˆ˜, í´ë˜ìŠ¤ ì „ìš© ìœ í‹¸ë¦¬í‹° ë“±ì„ **í´ë˜ìŠ¤ ì•ˆì— ë¬¶ê³  ì‹¶ì„ ë•Œ**.
- ì—¬ì „íˆ â€œê°ì²´â€ë¼ì„œ í•„ìš”í•˜ë©´ **ìƒì†/ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„**ë„ ê°€ëŠ¥ (Java `static`ë³´ë‹¤ ê°•ë ¥).

## ğŸ¤«Â ì–´ë–»ê²Œ ê³¨ë¼?

- **ì—¬ëŸ¬ ë„ë©”ì¸/í´ë˜ìŠ¤ì—ì„œ ê³µìœ í•´ì•¼ í•˜ëŠ” ì „ì—­ ë¦¬ì†ŒìŠ¤** â†’ `object Company` (ì „ì—­ ì‹±ê¸€í„´)
- **íŠ¹ì • í´ë˜ìŠ¤ ë‚´ë¶€ì—ë§Œ ì†í•˜ëŠ” ì •ì  ì—­í• ** â†’ `Employee`ì˜ `companion object`

## (ë¤) ì‹¤ë¬´ íŒ

- ê³µí†µ ë°ì´í„°ê°€ ì™¸ë¶€ì—ì„œ ë§‰ ë°”ë€Œë©´ ì•ˆ ë˜ë©´ `var` ëŒ€ì‹  `val` + **ì„¤ì • ë©”ì„œë“œ ë‚´ë¶€ì—ì„œë§Œ ë³€ê²½**(ìº¡ìŠí™”)í•˜ê±°ë‚˜, **ë¶ˆë³€ ë°ì´í„°**ë¡œ ì„¤ê³„í•˜ëŠ” ê²Œ ì•ˆì „í•´.
- ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì¹´ìš´í„°ì²˜ëŸ¼ ê²½ìŸ ì¡°ê±´ì´ ìƒê¸¸ ìˆ˜ ìˆìœ¼ë©´ `AtomicInteger`ë‚˜ ë™ê¸°í™”ë¡œ ë³´í˜¸í•´.

## 4. Data object declarations : ë” ì½ê¸° ì¢‹ì€ ì‹±ê¸€í„´ ìƒìˆ˜

Since Kotlin 1.8, you can use the data modifier for object declarations. It generates the toString method for the object; this method includes the object name as a string.

```kotlin
data object ABC
	fun main() {
	println(ABC) // ABC
}
```

ì¼ë°˜ `data class`ì²˜ëŸ¼, **`toString()`**, `equals()`, `hashCode()` ë“±ì´ ìë™ ìƒì„±ëœë‹¤. ë‹¨, **ì‹±ê¸€í„´ ê°ì²´**ë¼ì„œ ìƒì„±ìê°€ ì—†ìœ¼ë¯€ë¡œ `data class`ì˜ ë‹¤ë¥¸ ê¸°ëŠ¥(`copy`, `componentN`)ì€ ì§€ì›ë˜ì§€ ì•ŠìŒ.

- `toString()` ìë™ ìƒì„± â†’ ê°ì²´ ì´ë¦„(`ABC`)ì„ ì¶œë ¥í•œë‹¤.
- `object ABC`ë¼ê³ ë§Œ í–ˆìœ¼ë©´ ì¶œë ¥ì€ `ABC@hashcode` ê°™ì€ í•´ì‹œê°’ì´ì—ˆì„ ê²ƒ.

```kotlin
// âœ… ìƒíƒœ(State)ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•œ ê³µí†µ íƒ€ì…
//    â†’ sealed interfaceë¥¼ ì“°ë©´ ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë“  ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŒ (íŒ¨í„´ë§¤ì¹­ì—ì„œ exhaustive ì²´í¬ ê°€ëŠ¥)
sealed interface LoginState

// âœ… ì—´ê±°(enum) ëŒ€ì²´
//    â†’ ì›ë˜ enum class LoggedState { LOGGED_OUT, LOADING, LOGGED_IN } ì´ëŸ° ì‹ìœ¼ë¡œ ì“¸ ìˆ˜ë„ ìˆìŒ
//    â†’ í•˜ì§€ë§Œ data objectë¥¼ ì“°ë©´ enumì²˜ëŸ¼ "ì‹±ê¸€í„´ ìƒìˆ˜"ë¥¼ ë§Œë“¤ ìˆ˜ ìˆê³ ,
//       ë™ì‹œì— 'ìƒíƒœ íŒ¨í„´'ì— ì˜ ë§ê²Œ íƒ€ì… ì•ˆì „ì„±ì„ ê°€ì§ˆ ìˆ˜ ìˆìŒ
data object LoggedOut : LoginState
data object Loading   : LoginState
data object LoggedIn  : LoginState

fun main() {
    // âœ… ìƒíƒœ íŒ¨í„´ í™œìš©
    //    â†’ í˜„ì¬ ìƒíƒœë¥¼ LoginState íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•˜ê³ ,
    //      í•„ìš”ì— ë”°ë¼ LoggedOut / Loading / LoggedIn ê°™ì€ "ìƒíƒœ ê°ì²´"ë¡œ êµì²´í•œë‹¤
    var state: LoginState = LoggedOut
    println(state) // LoggedOut

    state = Loading
    println(state) // Loading

    state = LoggedIn
    println(state) // LoggedIn
}
```

## ğŸ“Œ ì •ë¦¬

- **ì—´ê±°(enum) ëŒ€ì²´**
    
    `data object`ë¥¼ ì‚¬ìš©í•´ì„œ enumì²˜ëŸ¼ â€œìƒìˆ˜ ì§‘í•©â€ì„ ë§Œë“¤ì—ˆìŒ.
    
    â†’ `LoggedOut`, `Loading`, `LoggedIn`ì€ ê°ê° ë”± í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ëŠ” ì‹±ê¸€í„´ ê°ì²´.
    
- **ìƒíƒœ íŒ¨í„´(State Pattern)**
    
    í”„ë¡œê·¸ë¨ì˜ íë¦„(ì—¬ê¸°ì„œëŠ” ë¡œê·¸ì¸ ê³¼ì •)ì´ **í˜„ì¬ ìƒíƒœ ê°ì²´**ì— ë”°ë¼ ë°”ë€Œë„ë¡ êµ¬ì„±.
    
    `var state: LoginState`ì— ì–´ë–¤ ê°ì²´ë¥¼ ë„£ëŠëƒì— ë”°ë¼,
    
    - `LoggedOut` â†’ ë¡œê·¸ì•„ì›ƒ ìƒíƒœ
    - `Loading` â†’ ë¡œë”© ì¤‘ ìƒíƒœ
    - `LoggedIn` â†’ ë¡œê·¸ì¸ ì™„ë£Œ ìƒíƒœ
        
        ë¡œ í‘œí˜„ë¨.
        

ğŸ‘‰ ì´ë ‡ê²Œ ë³´ë©´ data objectëŠ” **enumì„ ëŒ€ì²´í•˜ëŠ” ë” ìœ ì—°í•œ ë°©ì‹**ì´ê³ , sealed interface + data object ì¡°í•©ì€ **ìƒíƒœ íŒ¨í„´ì„ íƒ€ì… ì•ˆì •ì ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ë²•**

ì´ì—ìš”.

## 5. Constant values

Itâ€™s common practice to generally extract constant values
as properties of companion objects and name them using
UPPER_SNAKE_CASE. This way, we name those values and
simplify their changes in the future.We name constant values
in a characteristic way to make it clear that they represent a
constant.

```kotlin
class Product(
    val code: String,
    val price: Double,
) {
    init {
        require(price > MIN_AMOUNT) // ìƒìˆ˜ ì‚¬ìš©
    }

    companion object {
        val MIN_AMOUNT = 5.00  // ì¼ë°˜ companion object ìƒìˆ˜
    }
}
```

- Kotlinì—ì„œëŠ” **ìƒìˆ˜ ê°’(UPPER_SNAKE_CASE)**ì„ ë³´í†µ `companion object` ì•ˆì— ì •ì˜.
- ì´ë ‡ê²Œ í•˜ë©´ í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê³ , í•„ìš”ì‹œ ê°’ ë³€ê²½ë„ í•œ êµ°ë°ë§Œ ìˆ˜ì •í•˜ë©´ ë©ë‹ˆë‹¤.

When companion object properties or top-level properties
represent a constant value (known at compile time) that is 

either a primitive or a String57, we can add the const modifier.
This is an optimization. All usages of such variables will be
replaced with their values at compile time.

```kotlin
class Product(
    val code: String,
    val price: Double,
) {
    init {
        require(price > MIN_AMOUNT)
    }

    companion object {
        const val MIN_AMOUNT = 5.00 // ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜
    }
}
```

- ë§Œì•½ ê°’ì´ **ì»´íŒŒì¼ ì‹œì ì— í™•ì •ë˜ëŠ” ìƒìˆ˜**ì´ê³ , **Primitive íƒ€ì…**(Int, Double, Boolean ë“±) ë˜ëŠ” **String**ì¼ ê²½ìš°,
    
    `val` ëŒ€ì‹  **`const val`**ì„ ì‚¬ìš©í•˜ë©´ ìµœì í™”ê°€ ì¼ì–´ë‚©ë‹ˆë‹¤.
    
- ì´ ê²½ìš° **ì½”ë“œì—ì„œ í•´ë‹¹ ë³€ìˆ˜ë¥¼ ì“°ë©´ ì‹¤ì œ ê°’ìœ¼ë¡œ ì¹˜í™˜**ë©ë‹ˆë‹¤. (Javaì˜ `static final`ê³¼ ìœ ì‚¬)

Such properties can also be used in annotations:

```kotlin
private const val OUTDATED_API: String =
    "This is a part of an outdated API."

@Deprecated(OUTDATED_API)
fun foo() {
    // ...
}

@Deprecated(OUTDATED_API)
fun boo() {
    // ...
}

```

- ê¼­ í´ë˜ìŠ¤ ì•ˆì´ ì•„ë‹ˆì–´ë„, íŒŒì¼ì˜ ìµœìƒë‹¨ì— `const val`ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì´ ê²½ìš°ì—ëŠ” ì „ì—­ ìƒìˆ˜ì²˜ëŸ¼ ì“°ì´ë©´ì„œë„ ìµœì í™”ê°€ ì ìš©ë©ë‹ˆë‹¤.

ğŸ‘‰ ì£¼ì„ ë©”ì‹œì§€ì²˜ëŸ¼, `const val`ì€ **ì• ë…¸í…Œì´ì…˜(annotation)** ì•ˆì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì¼ë°˜ `val` ì€ ë¶ˆê°€ëŠ¥)

### ğŸ“Œ ìš”ì•½

1. **ìƒìˆ˜ ì„ ì–¸ ìœ„ì¹˜** â†’ ë³´í†µ `companion object` ì•ˆ, ì´ë¦„ì€ `UPPER_SNAKE_CASE`.
2. **`val` vs `const val`**
    - `val` â†’ ëŸ°íƒ€ì„ì— ê²°ì •ë  ìˆ˜ ìˆëŠ” ê°’ë„ ê°€ëŠ¥.
    - `const val` â†’ ë°˜ë“œì‹œ **ì»´íŒŒì¼ íƒ€ì„ì— ì•Œ ìˆ˜ ìˆëŠ” Primitive/String**ë§Œ ê°€ëŠ¥, ìµœì í™” ë¨.
3. **í™œìš©**
    - ê²€ì¦ ì¡°ê±´, ê¸°ë³¸ê°’, ì—ëŸ¬ ë©”ì‹œì§€, ì• ë…¸í…Œì´ì…˜ ë©”ì‹œì§€ ë“±ì— ìì£¼ ì‚¬ìš©.

## ğŸ“Š Kotlin `object` ê´€ë ¨ ê°œë… & Java `static` ë¹„êµí‘œ

| ê°œë… | ì •ì˜/íŠ¹ì§• | ìƒì„± ì‹œì  | ê°œìˆ˜ ì œí•œ | í˜¸ì¶œ ë°©ë²• | ìƒì†/êµ¬í˜„ | ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€ |
| --- | --- | --- | --- | --- | --- | --- |
| **Java static** | í´ë˜ìŠ¤ ìˆ˜ì¤€ì— ì†í•˜ëŠ” ë©¤ë²„ (ê°ì²´ ì—†ì´ ê³µìœ ) | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | ì œí•œ ì—†ìŒ | `ClassName.member` | âŒ (ìƒì† ë¶ˆê°€) | ëŒ€í‘œ ì „í™”ë²ˆí˜¸, ì „ì—­ ì¹´ìš´í„°, ìƒìˆ˜, ì •ì  ë©”ì„œë“œ |
| **Object expression** | `object {}`ë¡œ ë§Œë“œëŠ” **ìµëª… ê°ì²´** | ì‚¬ìš©ë  ë•Œë§ˆë‹¤ ìƒˆë¡œ ìƒì„± | ì—¬ëŸ¬ ê°œ ê°€ëŠ¥ | ì§€ì—­ ë³€ìˆ˜/í•„ë“œ ë“±ìœ¼ë¡œ ì°¸ì¡° | ê°€ëŠ¥ | ë¦¬ìŠ¤ë„ˆ, ì½œë°±, ì„ì‹œ ê°ì²´ |
| **Object declaration** | `object Name { ... }` â†’ **ì´ë¦„ ìˆëŠ” ì‹±ê¸€í„´** | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í•˜ë‚˜ë§Œ ì¡´ì¬ | `Name.member` | ê°€ëŠ¥ | ì „ì—­ ìœ í‹¸, ì‹±ê¸€í„´ íŒ¨í„´ |
| **Companion object (ì´ë¦„ ìˆìŒ)** | í´ë˜ìŠ¤ ë‚´ë¶€ì˜ ëŒ€í‘œ ê°ì²´, ì´ë¦„ ë¶™ì„ | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í´ë˜ìŠ¤ë‹¹ 1ê°œ | `ClassName.member` ë˜ëŠ” `ClassName.ObjectName.member` | ê°€ëŠ¥ | ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ, í´ë˜ìŠ¤ ì „ìš© ìƒìˆ˜ |
| **Companion object (ì´ë¦„ ì—†ìŒ)** | í´ë˜ìŠ¤ ë‚´ë¶€ ëŒ€í‘œ ê°ì²´, ì´ë¦„ ìƒëµ ì‹œ `Companion` | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í´ë˜ìŠ¤ë‹¹ 1ê°œ | `ClassName.member` ë˜ëŠ” `ClassName.Companion.member` | ê°€ëŠ¥ | ê°€ì¥ í”íˆ ì“°ì´ëŠ” í˜•íƒœ (`User.empty()`) |
| **Data object** | Kotlin 1.8+ `data object` â†’ `toString`, `equals`, `hashCode` ìë™ ìƒì„± | í´ë˜ìŠ¤ ë¡œë“œ ì‹œ | í•˜ë‚˜ë§Œ ì¡´ì¬ | `ObjectName` | ê°€ëŠ¥ | ì—´ê±°(enum) ëŒ€ì²´, ìƒíƒœ(State) íŒ¨í„´ |
| **Constant values (`const val`)** | ì»´íŒŒì¼ íƒ€ì„ì— í™•ì •ë˜ëŠ” ìƒìˆ˜ (Primitive, Stringë§Œ ê°€ëŠ¥) | ì»´íŒŒì¼ ì‹œ | ì œí•œ ì—†ìŒ | `ClassName.CONSTANT` ë˜ëŠ” top-level ì ‘ê·¼ | âŒ | ì• ë…¸í…Œì´ì…˜ ë©”ì‹œì§€, ìƒìˆ˜ ì •ì˜, ìµœì í™” |

## ğŸ“Š Java `static` â†” Kotlin ë§¤í•‘í‘œ

| Java | Kotlin | ë¹„ê³  |
| --- | --- | --- |
| `static field` (ì˜ˆ: `static int counter`) | `companion object { var counter = 0 }` | í´ë˜ìŠ¤ ì•ˆì—ì„œ ê³µìœ  ë©¤ë²„. í˜¸ì¶œì€ `ClassName.counter` |
| `static method` (ì˜ˆ: `static void doSomething()`) | `companion object { fun doSomething() { ... } }` | í˜¸ì¶œì€ `ClassName.doSomething()` |
| `static final` (ìƒìˆ˜, ì˜ˆ: `static final double TAX = 0.1`) | `companion object { const val TAX = 0.1 }` | `const val`ì€ **ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜** (Primitive, Stringë§Œ ê°€ëŠ¥). í˜¸ì¶œì€ `ClassName.TAX` |
| `static block` (í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¸”ë¡) | `init { ... }` ë˜ëŠ” `companion object { init { ... } }` | Kotlinì—ëŠ” ë³„ë„ static blockì´ ì—†ê³ , `init` ë¸”ë¡ì´ë‚˜ `companion object` ì´ˆê¸°í™” ë¸”ë¡ìœ¼ë¡œ ëŒ€ì²´ |
| `static inner class` | `object` ì„ ì–¸ ë˜ëŠ” `companion object` | Kotlinì€ ê¸°ë³¸ì ìœ¼ë¡œ inner classê°€ static ì„±ê²© â†’ í•„ìš” ì‹œ `object`ë‚˜ `companion` í™œìš© |
| `static import` | `import packageName.CONSTANT` | Kotlinì—ì„œë„ ìƒìˆ˜/í•¨ìˆ˜ëŠ” top-level import ê°€ëŠ¥. companion object ë©¤ë²„ë„ `@JvmField`ë‚˜ `@JvmStatic`ìœ¼ë¡œ import ìµœì í™” ê°€ëŠ¥ |
| `class with only static members` | `object SingletonName` | ì‹±ê¸€í„´ íŒ¨í„´ ëŒ€ì²´. Kotlin `object`ëŠ” JVMì—ì„œ ìë™ìœ¼ë¡œ staticìœ¼ë¡œ ì»´íŒŒì¼ë¨ |
| `enum` | `enum class` ë˜ëŠ” `sealed interface + data object` | ë‹¨ìˆœ enumì€ ê·¸ëŒ€ë¡œ `enum class`, ìƒíƒœ/íŒ¨í„´ìš©ì´ë©´ `sealed + data object` |

## 6. Summary

In this chapter, weâ€™ve learned that objects can be created
not only from classes but also using object expressions and 

object declarations. Both these kinds of objects have practical
usages. Object expression is used as an alternative to Java
anonymous objects, but it offers more. Object declaration is
Kotlinâ€™s implementation of the singleton pattern. A special
form of object declaration, known as a companion object, is
used as an alternative to static elements but with additional
support for inheritance. We also have the const modifier,
which offers better support for constant elements defined at
the top level or in object declarations.
In the previous chapter, we discussed data classes, but there
are other modifiers we use for classes in Kotlin. In the next
chapter, we will learn about another important type of class:
exceptions.

1. **ê°ì²´ ìƒì„± ë°©ë²•**
    - ê°ì²´ëŠ” ë‹¨ìˆœíˆ `class`ë¡œë§Œ ë§Œë“œëŠ” ê²Œ ì•„ë‹ˆë¼,
        
        **object expression**(ìµëª… ê°ì²´)ê³¼ **object declaration**(ì´ë¦„ ìˆëŠ” ê°ì²´)ìœ¼ë¡œë„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
        
2. **Object expression**
    - Javaì˜ **ìµëª… í´ë˜ìŠ¤** ëŒ€ì²´.
    - í•˜ì§€ë§Œ ë” ê°•ë ¥í•´ì„œ **ë©¤ë²„ ì •ì˜, ìƒì†, ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„**ë„ ê°€ëŠ¥.
    - ì£¼ë¡œ **ë¦¬ìŠ¤ë„ˆ, ì½œë°±** ë“± ì„ì‹œ ê°ì²´ì— í™œìš©.
3. **Object declaration**
    - Kotlinì˜ **ì‹±ê¸€í„´ íŒ¨í„´ êµ¬í˜„**.
    - í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ëŠ” ê°ì²´ë¥¼ ì œê³µ.
    - ì „ì—­ ìœ í‹¸ë¦¬í‹°, ê³µìœ  ë¦¬ì†ŒìŠ¤ ë“±ì— ì‚¬ìš©.
4. **Companion object**
    - object declarationì˜ íŠ¹ë³„í•œ í˜•íƒœ.
    - Javaì˜ `static` ëŒ€ì²´ + **ìƒì†/ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ ê°€ëŠ¥**.
    - í´ë˜ìŠ¤ ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥ (`User.empty()`).
5. **Const modifier**
    - `const val`ì„ ì“°ë©´ **ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜**ë¡œ ìµœì í™”.
    - top-level ë˜ëŠ” companion object ì•ˆì—ì„œ ì£¼ë¡œ ì •ì˜.
    - ì• ë…¸í…Œì´ì…˜ ë©”ì‹œì§€ì—ë„ ì‚¬ìš© ê°€ëŠ¥.

What is an object? This is the question I often start this section
with inmyworkshops, and I generally get an instant response,
“An instance of a class”. That is right, but how do we create
objects? One way is easy: using constructors.

```kotlin
class A
// Using a constructor to create an object
val a = A()
```

객체는 일반적으로 “클래스의 인스턴스”라고 정의하고, 위처럼 기본적으로 생성자를 이용해서 만들어지지만, 2가지 추가적인 방법이 있다.

However, this is not the only way. In Kotlin, we can also create
objects using object expression and object declaration. Let’s
discuss these two options.

## 1. Object expressions

To create an empty object using an expression, we use the
object keyword and braces. This syntax for creating objects is
known as object expression.

```kotlin
val instance = object {}
```

`object {}` 구문을 사용해 **익명 객체(anonymous object)**를 생성하는 방법입니다. 

An empty object extends no classes (except for Any, which is
extended by all objects in Kotlin), implements no interfaces,
and has nothing inside its body. Nevertheless, it is useful. Its
power lies in its uniqueness: such an object equals nothing
else but itself. Therefore, it is perfectly suited to be used as
some kind of token or synchronization lock.

```kotlin
class Box {
	var value: Any? = NOT_SET
	fun initialized() = value != NOT_SET
	
	companion object {
		private val NOT_SET = object {}
	}
}

private val LOCK = object {}
fun synchronizedOperation() = synchronized(LOCK) {
	// ...
}
```

- **object {}를 비워두면** Any만 상속하는 기본형 빈 객체가 된다.
- **object {} 안에 멤버·상속·인터페이스 구현을 추가할 수도 있다.**

An empty object can also be created with the constructor of
Any, so Any() is an alternative to object {}.

```kotlin
private val NOT_SET = Any()
```

However, objects created with an object expression do not

need to be empty. They can have bodies, extend classes, im-
plement interfaces, etc. The syntax is the same as for classes,

but object declarations use the object keyword instead of class
and should not define the name or constructor.

```kotlin
data class User(val name: String)

interface UserProducer {
	fun produce(): User
}

fun printUser(producer: UserProducer) {
	println(producer.produce())
}

fun main() {
	val user = User("Jake")
	val producer = object : UserProducer {
	override fun produce(): User = user
	}
	printUser(producer) // User(name=Jake)
}
```

In a local scope, object expressions define an anonymous
type that won’t work outside the class where it is defined.
This means the non-inherited members of object expressions
are accessible only when an anonymous object is declared
in a local or class-private scope; otherwise, the object is just
an opaque Any type, or the type of the class or interface it
inherits from. This makes non-inherited members of object
expressions hard to use in real-life projects.

```kotlin
class Robot {
	// Possible, but rarely useful
	// prefer regular member properties instead
	private val point = object {
		var x = 0
		var y = 0
	}
	fun moveUp() {
	point.y += 10
}

fun show() {
	println("(${point.x}, ${point.y})")
	}
}

fun main() {
	val robot = Robot()
	robot.show() // (0, 0)
	robot.moveUp()
	robot.show() // (0, 10)
	val point = object {
	var x = 0
	var y = 0
}

println(point.x) // 0
point.y = 10
println(point.y) // 10
}
```

- **로컬 범위**(함수 내부, private 속성 등)에서 만든 경우 → 해당 범위 내에서만 **익명 타입**으로 사용 가능.
- **공개(public) 범위**에서 만든 경우 → 타입이 `Any` 또는 구현한 클래스/인터페이스 타입으로만 보임 → **비상속 멤버 사용 불가**.

In practice, object expressions are used as an alternative
to Java anonymous classes, i.e., when we need to create a
watcher or a listener with multiple handler methods.

```kotlin
taskNameView.addTextChangedListener(object : TextWatcher {
    override fun afterTextChanged(editable: Editable?) { /* ... */ }
    override fun beforeTextChanged(text: CharSequence?, start: Int, count: Int, after: Int) { /* ... */ }
    override fun onTextChanged(text: CharSequence?, start: Int, before: Int, count: Int) { /* ... */ }
})
```

Object expression은 Java의 **익명 클래스** 대체 용도로 많이 씀. 대표적으로 **리스너(listener)**, **콜백(callback)** 구현 시 사용.

Note that “object expression” is a better name than “anony-mous class” since this is an expression that produces an object.

## 💡 Object Expression 핵심 정리

1. **정의**
    
    `object {}` 문법을 사용해 **익명 객체(anonymous object)**를 생성할 수 있다.
    
    Java의 익명 클래스와 비슷하지만, **클래스를 정의하는 것이 아니라 객체를 바로 생성하는 표현식**이라는 점이 다르다.
    
2. **빈 객체와 확장 가능성**
    
    `object {}`를 **비워두면** `Any`만 상속하는 **기본형 빈 객체**가 된다.
    
    하지만 중괄호 안에 **멤버를 추가**하거나, **클래스를 상속**하거나, **인터페이스를 구현**하는 것도 가능하다.
    
3. **이름과 생성자 없음**
    
    Object expression은 **이름(name)과 생성자(constructor)**를 정의하지 않는다.
    
    - **로컬 범위**나 **private 범위**에서 생성한 경우 → 해당 익명 타입의 멤버에 직접 접근 가능.
    - **public 범위**에서 생성한 경우 → `Any` 타입이나 상속·구현한 타입으로만 접근 가능하며, 비상속 멤버는 사용할 수 없다.
4. **활용 예시**
    
    내용이 없는 빈 객체라도 **유일성(uniqueness)**을 가지므로,
    
    - 토큰(token)이나 **동기화 락(lock)**
    - 리스너(listener), 콜백(callback), Watcher 등의 **간단 객체 생성**

## 2. Object declaration

If we take an object expression and give it a name, we get an
object declaration. This structure also creates a single object,
but this object is not anonymous: it has a name that can be
used to reference it.

```kotlin
object Point {
	var x = 0
	var y = 0
}

fun main() {
	println(Point.x) // 0
	Point.y = 10
	println(Point.y) // 10
	val p = Point
	p.x = 20
	println(Point.x) // 20
	println(Point.y) // 10
}
```

Object expression(익명 객체)과 달리 **이름**이 있어 코드 어디서든 참조할 수 있고, 선언 시점에 클래스와 그 클래스의 **단일 인스턴스**(싱글턴)를 동시에 생성한다.

Kotlin에서 싱글턴은 별도 패턴 구현 없이 `object` 선언만으로 가능하고, 객체는 오직 **하나만** 존재하며, 모든 접근은 이 단일 인스턴스를 통해 이루어진다.

Object declaration is an implementation of a singleton pat-
tern, so this declaration creates a classwith a single instance.

Whenever we want to use this class, we need to operate on this
single instance. Object declarations support all the features
that classes support; for example, they can extend classes or
implement interfaces.

A programming pattern where a class is implemented
such that it can have only one instance.

```kotlin
data class User(val name: String)

interface UserProducer {
	fun produce(): User
}

object FakeUserProducer : UserProducer {
	override fun produce(): User = User("fake")
}

fun setUserProducer(producer: UserProducer) {
	println(producer.produce())
}

fun main() {
	setUserProducer(FakeUserProducer) // User(name=fake)
}
```

활용 사례

- 전역에서 공유해야 하는 **공통 객체**
- 상태를 하나로 유지해야 하는 **설정 객체**
- 재사용 가능한 **전역 유틸리티**나 **Mock 객체**

## 📌 Object Expression vs Object Declaration 비교

| 구분 | Object Expression | Object Declaration |
| --- | --- | --- |
| 이름 | 없음(익명) | 있음 |
| 생성 시점 | 호출될 때마다 새 객체 생성 | 최초 로드 시 단일 객체 생성 |
| 인스턴스 개수 | 여러 개 가능 | 단 하나(싱글턴) |
| 사용 범위 | 생성된 범위에 따라 제한 | 어디서든 접근 가능 |
| 주 사용처 | 콜백, 리스너, 임시 객체 | 전역 상태, 설정, 싱글턴 서비스 |

## 3. Companion objects

When I reflect on the times when I worked as a Java devel-
oper, I remember discussions about what features should be

introduced into that language. A common idea I often heard
was introducing inheritance for static elements. In the end,
inheritance is very important in Java, so why can’t we use it
for static elements? Kotlin has addressed this problem with
companion objects; however, to make that possible, it first
needed to eliminate actual static elements, i.e., elements that
are called on classes, not on objects.

```java
// Java
class User {
	// Static element definition
	public static User empty() {
		return new User();
	}
}

// Static element usage
User user = User.empty()
```

Yes, we don’t have static elements in Kotlin, but we don’t need
them because we use object declarations instead. If we define
an object declaration in a class, it is static by default (just
like classes defined inside classes), so we can directly call its
elements.

```kotlin
// Kotlin
class User {
	object Producer {
		fun empty() = User()
	}
}

// Usage
val user: User = User.Producer.empty()
```

- Java에는 `static` 멤버가 있지만 **상속 불가능**.
- Kotlin은 아예 `static` 키워드 대신 **객체 지향적 대안**인 **companion object**를 도입.
- **companion object**는 클래스 안에 정의된 **이름 있는 단일 객체**로, 해당 클래스의 정적 멤버처럼 사용할 수 있다.

- **정적 멤버처럼 보이지만** 호출 시 반드시 `User.Producer.empty()`처럼 **object 이름**을 거쳐야 함.
- 클래스 내부의 일반 `object`는 **static처럼 동작**하지만, 문법상 호출이 조금 번거로움.

This is not as convenient as static elements, but we can im-
prove it. If we use the companion keyword before an object

declaration defined inside a class, then we can call these
object methods implicitly “on the class”.

```kotlin
class User {
	companion object Producer {
		fun empty() = User()
	}
}

// Usage
val user: User = User.empty()
// or
val user: User = User.Producer.empty()
```

- `companion` 키워드를 붙이면 **클래스 이름으로 바로 호출 가능**.
- 이름을 생략하면 기본 이름은 `Companion`.
- 

- `companion` 키워드를 붙이면 **클래스 이름에서 바로 호출 가능** (`User.empty()`).
- 사실상 Java의 `static` 메서드 호출과 거의 동일한 문법적 편의 제공.
- 여전히 객체이므로, **상속**이나 **인터페이스 구현**이 가능.
- 클래스당 **하나만** 존재할 수 있음.
- 클래스 로드 시 생성되어 **싱글턴**처럼 사용됨.

Objects with the companion modifier, also known as compan-
ion objects, do not need an explicit name. Their default name

is Companion.

```kotlin
class User {
	companion object {
		fun empty() = User()
	}
}

// Usage
val user: User = User.empty()
// or
val user: User = User.Companion.empty()
```

**특징**

- 이름 없는 companion object → 기본 이름은 `Companion`.
- 호출 시 `User.empty()`가 가장 일반적이며, `User.Companion.empty()`도 가능.
- 클래스당 1개만 가능.
- 이름을 안 붙이는 경우가 보편적이며, 꼭 필요할 때만 `Companion`으로 접근.

## 📌 비교 표

| 구분 | 클래스 내부 object | companion object (이름 있음) | companion object (이름 없음) |
| --- | --- | --- | --- |
| 생성 시점 | 클래스 로드 시 | 클래스 로드 시 | 클래스 로드 시 |
| 호출 방식 | `User.Producer.method()` | `User.method()` 또는 `User.Producer.method()` | `User.method()` 또는 `User.Companion.method()` |
| 이름 필수 여부 | 필수 | 선택(붙이면 호출 가능) | 기본 이름 `Companion` |
| 개수 제한 | 없음 | 클래스당 1개 | 클래스당 1개 |
| 사용 의도 | 클래스 내부 정적 객체 | 클래스 정적 멤버 + 상속/구현 | 가장 단순한 companion 형태 |
| 상속/인터페이스 구현 | 가능 | 가능 | 가능 |

---

이렇게 보면

- **1번**은 호출이 길고, 정적 멤버 역할은 하지만 편의성이 떨어짐.
- **2번**은 static과 유사한 호출 + object 이름 호출 모두 가능.
- **3번**은 가장 간단하고 흔히 쓰이는 형태.

This is how we achieved a syntax that is nearly as convenient
as static elements. The only inconvenience is that we must
locate all the “static” elements inside a single object (there can
be only one companion object in a class). This is a limitation,
but we have something in return: companion objects are
objects, so they can extend classes or implement interfaces.
Let me show you an example. Let’s say that you represent
money in different currencies using different classes like USD,
EUR, or PLN. For convenience, each of these defines from builder
functions, which simplify object creation.

```kotlin
import java.math.BigDecimal
import java.math.MathContext
import java.math.RoundingMode.HALF_EVEN

abstract class Money(
	val amount: BigDecimal,
	val currency: String
)

class USD(amount: BigDecimal) : Money(amount, "USD") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): USD =
		USD(amount.toBigDecimal(MATH))
		fun from(amount: Double): USD =
		USD(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): USD =
		USD(amount.toBigDecimal(MATH))
	}
}

class EUR(amount: BigDecimal) : Money(amount, "EUR") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): EUR =
		EUR(amount.toBigDecimal(MATH))
		fun from(amount: Double): EUR =
		EUR(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): EUR =
		EUR(amount.toBigDecimal(MATH))
	}
}

class PLN(amount: BigDecimal) : Money(amount, "PLN") {
	companion object {
		private val MATH = MathContext(2, HALF_EVEN)
		fun from(amount: Int): PLN =
		PLN(amount.toBigDecimal(MATH))
		fun from(amount: Double): PLN =
		PLN(amount.toBigDecimal(MATH))
		@Throws(NumberFormatException::class)
		fun from(amount: String): PLN =
		PLN(amount.toBigDecimal(MATH))
	}
}

fun main() {
	val eur: EUR = EUR.from("12.00")
	val pln: PLN = PLN.from(20)
	val usd: USD = USD.from(32.5)
}
```

The repetitive functions for creating objects from different
types can be extracted into an abstract MoneyMaker class, which
can be extended by companion objects of different currencies.
This class can offer a range of methods to create a currency.
This way, we use companion object inheritance to extract a
pattern that is common to all companion objects of classes
that represent money.

```kotlin
import java.math.BigDecimal
import java.math.MathContext
import java.math.RoundingMode.HALF_EVEN

abstract class Money(
	val amount: BigDecimal,
	val currency: String
)

abstract class MoneyMaker<Currency : Money> {
	private val MATH = MathContext(2, HALF_EVEN)
	abstract fun from(amount: BigDecimal): Currency
	fun from(amount: Int): Currency =
	from(amount.toBigDecimal(MATH))
	fun from(amount: Double): Currency =
	from(amount.toBigDecimal(MATH))
	@Throws(NumberFormatException::class)
	fun from(amount: String): Currency =
	from(amount.toBigDecimal(MATH))
}

class USD(amount: BigDecimal) : Money(amount, "USD") {
	companion object : MoneyMaker<USD>() {
	override fun from(amount: BigDecimal): USD =
	USD(amount)
	}
}

class EUR(amount: BigDecimal) : Money(amount, "EUR") {
	companion object : MoneyMaker<EUR>() {
	override fun from(amount: BigDecimal): EUR =
	EUR(amount)
	}
}

class PLN(amount: BigDecimal) : Money(amount, "PLN") {
	companion object : MoneyMaker<PLN>() {
	override fun from(amount: BigDecimal): PLN =
	PLN(amount)
	}
}

fun main() {
	val eur: EUR = EUR.from("12.00")
	val pln: PLN = PLN.from(20)
	val usd: USD = USD.from(32.5)
}
```

Our community is still learning how to use these capabilities,
but you can already find plenty of examples in projects and libraries. Here are a few interesting examples:

```kotlin
// Using companion object inheritance for logging
// from the Kotlin Logging framework
class FooWithLogging {
	fun bar(item: Item) {
	logger.info { "Item $item" }
	// Logger comes from the companion object
	}
	companion object : KLogging()
	// companion inherits logger property
}

// Android-specific example of using an abstract factory
// for companion object
class MainActivity : Activity() {
	//...
	// Using companion object as a factory
	companion object : ActivityFactory() {
		override fun getIntent(context: Context): Intent =
		Intent(context, MainActivity::class.java)
	}
}

abstract class ActivityFactory {
	abstract fun getIntent(context: Context): Intent
		fun start(context: Context) {
			val intent = getIntent(context)
			context.startActivity(intent)
		}
		fun startForResult(activity: Activity, requestCode: Int) {
			val intent = getIntent(activity)
			activity.startActivityForResult(intent, requestCode)
		}
}

// Usage of all the members of the companion ActivityFactory
val intent = MainActivity.getIntent(context)
MainActivity.start(context)
MainActivity.startForResult(activity, requestCode)

// In contexts on Kotlin Coroutines, companion objects are
// used as keys to identify contexts
data class CoroutineName(
	val name: String
) : AbstractCoroutineContextElement(CoroutineName) {

	// Companion object is a key
	companion object Key : CoroutineContext.Key<CoroutineName>
	override fun toString(): String = "CoroutineName($name)"
}

// Finding a context by key
val name1 = context[CoroutineName] // Yes, this is a companion
// You can also refer to companion objects by its name
val name2 = context[CoroutineName.Key]
```

Do not treat them as best practices but rather as examples
ofwhat youmight dowith the fact that companion objects can
inherit from classes and implement interfaces.

### 장점과 제한

- **장점**
    - 정적 멤버와 유사한 편리한 호출 방식.
    - 객체이므로 상속·인터페이스 구현 가능.
- **제한**
    - 클래스당 1개만 정의 가능.
    - 모든 "정적" 요소를 해당 companion object에 모아야 함.

## #1. static이란? 자바기준

- 보통 우리가 클래스를 만든다면, 설계도(클래스)로부터 여러개의 객체(인스턴스)를 찍어낼 수 있다.
- 그런데 가끔은 모든 객체가 공통으로 쓰는 변수나 함수가 필요하다. “우리 회사의 대표 전화번호” → 직원 객체를 100개 만들어도 전화번호는 하나.
- 이런걸 자바에서는 static이라고 부른다. → 클래스 이름으로 바로 접근 가능(Company.phoneNumber).

```java
class Company {
    public static String phoneNumber = "010-1234-5678";
    public static void printHello() {
        System.out.println("Hello from company!");
    }
}

public class Main {
    public static void main(String[] args) {
        Company.printHello(); // 객체 안 만들고 호출 가능
        System.out.println(Company.phoneNumber);
    }
}

```

- static은 클래스에 속하고, 객체에 속하지 않는다.
- 메모리에 딱 한번만 만들어진다.

## #2. Kotlin은 왜 static이 없을까?

Kotlin은 모든게 객체라는 철학을 따르기 때문에, Java처럼 “객체 없이 호출하는 static” 대신 object 선언을 사용. object 선언도 딱 한번만 만들어지는 객체 → 사실상 static처럼 동작.

## #3. Object 선언

```kotlin
object Logger {
    fun log(msg: String) {
        println("Log: $msg")
    }
}

fun main() {
    Logger.log("Start program") // 객체 없이 바로 호출
}

```

- 특징: **이름 있는 단일 객체** (싱글턴).
- 클래스 밖에 두면 전역에서 접근 가능.
- 클래스 안에 넣으면 Java static 멤버처럼 사용 가능 (`User.Producer.method()`).

## #4. Companion Object

- 클래스 안에 있는 **특별한 object**.
- **클래스 이름**으로 바로 접근 가능하게 만들어주는 object.

```kotlin
class User {
    companion object {
        fun empty() = User()
    }
}

fun main() {
    val u1 = User.empty()          // OK
    val u2 = User.Companion.empty() // 기본 이름 'Companion'
}

```

- 클래스당 **하나만** 존재 가능.
- Java의 static과 비슷하게 쓰이지만, **상속·인터페이스 구현** 가능 → static보다 강력.
- 팩토리 메서드, 공통 상수, 전역 설정 등에 많이 사용.

---

static : 클래스 수준에서 공유되는 멤버를 만들기 위함.

모든 객체가 하나의 값(또는 함수)을 공유.

기본 멤버(인스턴스 변수) : 객체마다 따로 존재. 직원 객체 100개면 전화번호도 100개.

static 멤버 : 클래스웨 귀속 → 객체 수와 상관없이 하나만 존재.

메모리 절약 / 공통 로직 / 객체없이 접근 가능(Company.phoneNumber: 클래스 이름으로 바로 호출)

```java
public class Employee {
    // ✅ 모든 직원이 공유하는 대표 전화번호
    public static String companyPhoneNumber = "02-1234-5678";

    private String name;
    private String position;

    public Employee(String name, String position) {
        this.name = name;
        this.position = position;
    }

    public void printInfo() {
        System.out.println(name + " (" + position + "), 대표번호: " + companyPhoneNumber);
    }

    // ✅ 회사 대표번호 변경 (객체 없이 호출 가능)
    public static void changeCompanyPhone(String newNumber) {
        companyPhoneNumber = newNumber;
    }

    public static void main(String[] args) {
        Employee e1 = new Employee("Alice", "Manager");
        Employee e2 = new Employee("Bob", "Developer");

        e1.printInfo(); // Alice (Manager), 대표번호: 02-1234-5678
        e2.printInfo(); // Bob (Developer), 대표번호: 02-1234-5678

        // 회사 대표번호 변경
        Employee.changeCompanyPhone("02-9999-8888");

        // 모든 직원이 변경된 번호를 참조
        e1.printInfo(); // Alice (Manager), 대표번호: 02-9999-8888
        e2.printInfo(); // Bob (Developer), 대표번호: 02-9999-8888
    }
}

```

- `static`은 **클래스에 속하는 값**을 만들어서 모든 객체가 공유할 수 있게 한다.
- 대표 전화번호, 세율, 전역 카운터, 회사 정책 같은 **변하지 않거나 전역적으로 동일한 데이터**에 적합하다.
- 객체를 만들지 않고도 클래스 이름으로 접근할 수 있어 편리하다.

```java
// 전역 싱글턴: 회사 공통 정책(대표번호)
object Company {
    var phoneNumber: String = "02-1234-5678"
    fun changePhone(newNumber: String) {
        phoneNumber = newNumber
    }
}

class Employee(
    private val name: String,
    private val position: String
) {
    fun printInfo() {
        println("$name ($position), 대표번호: ${Company.phoneNumber}")
    }
}

fun main() {
    val e1 = Employee("Alice", "Manager")
    val e2 = Employee("Bob", "Developer")

    e1.printInfo() // Alice (Manager), 대표번호: 02-1234-5678
    e2.printInfo() // Bob (Developer), 대표번호: 02-1234-5678

    // 회사 대표번호 변경 (객체 없이, 전역 object로)
    Company.changePhone("02-9999-8888")

    e1.printInfo() // ... 02-9999-8888
    e2.printInfo() // ... 02-9999-8888
}

```

- **여러 클래스가 같은 전역 정책/리소스**를 공유할 때 (예: 로거, 설정, 카운터, 캐시, API 키 관리자 등).
- “회사”처럼 **도메인 개념으로 독립 객체**를 분리하고 싶을 때.

```java
class Employee(
    private val name: String,
    private val position: String
) {
    fun printInfo() {
        println("$name ($position), 대표번호: $companyPhoneNumber")
    }

    companion object {
        var companyPhoneNumber: String = "02-1234-5678"

        fun changeCompanyPhone(newNumber: String) {
            companyPhoneNumber = newNumber
        }
    }
}

fun main() {
    val e1 = Employee("Alice", "Manager")
    val e2 = Employee("Bob", "Developer")

    e1.printInfo() // Alice (Manager), 대표번호: 02-1234-5678
    e2.printInfo() // Bob (Developer), 대표번호: 02-1234-5678

    // 클래스 이름으로 바로 호출 (정적처럼 보임)
    Employee.changeCompanyPhone("02-9999-8888")

    e1.printInfo() // ... 02-9999-8888
    e2.printInfo() // ... 02-9999-8888
}

```

- **그 클래스에 속한 정적 멤버**처럼 보이게 하고 싶을 때.
- 팩토리 메서드(`Employee.from(...)`), 상수, 클래스 전용 유틸리티 등을 **클래스 안에 묶고 싶을 때**.
- 여전히 “객체”라서 필요하면 **상속/인터페이스 구현**도 가능 (Java `static`보다 강력).

## 🤫 어떻게 골라?

- **여러 도메인/클래스에서 공유해야 하는 전역 리소스** → `object Company` (전역 싱글턴)
- **특정 클래스 내부에만 속하는 정적 역할** → `Employee`의 `companion object`

## (덤) 실무 팁

- 공통 데이터가 외부에서 막 바뀌면 안 되면 `var` 대신 `val` + **설정 메서드 내부에서만 변경**(캡슐화)하거나, **불변 데이터**로 설계하는 게 안전해.
- 멀티스레드 환경에서 카운터처럼 경쟁 조건이 생길 수 있으면 `AtomicInteger`나 동기화로 보호해.

## 4. Data object declarations : 더 읽기 좋은 싱글턴 상수

Since Kotlin 1.8, you can use the data modifier for object declarations. It generates the toString method for the object; this method includes the object name as a string.

```kotlin
data object ABC
	fun main() {
	println(ABC) // ABC
}
```

일반 `data class`처럼, **`toString()`**, `equals()`, `hashCode()` 등이 자동 생성된다. 단, **싱글턴 객체**라서 생성자가 없으므로 `data class`의 다른 기능(`copy`, `componentN`)은 지원되지 않음.

- `toString()` 자동 생성 → 객체 이름(`ABC`)을 출력한다.
- `object ABC`라고만 했으면 출력은 `ABC@hashcode` 같은 해시값이었을 것.

```kotlin
// ✅ 상태(State)를 표현하기 위한 공통 타입
//    → sealed interface를 쓰면 컴파일러가 모든 상태를 알 수 있음 (패턴매칭에서 exhaustive 체크 가능)
sealed interface LoginState

// ✅ 열거(enum) 대체
//    → 원래 enum class LoggedState { LOGGED_OUT, LOADING, LOGGED_IN } 이런 식으로 쓸 수도 있음
//    → 하지만 data object를 쓰면 enum처럼 "싱글턴 상수"를 만들 수 있고,
//       동시에 '상태 패턴'에 잘 맞게 타입 안전성을 가질 수 있음
data object LoggedOut : LoginState
data object Loading   : LoginState
data object LoggedIn  : LoginState

fun main() {
    // ✅ 상태 패턴 활용
    //    → 현재 상태를 LoginState 타입으로 선언하고,
    //      필요에 따라 LoggedOut / Loading / LoggedIn 같은 "상태 객체"로 교체한다
    var state: LoginState = LoggedOut
    println(state) // LoggedOut

    state = Loading
    println(state) // Loading

    state = LoggedIn
    println(state) // LoggedIn
}
```

## 📌 정리

- **열거(enum) 대체**
    
    `data object`를 사용해서 enum처럼 “상수 집합”을 만들었음.
    
    → `LoggedOut`, `Loading`, `LoggedIn`은 각각 딱 하나만 존재하는 싱글턴 객체.
    
- **상태 패턴(State Pattern)**
    
    프로그램의 흐름(여기서는 로그인 과정)이 **현재 상태 객체**에 따라 바뀌도록 구성.
    
    `var state: LoginState`에 어떤 객체를 넣느냐에 따라,
    
    - `LoggedOut` → 로그아웃 상태
    - `Loading` → 로딩 중 상태
    - `LoggedIn` → 로그인 완료 상태
        
        로 표현됨.
        

👉 이렇게 보면 data object는 **enum을 대체하는 더 유연한 방식**이고, sealed interface + data object 조합은 **상태 패턴을 타입 안정적으로 구현하는 방법**

이에요.

## 5. Constant values

It’s common practice to generally extract constant values
as properties of companion objects and name them using
UPPER_SNAKE_CASE. This way, we name those values and
simplify their changes in the future.We name constant values
in a characteristic way to make it clear that they represent a
constant.

```kotlin
class Product(
    val code: String,
    val price: Double,
) {
    init {
        require(price > MIN_AMOUNT) // 상수 사용
    }

    companion object {
        val MIN_AMOUNT = 5.00  // 일반 companion object 상수
    }
}
```

- Kotlin에서는 **상수 값(UPPER_SNAKE_CASE)**을 보통 `companion object` 안에 정의.
- 이렇게 하면 클래스 내부에서 재사용 가능하고, 필요시 값 변경도 한 군데만 수정하면 됩니다.

When companion object properties or top-level properties
represent a constant value (known at compile time) that is 

either a primitive or a String57, we can add the const modifier.
This is an optimization. All usages of such variables will be
replaced with their values at compile time.

```kotlin
class Product(
    val code: String,
    val price: Double,
) {
    init {
        require(price > MIN_AMOUNT)
    }

    companion object {
        const val MIN_AMOUNT = 5.00 // 컴파일 타임 상수
    }
}
```

- 만약 값이 **컴파일 시점에 확정되는 상수**이고, **Primitive 타입**(Int, Double, Boolean 등) 또는 **String**일 경우,
    
    `val` 대신 **`const val`**을 사용하면 최적화가 일어납니다.
    
- 이 경우 **코드에서 해당 변수를 쓰면 실제 값으로 치환**됩니다. (Java의 `static final`과 유사)

Such properties can also be used in annotations:

```kotlin
private const val OUTDATED_API: String =
    "This is a part of an outdated API."

@Deprecated(OUTDATED_API)
fun foo() {
    // ...
}

@Deprecated(OUTDATED_API)
fun boo() {
    // ...
}

```

- 꼭 클래스 안이 아니어도, 파일의 최상단에 `const val`을 정의할 수 있습니다.
- 이 경우에는 전역 상수처럼 쓰이면서도 최적화가 적용됩니다.

👉 주석 메시지처럼, `const val`은 **애노테이션(annotation)** 안에서도 사용할 수 있습니다. (일반 `val` 은 불가능)

### 📌 요약

1. **상수 선언 위치** → 보통 `companion object` 안, 이름은 `UPPER_SNAKE_CASE`.
2. **`val` vs `const val`**
    - `val` → 런타임에 결정될 수 있는 값도 가능.
    - `const val` → 반드시 **컴파일 타임에 알 수 있는 Primitive/String**만 가능, 최적화 됨.
3. **활용**
    - 검증 조건, 기본값, 에러 메시지, 애노테이션 메시지 등에 자주 사용.

## 📊 Kotlin `object` 관련 개념 & Java `static` 비교표

| 개념 | 정의/특징 | 생성 시점 | 개수 제한 | 호출 방법 | 상속/구현 | 주요 사용 사례 |
| --- | --- | --- | --- | --- | --- | --- |
| **Java static** | 클래스 수준에 속하는 멤버 (객체 없이 공유) | 클래스 로드 시 | 제한 없음 | `ClassName.member` | ❌ (상속 불가) | 대표 전화번호, 전역 카운터, 상수, 정적 메서드 |
| **Object expression** | `object {}`로 만드는 **익명 객체** | 사용될 때마다 새로 생성 | 여러 개 가능 | 지역 변수/필드 등으로 참조 | 가능 | 리스너, 콜백, 임시 객체 |
| **Object declaration** | `object Name { ... }` → **이름 있는 싱글턴** | 클래스 로드 시 | 하나만 존재 | `Name.member` | 가능 | 전역 유틸, 싱글턴 패턴 |
| **Companion object (이름 있음)** | 클래스 내부의 대표 객체, 이름 붙임 | 클래스 로드 시 | 클래스당 1개 | `ClassName.member` 또는 `ClassName.ObjectName.member` | 가능 | 정적 팩토리 메서드, 클래스 전용 상수 |
| **Companion object (이름 없음)** | 클래스 내부 대표 객체, 이름 생략 시 `Companion` | 클래스 로드 시 | 클래스당 1개 | `ClassName.member` 또는 `ClassName.Companion.member` | 가능 | 가장 흔히 쓰이는 형태 (`User.empty()`) |
| **Data object** | Kotlin 1.8+ `data object` → `toString`, `equals`, `hashCode` 자동 생성 | 클래스 로드 시 | 하나만 존재 | `ObjectName` | 가능 | 열거(enum) 대체, 상태(State) 패턴 |
| **Constant values (`const val`)** | 컴파일 타임에 확정되는 상수 (Primitive, String만 가능) | 컴파일 시 | 제한 없음 | `ClassName.CONSTANT` 또는 top-level 접근 | ❌ | 애노테이션 메시지, 상수 정의, 최적화 |

## 📊 Java `static` ↔ Kotlin 매핑표

| Java | Kotlin | 비고 |
| --- | --- | --- |
| `static field` (예: `static int counter`) | `companion object { var counter = 0 }` | 클래스 안에서 공유 멤버. 호출은 `ClassName.counter` |
| `static method` (예: `static void doSomething()`) | `companion object { fun doSomething() { ... } }` | 호출은 `ClassName.doSomething()` |
| `static final` (상수, 예: `static final double TAX = 0.1`) | `companion object { const val TAX = 0.1 }` | `const val`은 **컴파일 타임 상수** (Primitive, String만 가능). 호출은 `ClassName.TAX` |
| `static block` (클래스 초기화 블록) | `init { ... }` 또는 `companion object { init { ... } }` | Kotlin에는 별도 static block이 없고, `init` 블록이나 `companion object` 초기화 블록으로 대체 |
| `static inner class` | `object` 선언 또는 `companion object` | Kotlin은 기본적으로 inner class가 static 성격 → 필요 시 `object`나 `companion` 활용 |
| `static import` | `import packageName.CONSTANT` | Kotlin에서도 상수/함수는 top-level import 가능. companion object 멤버도 `@JvmField`나 `@JvmStatic`으로 import 최적화 가능 |
| `class with only static members` | `object SingletonName` | 싱글턴 패턴 대체. Kotlin `object`는 JVM에서 자동으로 static으로 컴파일됨 |
| `enum` | `enum class` 또는 `sealed interface + data object` | 단순 enum은 그대로 `enum class`, 상태/패턴용이면 `sealed + data object` |

## 6. Summary

In this chapter, we’ve learned that objects can be created
not only from classes but also using object expressions and 

object declarations. Both these kinds of objects have practical
usages. Object expression is used as an alternative to Java
anonymous objects, but it offers more. Object declaration is
Kotlin’s implementation of the singleton pattern. A special
form of object declaration, known as a companion object, is
used as an alternative to static elements but with additional
support for inheritance. We also have the const modifier,
which offers better support for constant elements defined at
the top level or in object declarations.
In the previous chapter, we discussed data classes, but there
are other modifiers we use for classes in Kotlin. In the next
chapter, we will learn about another important type of class:
exceptions.

1. **객체 생성 방법**
    - 객체는 단순히 `class`로만 만드는 게 아니라,
        
        **object expression**(익명 객체)과 **object declaration**(이름 있는 객체)으로도 만들 수 있다.
        
2. **Object expression**
    - Java의 **익명 클래스** 대체.
    - 하지만 더 강력해서 **멤버 정의, 상속, 인터페이스 구현**도 가능.
    - 주로 **리스너, 콜백** 등 임시 객체에 활용.
3. **Object declaration**
    - Kotlin의 **싱글턴 패턴 구현**.
    - 프로그램 전체에서 하나만 존재하는 객체를 제공.
    - 전역 유틸리티, 공유 리소스 등에 사용.
4. **Companion object**
    - object declaration의 특별한 형태.
    - Java의 `static` 대체 + **상속/인터페이스 구현 가능**.
    - 클래스 이름으로 바로 접근 가능 (`User.empty()`).
5. **Const modifier**
    - `const val`을 쓰면 **컴파일 타임 상수**로 최적화.
    - top-level 또는 companion object 안에서 주로 정의.
    - 애노테이션 메시지에도 사용 가능.

In Kotlin, we say that all classes inherit from the Any super-
class, which is at the top of the class hierarchy49. Methods

defined in Any can be called on all objects. These methods are:
• equals - used when two objects are compared using ==, `객체 비교 시 사용`
• hashCode - used by collections that use the hash table
algorithm, `해시 테이블을 사용하는 컬렉션에서 사용`
• toString - used to represent an object as a string, e.g., in
a string template or the print function. `객체를 문자열로 표현할 때 사용`
Thanks to these methods, we can represent any object as a
string or check the equality of any two objects.

```kotlin
// Any formal definition
open class Any {
	open operator fun equals(other: Any?): Boolean
	open fun hashCode(): Int
	open fun toString(): String
}

class A // Implicitly inherits from Any

fun main() {
	val a = A()
	a.equals(a)
	a == a
	a.hashCode()
	a.toString()
	println(a)
}
```

Truth be told, Any is represented as a class, but
it should actually be considered the head of the 

type hierarchy, but with some special functions.
Consider the fact that Any is also the supertype of all
interfaces, even though interfaces cannot inherit
from classes.

So Any is an analog to Object in Java, JavaScript or C#.
There is no direct analog in C++.

The default implementations of equals, hashCode, and toString
are strongly based on the object’s address in memory. The

equals method returns true only when the address of both ob-
jects is the same,whichmeans the same object is on both sides.

The hashCode method typically transforms an address into a
number. toString produces a string that starts with the class
name, then the at sign “@”, then the unsigned hexadecimal
representation of the hash code of the object.

```kotlin
class A

fun main() {
	val a1 = A()
	val a2 = A()
	println(a1.equals(a1)) // true
	println(a1.equals(a2)) // false
	// or
	println(a1 == a1) // true
	println(a1 == a2) // false
	println(a1.hashCode()) // Example: 149928006
	println(a2.hashCode()) // Example: 713338599
	println(a1.toString()) // Example: A@8efb846
	println(a2.toString()) // Example: A@2a84aee7
	// or
	println(a1) // Example: A@8efb846
	println(a2) // Example: A@2a84aee7
}
```

- *`equals(a1, a2)`*는 두 객체를 비교하는 메서드로, 객체 **a1**과 **a2**의 주소가 다르면 `false`를 반환합니다.
- *`hashCode()`*는 객체의 주소를 **해시값**으로 변환하여 반환합니다.
- *`toString()`*은 객체를 문자열로 표현할 때 사용되며, 기본적으로 **클래스 이름 + "@" + 해시코드**를 반환합니다.

By overriding these methods, we can decide how a class
should behave. Consider the following class A, which is equal to other instances of the same class and returns a constant
hash code and string representation.

```kotlin
class A {
	override fun equals(other: Any?): Boolean = other is A
	override fun hashCode(): Int = 123
	override fun toString(): String = "A()"
}

fun main() {
	val a1 = A()
	val a2 = A()
	println(a1.equals(a1)) // true
	println(a1.equals(a2)) // true
	// or
	println(a1 == a1) // true
	println(a1 == a2) // true
	println(a1.hashCode()) // 123
	println(a2.hashCode()) // 123
	println(a1.toString()) // A()
	println(a2.toString()) // A()
	// or
	println(a1) // A()
	println(a2) // A()
}
```

- `class A`에서 **`equals()`, `hashCode()`, `toString()` 메서드를 오버라이드**할 수 있는 이유는 이 메서드들이 **`Any` 클래스에서 `open`으로 정의**되어 있기 때문입니다.
- *`Any` 클래스는 `open`*으로 정의되어 있어 **모든 클래스는 `Any`를 상속**받고, `Any`에서 제공하는 **메서드를 오버라이드**할 수 있습니다.
- **`class A`는 `open`이 아니어도 `Any` 클래스의 메서드는 오버라이드 가능**합니다.

따라서 **`Any`의 메서드는 `open`으로 정의되어 있어서 오버라이드 가능**하며, **`class A`에서 이를 오버라이드**할 수 있는 것입니다!

I’ve dedicated separate items in the Effective Kotlin book to
implementing a custom equals and hashCode50, but in practice
we rarely need to do that. As it turns out, in modern projects
we almost solely operate on only two kinds of objects:

- Active objects, like services, controllers, repositories,
etc. Such classes don’t need to override any methods
from Any because the default behavior is perfect for
them.
• Data model class objects, which represent bundles of
data. For such objects, we use the data modifier, which
overrides the toString, equals, and hashCode methods.
The data modifier also implements the methods copy
and componentN (component1, component2, etc.), which are
not inherited and cannot be modified.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

val player = Player(0, "Gecko", 9999)
```

### 🧩 데이터 클래스의 특징

1. **자동 오버라이딩**: `equals()`, `hashCode()`, `toString()` 메서드를 자동으로 구현합니다.
2. **`copy()` 메서드**: 객체의 복사를 쉽게 할 수 있게 해줍니다.
3. **`componentN()` 메서드**: 각 프로퍼티를 쉽게 접근할 수 있게 해줍니다.

Let’s discuss the aforementioned implicit data class methods
and the differences between regular class behavior and data
class behavior.

```kotlin
data class Player(
    val id: Int,
    val name: String,
    val points: Int
)

fun main() {
    val player1 = Player(1, "John", 100)
    val player2 = player1.copy(id = 2, name = "Alex") // 복사해서 새 객체 생성

    println(player1) // Player(id=1, name=John, points=100)
    println(player2) // Player(id=2, name=Alex, points=100)

    // componentN()을 사용하여 프로퍼티 접근
    val (id, name, points) = player2
    println("$name has $points points") // Alex has 100 points
}

```

- *`copy()`*는 객체를 복사하면서 일부 값을 변경할 수 있습니다.
- *`componentN()`*은 데이터 클래스의 각 프로퍼티에 접근하는 데 유용합니다.

## ✅ **`Any`와 `Data Class` 차이점 요약**

| 항목 | `Any` | `Data Class` |
| --- | --- | --- |
| **기본 메서드** | `equals()`, `hashCode()`, `toString()`을 **기본 제공**하며, **오버라이드 가능** | `equals()`, `hashCode()`, `toString()`을 **자동으로 오버라이드** |
| **주요 사용** | **모든 클래스의 최상위 클래스**, 모든 객체는 **`Any`**를 상속 | **데이터 모델을 위한 클래스** |
| **추가 메서드** | **없음** | `copy()`, `componentN()` 메서드를 자동으로 제공 |

## 1. Transforming to a string

The default toString transformation produces a string that
starts with the class name, then the at sign “@”, and then the
unsigned hexadecimal representation of the hash code of the
object. The purpose of this is to display the class name and to
determine whether two strings represent the same object or
not.

This type of class is so popular that in Java it is common

practice to auto-generate equals, hashCode, and toString in In-
telliJ or using the Lombok library.

```kotlin
class FakeUserRepository

fun main() {
	val repository1 = FakeUserRepository()
	val repository2 = FakeUserRepository()
	println(repository1) // e.g. FakeUserRepository@8efb846
	println(repository1) // e.g. FakeUserRepository@8efb846
	println(repository2) // e.g. FakeUserRepository@2a84aee7
}
```

이 메서드는 객체를 문자열로 표현할 때 사용되며, **같은 객체인지 다른 객체인지를 확인하는 데** 유용합니다.

With the data modifier, the compiler generates a toString
that displays the class name and then pairs with the name
and value for each primary constructor property. We assume
that data classes are represented by their primary constructor
properties, so all these properties, together with their values,
are displayed during a transformation to a string. This is
useful for logging and debugging.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	val player = Player(0, "Gecko", 9999)
	println(player)
	// Player(id=0, name=Gecko, points=9999)
	println("Player: $player")
	// Player: Player(id=0, name=Gecko, points=9999)
}
```

Kotlin에서는 **문자열 템플릿**이나 **`println()`** 함수가 **객체를 출력할 때** 객체의 **`toString()`** 메서드를 호출하여 객체를 **문자열로 변환**합니다.

- Kotlin에서 문자열 템플릿을 사용하면 **`$player`** 부분이 **`player.toString()`*으로 변환됩니다.
- 즉, **`player.toString()`*이 호출되어 `Player(id=0, name=Gecko, points=9999)`가 문자열에 삽입되고, `"Player: Player(id=0, name=Gecko, points=9999)"`라는 문자열이 출력됩니다.

![스크린샷 2025-08-12 오후 4.22.34.png](attachment:05ecb16b-947a-4a95-ad2b-0edd39981205:스크린샷_2025-08-12_오후_4.22.34.png)

## 2. Objects equality

In Kotlin, we check the equality of two objects using ==, which
uses the equals method from Any. So, this method decides if
two objects should be considered equal or not. By default,
two different instances are never equal. This is perfect for
active objects, i.e., objects that work independently of other
instances of the same class and possibly have a protected
mutable state.

```kotlin
class FakeUserRepository

fun main() {
	val repository1 = FakeUserRepository()
	val repository2 = FakeUserRepository()
	println(repository1 == repository1) // true
	println(repository1 == repository2) // false
}
```

Classes with the data modifier represent bundles of data; they
are considered equal to other instances if:
• both are of the same class,
• their primary constructor property values are equal.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)
fun main() {
	val player = Player(0, "Gecko", 9999)
	println(player == Player(0, "Gecko", 9999)) // true
	println(player == Player(0, "Ross", 9999)) // false
}
```

This is what a simplified implementation of the equals method
generated by the data modifier for the Player class looks like:

```kotlin
override fun equals(other: Any?): Boolean = other is Player &&
other.id == this.id &&
other.name == this.name &&
other.points == this.points
```

Implementing a custom equals is described in Effec-
tive Kotlin, Item 42: Respect the contract of equals.

## 3. Hash code

Another method from Any is hashCode, which is used to trans-
form an object into an Int. With a hashCode method, the object

instance can be stored in the hash table data structure imple-
mentations that are part of many popular classes, including

HashSet and HashMap. The most important rule of the hashCode
implementation is that it should:
• be consistent with equals, so it should return the same
Int for equal objects, and it must always return the same
hash code for the same object.
• spread objects as uniformly as possible in the range of all
possible Int values.
The default hashCode is based on an object’s address inmemory.
The hashCode generated by the data modifier is based on the
hash codes of this object’s primary constructor properties. In
both cases, the same number is returned for equal objects.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
	println(Player(0, "Gecko", 9999).hashCode()) // 2129010918
	println(Player(0, "Ross", 9999).hashCode()) // 79159602
}
```

To learn more about the hash table algorithm and implement-
ing a custom hashCode method, see Effective Kotlin, Item 41:

Respect the contract of hashCode.

### 자동 생성된 `hashCode()` 메서드 예시

`data class`에서 자동으로 생성되는 **`hashCode()`** 메서드는 보통 다음과 같이 구현됩니다:

```kotlin

override fun hashCode(): Int {
    var result = id
    result = 31 * result + name.hashCode()
    result = 31 * result + points
    return result
}

```

- `hashCode()` 메서드는 **`id`, `name`, `points`*의 해시 코드 값을 사용하여 **객체의 고유한 해시 코드**를 계산합니다.

### **`hashCode()`와 `equals()`의 계약**

`hashCode()`와 **`equals()`**는 **계약을 따라야** 합니다. **`equals()`**가 `true`를 반환하는 객체는 **반드시 동일한 `hashCode()`**를 반환해야 합니다. 이 규칙을 지키지 않으면, 객체를 **`HashSet`**, **`HashMap`** 같은 자료 구조에서 제대로 사용할 수 없게 됩니다.

---

### **결론 및 요약**

- *`hashCode()`*는 **객체를 `Int`로 변환**하는 메서드로, **해시 테이블** 자료 구조에서 객체를 효율적으로 관리하는 데 사용됩니다.
- *`data class`*는 **주 생성자 프로퍼티**를 기반으로 **자동으로 `hashCode()`** 메서드를 생성하며, 객체 비교 및 해시 값을 계산할 때 유용하게 사용됩니다.
- *`equals()`*와 **`hashCode()`*는 **동일한 객체**를 판단할 때 일관되게 동작해야 합니다.

---

### ✅ 한 줄 요약

> **hashCode()**는 객체를 Int 값으로 변환하는 메서드로, **data class**에서 주 생성자의 프로퍼티를 기반으로 자동으로 생성되며, **equals()**와 함께 일관된 객체 비교를 제공합니다.
> 

## 4. Copying objects

Another method generated by the data modifier is copy, which
is used to create a new instance of a class but with a concrete
modification. The idea is very simple: it is a function with
parameters for each primary constructor property, but each
of these parameters has a default value, i.e., the current value
of the associated property.

```kotlin
// This is how copy generated by data modifier
// for Person class looks like under the hood
fun copy(
	id: Int = this.id,
	name: String = this.name,
	points: Int = this.points
) = Player(id, name, points)
```

This means we can call copy with no parameters to make a
copy of our object with no modifications, but we can also
specify new values for the properties we want to change.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)
fun main() {
	val p = Player(0, "Gecko", 9999)
	println(p.copy()) // Player(id=0, name=Gecko, points=9999)
	println(p.copy(id = 1, name = "New name"))
	// Player(id=1, name=New name, points=9999)
	println(p.copy(points = p.points + 1))
	// Player(id=0, name=Gecko, points=10000)
}
```

Note that copy creates a shallow copy of an object; so, if our
object holds a mutable state, a change in one object will be a
change in all its copies too.

```kotlin
data class StudentGrades(
	val studentId: String,
	// Code smell: Avoid using mutable objects in data classes
	val grades: MutableList<Int>
)

fun main() {
	val grades1 = StudentGrades("1", mutableListOf()) // grades1 생성
	val grades2 = grades1.copy(studentId = "2") // grades1을 복사하여 grades2 생성

	println(grades1) // Grades(studentId=1, grades=[])
	println(grades2) // Grades(studentId=2, grades=[])
	grades1.grades.add(5)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[5])
	// grades1.grades.add(5)를 실행하면 grades1의 **grades** 리스트에 5가 추가됩니다. 
	// 하지만 grades1과 grades2는 동일한 **MutableList** 객체를 참조하고 있으므로, grades2의 **grades**에도 5가 추가됩니다.
	grades2.grades.add(1)
	println(grades1) // Grades(studentId=1, grades=[5, 1])
	println(grades2) // Grades(studentId=2, grades=[5, 1])
	// grades2.grades.add(1)을 호출하면, 
	// grades2의 grades 리스트에 1이 추가됩니다. 
	// 같은 리스트 객체를 참조하고 있기 때문에, grades1의 **grades**에도 1이 추가됩니다.
}
```

`copy()` 메서드는 **얕은 복사**(shallow copy)를 수행합니다. 즉, **객체가 참조하는 가변 객체는 복사되지 않고, 참조만 복사**됩니다. 따라서 **가변 상태**를 가진 객체는 **복사본에서도 동일한 상태를 가질 수 있습니다**.

**`grades`**는 가변 객체(MutableList)이기 때문에, **`grades1`**에서 변경된 사항이 **`grades2`**에도 영향을 미칩니다.

이로 인해 **`grades1`**과 **`grades2`**는 **`grades`** 리스트의 **같은 참조를 공유**하게 됩니다. 이때 `grades1`의 **`grades`**는 **빈 `MutableList`**입니다.

### **`copy()`와 얕은 복사**

- *`copy()`*는 **얕은 복사**를 수행하기 때문에, 내부의 **가변 객체**(예: `MutableList`)는 복사되지 않고 **참조만 복사**됩니다. 이로 인해 **한 객체에서 가변 상태를 변경하면 다른 객체에도 영향을 미칠 수 있습니다**.

Kotlin에서 **얕은 복사**는 **`copy()`** 메서드를 통해 자동으로 이루어지며, **깊은 복사**는 필요에 따라 **수동으로 구현**해야 합니다.

We do not have this problem when we use copy for immutable

classes, i.e., classes with only val properties that hold im-
mutable values. copy was introduced as special support for

immutability (for details, see Effective Kotlin, Item 1: Limit
mutability).

```kotlin
data class StudentGrades(
	val studentId: String,
	val grades: List<Int>  // 불변 리스트 사용
)

fun main() {
	var grades1 = StudentGrades("1", listOf())
	var grades2 = grades1.copy(studentId = "2")
	println(grades1) // Grades(studentId=1, grades=[])
	println(grades2) // Grades(studentId=2, grades=[])
	grades1 = grades1.copy(grades = grades1.grades + 5)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[])
	grades2 = grades2.copy(grades = grades2.grades + 1)
	println(grades1) // Grades(studentId=1, grades=[5])
	println(grades2) // Grades(studentId=2, grades=[1])
}
```

Notice that data classes are unsuitable for objects that must
maintain invariant constraints on mutable properties. For
example, in the User example below, the class would not be
able to guarantee that the name and surname values are not
blank if these variables were mutable (so, defined with var).
Data classes are perfectly fit for immutable properties, whose
constraints might be checked during the creation of these
objects. In the example below, we can be sure that the name and
surname values are not blank in an instance of User.

```kotlin
data class User(
	val name: String,
	val surname: String,
) {
	init {
		require(name.isNotBlank())
		// throws exception if name is blank
		require(surname.isNotBlank())
		// throws exception if surname is blank
	}
}
```

### 1. **`data class`가 변경 불가능한 값을 다룰 때 유용한 이유**

`data class`는 기본적으로 **불변성(immutability)**을 염두에 두고 설계되었습니다. `data class`는 다음과 같은 특징을 가집니다:

- **`val` 프로퍼티**: `data class`의 주 생성자는 **기본적으로 `val` 프로퍼티**를 사용합니다. 이 프로퍼티는 **읽기 전용**이며, 한 번 초기화된 값은 변경할 수 없습니다. 따라서 `data class`는 **불변 객체**로 작업할 때 유용합니다.
- **자동 생성된 메서드**: `data class`는 **`equals()``, **`hashCode()`*, **`toString()`** 등의 메서드를 **자동으로 생성**합니다. 이 메서드들은 객체가 변경되지 않는 경우 (불변성) 완벽하게 동작하여, 비교 및 문자열 변환을 쉽게 처리할 수 있습니다.
- **`copy()` 메서드**: `data class`는 **`copy()`** 메서드를 자동으로 생성하여, 객체의 **복사본을 만들되 일부 속성만 변경**할 수 있습니다. 이는 불변 객체에서 상태를 변경하지 않고도 새로운 값을 만들어낼 수 있는 방법을 제공합니다.

따라서 **`data class`는 불변 데이터를 다룰 때 매우 유용**하며, **상태 변경을 최소화**하면서 **객체를 다루기 용이**하게 만듭니다.

### 예시: 불변 데이터를 다룰 때 유용한 `data class`

```kotlin
kotlin
복사
data class Player(
    val id: Int,
    val name: String,
    val points: Int
)

fun main() {
    val player = Player(1, "Gecko", 9999)
    println(player)  // Player(id=1, name=Gecko, points=9999)

    // copy()로 새로운 객체 생성
    val newPlayer = player.copy(name = "Alex")
    println(newPlayer)  // Player(id=1, name=Alex, points=9999)
}

```

위와 같은 예시에서 `Player`는 **불변 객체**이며, **`copy()`** 메서드를 사용하여 **새로운 객체를 만들되, 기존 객체는 변경하지** 않습니다. 이처럼 `data class`는 **변경 불가능한 데이터**를 안전하게 다룰 수 있습니다.

---

### 2. **가변 객체가 필요한 경우, `init` 블록 사용**

맞습니다! `data class` 내에서 **가변 객체**를 포함할 필요가 있을 경우, **`init` 블록**을 사용하여 객체 생성 시 특정 검증이나 초기화 작업을 할 수 있습니다. `data class`는 **`val`**로 불변 프로퍼티를 많이 사용하지만, 만약 **가변 객체**(예: `MutableList`, `MutableMap`)를 사용해야 한다면 **`init` 블록**에서 이를 처리할 수 있습니다.

### 예시: `init` 블록을 사용하는 경우

```kotlin
kotlin
복사
data class StudentGrades(
    val studentId: String,
    val grades: MutableList<Int> = mutableListOf()  // 가변 객체
) {
    init {
        // grades가 비어있으면 기본 값을 추가
        if (grades.isEmpty()) {
            grades.add(0)
        }
    }
}

fun main() {
    val student = StudentGrades("1")
    println(student)  // StudentGrades(studentId=1, grades=[0])

    student.grades.add(5)
    println(student)  // StudentGrades(studentId=1, grades=[0, 5])
}

```

### 정리

- **`data class`는 기본적으로 불변 데이터를 다룰 때 유용**합니다. **`val` 프로퍼티**와 **자동 생성된 메서드** 덕분에 **불변성**을 유지할 수 있습니다.
- **가변 객체가 필요한 경우**, **`init` 블록**을 사용하여 객체 생성 시 초기화를 처리할 수 있으며, 이를 통해 **불변성**을 지키면서 필요한 값을 추가하거나 검증할 수 있습니다.

## 5. Destructuring

Kotlin supports a feature called position-based destructuring,
which lets us assign multiple variables to components of a
single object. For that, we place our variable names in round
brackets.

```kotlin
data class Player(
	val id: Int,
	val name: String,
	val points: Int
)

fun main() {
	val player = Player(0, "Gecko", 9999)
	val (id, name, pts) = player
	println(id) // 0
	println(name) // Gecko
	println(pts) // 9999
}
```

- 이때, **구조 분해는 변수의 순서**에 맞춰 값을 할당합니다.
- *`data class`*에서는 **`componentN`** 메서드를 자동으로 생성하여 각 **속성 값을** **순서대로 반환**합니다.

This mechanism relies on position, not names. The object
on the right side of the equality sign needs to provide the
functions component1, component2, etc., and the variables are
assigned to the results of these methods.

```kotlin
val (id, name, pts) = player
// is compiled to
val id: Int = player.component1()
val name: String = player.component2()
val pts: Int = player.component3()
```

**`component1()`**, **`component2()`**, **`component3()`** 메서드는 **`data class`**의 **주 생성자**에 정의된 **각 프로퍼티**를 반환합니다. 이 메서드들은 **순서대로** 생성되며, `component1`은 첫 번째 프로퍼티인 **`id`**를 반환하고, `component2`는 **`name`**을 반환하며, `component3`는 **`points`**를 반환합니다.

### **`data class`와 `componentN` 메서드**

Kotlin에서 **`data class`**는 **주 생성자의 프로퍼티**를 기반으로 **자동으로 `componentN()` 메서드를 생성**합니다. 이 메서드는 각 프로퍼티에 대응하는 값을 반환하며, **구조 분해**를 가능하게 합니다.

### **`data class`와 함께 사용하는 이유**

`data class`는 기본적으로 **`toString()`**, **`equals()`**, **`hashCode()`**, **`copy()`**, 그리고 **`componentN()`** 메서드를 **자동으로 생성**합니다. **구조 분해**는 그 중 하나로, 객체를 **여러 변수에 나누어 할당할 수 있는 기능**입니다.

따라서, **구조 분해가 필요한 경우**에는 **`data class`**를 사용하면 **자동으로 필요한 메서드들이 생성**되어 편리합니다.

### **정리**

- *`data class`*는 **구조 분해**를 사용할 수 있도록 **`componentN()` 메서드**를 자동으로 생성합니다.
- 구조 분해는 **`==` 연산자**로 **객체 비교**할 때처럼 객체의 **프로퍼티 순서대로 값**을 추출해 **여러 변수에 할당**할 수 있게 해줍니다.
- *`data class`*는 **불변 데이터**를 처리할 때 **편리하게 사용할 수 있으며**, **구조 분해** 외에도 **자동 생성되는 메서드들**을 활용하여 코드의 효율성을 높입니다.

This code works because the data modifier generates
componentN functions for each primary constructor parameter,
according to their order in the constructor.

These are currently all the functionalities that the data mod-
ifier provides. Don’t use it if you don’t need toString, equals, 

hashCode, copy or destructuring. If you need some of these func-
tionalities for a class representing a bundle of data, use the

data modifier instead of implementing the methods yourself.

## 6. When and how should we use destructuring?

Position-based destructuring has pros and cons. Its biggest
advantage is that we can name variables however we want,
so we can use names like country and city in the example
below. We can also destructure anything we want as long
as it provides componentN functions. This includes List and
Map.Entry, both of which have componentN functions defined as
extensions:

```kotlin
fun main() {
	val visited = listOf("Spain", "Morocco", "India")
	val (first, second, third) = visited
	println("$first $second $third")
	// Spain Morocco India
	val trip = mapOf(
	"Spain" to "Gran Canaria",
	"Morocco" to "Taghazout",
	"India" to "Rishikesh"
)

for ((country, city) in trip) {
	println("We loved $city in $country")
	// We loved Gran Canaria in Spain
	// We loved Taghazout in Morocco
	// We loved Rishikesh in India
	}
}
```

### 장점:

- **변수 이름을 자유롭게 지정**할 수 있어 직관적인 변수 이름을 사용할 수 있습니다.
- **`componentN()` 함수**만 있으면 **어떤 객체든 분해할 수 있습니다**. 예를 들어, `List`나 `Map.Entry`도 **`componentN()` 함수**가 확장 함수로 제공되기 때문에, 이를 이용하여 구조 분해가 가능합니다.

On the other hand, position-based destructuring is danger-
ous. We need to adjust every destructuring when the order

or number of elements in a data class changes. When we use
this feature, it is very easy to introduce errors into our code by
changing the order of the primary constructor’s properties.

```kotlin
data class FullName(
	val firstName: String,
	val secondName: String,
	val lastName: String
)

val elon = FullName("Elon", "Reeve", "Musk")
val (name, surname) = elon
print("It is $name $surname!") // It is Elon Reeve!
```

위와 같은 경우에는 **`firstName`**과 **`secondName`**에 할당되고, **`lastName`**은 할당되지 않으므로, 할당되지 않은 값은 **사용할 수 없게 되므로** 주의가 필요.

We need to be careful with destructuring. It is useful to use
the same names as data class primary constructor properties.
In the case of an incorrect order, an IntelliJ/Android Studio
warningwill be shown. Itmight even be useful to upgrade this
warning to an error.

![스크린샷 2025-08-12 오후 9.27.41.png](attachment:b41ceb91-d08c-42ac-a230-5fce227a9087:스크린샷_2025-08-12_오후_9.27.41.png)

Destructuring a single value in lambda is very confusing,

especially since parentheses around arguments in lambda ex-
pressions are either optional or required in some languages.

```kotlin
data class User(
	val name: String,
	val surname: String,
)

fun main() {
	val users = listOf(
	User("Nicola", "Corti")
	)
	users.forEach { u -> println(u) }
	// User(name=Nicola, surname=Corti)
	users.forEach { (u) -> println(u) }
	// Nicola
}
```

- 첫 번째 **`forEach`*에서는 `u`가 `User` 객체 전체를 참조하고 출력됩니다. **출력**: `User(name=Nicola, surname=Corti)`
- 두 번째 **`forEach`*에서는 **구조 분해**를 사용하여 **`User` 객체의 `name`과 `surname`을** **분해**하여 `name`만 출력합니다. **출력**: `Nicola`

이 예시에서 `u`를 **괄호로 감싸는** 것은 **람다식에서 구조 분해**를 사용하는 방법입니다. **`(u)`**는 **`User` 객체의 `name` 속성**만을 참조하게 됩니다.

**구조 분해**에서 **괄호 안에 `u`** 하나만 있는 경우, **`User` 객체의 첫 번째 속성만** 분리하여 변수 `u`에 할당됩니다.

- 즉, **`name`만 `u`에 할당**되며, **`surname`은 할당되지 않습니다**.

```kotlin
users.forEach { (name, surname) -> println(name) }  // name만 출력
users.forEach { (_, surname) -> println(surname) }  // surname만 출력

```

## 7. Data class limitations

The idea behind data classes is that they represent a bundle
of data; their constructors allow us to specify all this data,
and we can access it through destructuring or by copying
them to another instance with the copy method. This is why
only primary constructor properties are considered by the
methods defined in data classes.

```kotlin
data class Dog(
	val name: String,
) {
	// Bad practice, avoid mutable properties in data classes
	var trained = false
}

fun main() {
	val d1 = Dog("Cookie")
	d1.trained = true
	println(d1) // Dog(name=Cookie)
	// so nothing about trained property
	val d2 = d1.copy()
	println(d1.trained) // true
	println(d2.trained) // false
	// so trained value not copied
}
```

- **주 생성자 속성**(예: `name`)은 **`data class` 메서드에서 고려**되지만, **클래스 본문 속성**(예: `trained`)은 **복사되지 않으며 `toString()`에도 포함되지 않습니다**.
- *`trained`*는 **`copy()`** 메서드 호출 시 복사되지 않기 때문에, `d1`과 `d2`는 **`trained` 값**이 다르게 출력됩니다.
- **데이터 클래스에서는 주 생성자의 속성만 중요한 의미를 갖고, 그 외의 속성은 무시됩니다**.

Data classes are supposed to keep all the essential properties
in their primary constructor. Inside the body, we should only

keep redundant immutable properties, which means proper-
ties whose value is distinctly calculated from primary con-
structor properties, like fullName, which is calculated from

name and surname. Such values are also ignored by data class 

methods, but their value will always be correct because it will
be calculated when a new object is created.

```kotlin
data class FullName(
	val name: String,
	val surname: String,
) {
	val fullName = "$name $surname"
}

fun main() {
	val d1 = FullName("Cookie", "Moskała")
	println(d1.fullName) // Cookie Moskała
	println(d1) // FullName(name=Cookie, surname=Moskała)
	val d2 = d1.copy()
	println(d2.fullName) // Cookie Moskała
	println(d2) // FullName(name=Cookie, surname=Moskała)
}
```

**주 생성자**에 속하지 않는 속성은 **복사(copy)**와 같은 **`data class` 메서드**에서 무시됩니다. 이와 같은 속성은 **불변(immutable)**이어야 하며, **주 생성자 속성**으로 계산된 값만 포함해야 합니다.

- *`fullName`*은 **주 생성자 속성**인 **`name`*과 **`surname`*을 **기반으로 계산된 불변 값**입니다.
- 데이터 클래스 메서드는 **주 생성자 속성만**을 고려하지만, **`fullName`** 속성은 **복사(copy)** 시에도 **올바르게 계산**됩니다.

**데이터 클래스는 `final`이어야 하므로 상속 불가**

You should also remember that data classes must be final and
so cannot be used as a super-type for inheritance.

### **본문 속성을 정의해야 할 경우:**

**본문 속성**을 사용하는 경우는 주로 **계산된 값**을 저장하거나, **불변 데이터를 기반으로 한 추가적인 계산**이 필요한 경우입니다. 예를 들어, **`fullName`**과 같이 **주 생성자 속성을 기반으로 한 계산된 값**을 저장하고자 할 때 사용됩니다.

### 예시 1: 계산된 값을 저장하기

```kotlin
kotlin
복사
data class Person(
    val firstName: String,
    val lastName: String
) {
    // 계산된 속성
    val fullName = "$firstName $lastName"
}

fun main() {
    val person = Person("John", "Doe")
    println(person.fullName) // John Doe
    println(person) // Person(firstName=John, lastName=Doe)
}

```

이 예시에서 **`fullName`**은 **주 생성자 속성**인 **`firstName`**과 **`lastName`**을 기반으로 계산된 값입니다. 이와 같은 속성은 **불변**이며, **복사(copy)** 시 자동으로 **다시 계산**됩니다.

### 예시 2: 추가적인 비즈니스 로직을 저장하기

```kotlin
kotlin
복사
data class Rectangle(
    val width: Int,
    val height: Int
) {
    // 계산된 속성
    val area: Int = width * height
}

fun main() {
    val rect = Rectangle(10, 5)
    println(rect.area)  // 50
}

```

여기서 **`area`**는 **`width`**와 **`height`**를 기반으로 계산된 값입니다. **`area`**는 **주 생성자 속성**이 아니지만, 데이터 클래스로 **`toString()`**이나 **`copy()`**에서 제외됩니다. 그러나 **`area`**를 객체를 다룰 때 필요로 할 경우 **본문 속성으로 정의**할 수 있습니다.

---

### **본문 속성을 사용해야 하는 이유:**

1. **계산된 값**을 다룰 때: **주 생성자 속성**만으로 해결할 수 없는 계산된 속성을 다룰 때 본문 속성을 사용합니다. 예를 들어 **`fullName`**, **`area`*와 같이 **주 생성자 속성을 기반으로 계산되는 값**을 정의할 수 있습니다.
2. **불변 데이터 클래스**의 속성으로, 주 생성자 속성만으로는 다룰 수 없는 값을 저장하고 싶을 때 유용합니다.
3. **데이터 클래스의 특성상, 주 생성자 속성** 외의 **추가 속성**이 필요할 경우, 본문 속성으로 추가할 수 있습니다.

### **`data class`에서 본문 속성 사용의 한계:**

- **`toString()`, `copy()`, `equals()`** 메서드에서는 **본문 속성이 무시**됩니다. 즉, **본문 속성은 주 생성자 속성에 비해 관리가 어려울 수 있습니다**.
- **데이터 클래스의 목적은** **주 생성자 속성**에 대한 데이터 캡슐화이므로 **본문 속성은 보조적인 역할**만 하도록 사용하는 것이 좋습니다.

## 8. Prefer data classes instead of tuples

Data classes offer more than what is generally provided by
tuples. Historically, they replaced tuples in Kotlin since they
are considered better practice52. The only tuples that are left
are Pair and Triple, but these are data classes under the hood:

```kotlin
data class Pair<out A, out B>(
	val first: A,
	val second: B
) : Serializable {
	override fun toString(): String =
		"($first, $second)"
}

data class Triple<out A, out B, out C>(
	val first: A,
	val second: B,
	val third: C
) : Serializable {
	override fun toString(): String =
		"($first, $second, $third)"
}
```

Kotlin had support for tuples when it was still in the
beta version. We were able to define a tuple by brackets and
a set of types, like (Int, String, String, Long). What we
achieved behaved the same as data classes in the end, but it
was far less readable. Can you guess what type this set of types
represents? It can be anything. Using tuples is tempting, but
using data classes is nearly always better. This is why tuples
were removed, and only Pair and Triple are left.

The easiest way to create a Pair is by using the to function.
This is a generic infix extension function, defined as follows
(we will discuss both generic and extension functions in later
chapters).

```kotlin
infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```

Thanks to the infix modifier, a method can be used by placing
its name between arguments, as the infix name suggests. The
result Pair is typed, so the result type from the "ABC" to 123
expression is Pair<String, Int>.

```kotlin
fun main() {
	val p1: Pair<String, Int> = "ABC" to 123
	println(p1) // (ABC, 123)
	val p2 = 'A' to 3.14
	// the type of p2 is Pair<Char, Double>
	println(p2) // (A, 123)
	val p3 = true to false
	// the type of p3 is Pair<Boolean, Boolean>
	println(p3) // (true, false)
}
```

**`to`** 함수는 **두 값을 하나의 튜플로 묶어주는 역할**을 하며, **`Pair`** 또는 **`Triple`**과 같은 데이터 클래스 타입으로 묶어줍니다.

These tuples remain because they are very useful for local
purposes, like:

• When we immediately name values:

```kotlin
val (description, color) = when {
	degrees < 5 -> "cold" to Color.BLUE
	degrees < 23 -> "mild" to Color.YELLOW
	else -> "hot" to Color.RED
}
```

- To represent an aggregate that is not known in advance,
as is commonly the case in standard library functions:

```kotlin
val (odd, even) = numbers.partition { it % 2 == 1 }
val map = mapOf(1 to "San Francisco", 2 to "Amsterdam")
```

여기서 **`to`**는 **`Pair`**를 생성하고, 이 **`Pair`**는 **`Map.Entry`**와 유사하게 키와 값을 묶어서 저장합니다.

In other cases, we prefer data classes. Take a look at an exam-
ple: let’s say that we need a function that parses a full name

into a name and a surname. One might represent this name
and surname as a Pair<String, String>:

```kotlin
fun String.parseName(): Pair<String, String>? {
	val indexOfLastSpace = this.trim().lastIndexOf(' ')
	if (indexOfLastSpace < 0) return null
	val firstName = this.take(indexOfLastSpace)
	val lastName = this.drop(indexOfLastSpace)
	return Pair(firstName, lastName)
}
// Usage
fun main() {
	val fullName = "Marcin Moskała"
	val (firstName, lastName) = fullName.parseName() ?: return
}
```

이 예시에서 **`Pair`**는 **`firstName`**과 **`lastName`**을 나타내기 위해 사용됩니다. 하지만 **`Pair<String, String>`**을 사용하면 **순서가 혼동**될 수 있습니다. 예를 들어, **`lastName`**이 **`firstName`**보다 먼저 올 수 있다는 오해를 줄 수 있습니다.

The problem is that when someone reads this code, it is not
clear that Pair<String, String> represents a full name.What is
more, it is not clear what the order of the values is, therefore
someone might think that the surname goes first:

```kotlin
val fullName = "Marcin Moskała"
val (lastName, firstName) = fullName.parseName() ?: return
print("His name is $firstName") // His name is Moskała
```

To make usage safer and the function easier to read, we should
use a data class instead:

```kotlin
data class FullName(
	val firstName: String,
	val lastName: String
)

fun String.parseName(): FullName? {
	val indexOfLastSpace = this.trim().lastIndexOf(' ')
	if (indexOfLastSpace < 0) return null
	val firstName = this.take(indexOfLastSpace)
	val lastName = this.drop(indexOfLastSpace)
	return FullName(firstName, lastName)
}

// Usage
fun main() {
	val fullName = "Marcin Moskała"
	val (firstName, lastName) = fullName.parseName() ?: return
	print("His name is $firstName $lastName")
	// His name is Marcin Moskała
}
```

### **`data class`의 장점:**

- **명확한 반환 타입**: 함수가 무엇을 반환하는지 한 눈에 알 수 있습니다.
- **복잡한 타입의 숨은 의미 제거**: **`Pair`*처럼 튜플을 사용하면 **값의 의미**가 불분명하지만, **`data class`*를 사용하면 각 값의 의미가 명확해집니다.
- **정적 검사**: IntelliJ에서는 **구조 분해 시 이름이 바뀌면 경고**를 표시하여, 실수를 줄일 수 있습니다.

This costs nearly nothing and improves the function signifi-
cantly:

- The return type of this function is more clear.
• The return type is shorter and easier to pass forward.
• If a user destructures variables with correct names but
in incorrect positions, a warning will be displayed in
IntelliJ.
If you don’t want this class in a wider scope, you can restrict
its visibility. It can even be private if you only need to use it for
some local processing in a single file or class. It is worth using
data classes instead of tuples. Classes are cheap in Kotlin, so
don’t be afraid to use them in your projects.

## 9. Summary

In this chapter, we’ve learned about Any, which is a superclass
of all classes.We’ve also learned aboutmethods defined by Any:
equals, hashCode, and toString. We’ve also learned that there

are two primary types of objects. Regular objects are consid-
ered unique and do not expose their details. Data class objects,

which we made using the data modifier, represent bundles of
data (we keep them in primary constructor properties). They
are equal when they hold the same data. When transformed
to a string, they print all their data. They additionally support
destructuring and making a copy with the copy method. Two
generic data classes in Kotlin stdlib are Pair and Triple, but
(apart from certain cases) we prefer to use custom data classes 

instead of these. Also, for the sake of safety, when we destruc-
ture a data class, we prefer to match the variable names with

the parameter names.
Now, let’smove on to a topic dedicated to special Kotlin syntax
that lets us create objects without defining a class.

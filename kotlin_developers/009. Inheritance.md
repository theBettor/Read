Ancient philosophers observed that many classes of objects
share the same characteristics. For instance, all mammals
have hair or fur, are warm-blooded, and feed their young with
milk. In programming, we represent such relationships
using inheritance.
When a class inherits from another class, it has all its member
functions and properties. The class that inherits is known
as a subclass of the class it inherits from, which is called a
superclass. They are also known as child and parent.
In Kotlin, all classes are closed by default, which means we
cannot inherit from them. We need to open a class using the
open keyword to allow inheritance from it. To inherit from a
class, we place a colon after the primary constructor (or after
the class name if there is no primary constructor), and then
we invoke the superclass constructor. In the example below,
the class Dog inherits from the class Mammal. Since Mammal has no
constructor specified, we call it without arguments, so with
Mammal(). This way, Dog inherits all the properties andmethods
from Mammal.

```kotlin
open class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false

	fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		}
	}
}

class Dog : Mammal() {
	fun makeVoice() {
		println("Bark bark")
	}
}

fun main() {
	val dog = Dog()
	dog.makeVoice() // Bark bark
	println(dog.haveHairOrFur) // true
	println(dog.warmBlooded) // true
	// Dog is Mammal, so we can up-cast it
	val mammal: Mammal = dog
	mammal.canFeed = true
	mammal.feedYoung() // Feeding young with milk
}
```

Conceptually, we treat subclasses as if they are their super-
classes: so, if Dog inherits from Mammal, we say that Dog is a

Mammal. Likewise, wherever Mammal is expected, we can use an
instance of Dog. Taking this into account, inheritance should
only be used if a real â€œis aâ€ relationship between two classes
exists.

- ìƒì† : ìì‹ í´ë˜ìŠ¤ê°€ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì†ì„±ì´ë‚˜ ë©”ì„œë“œë¥¼ ë¬¼ë ¤ë°›ëŠ” ê²ƒ.
- open : Kotlinì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í´ë˜ìŠ¤ê°€ finalë¡œ ì„ ì–¸ë˜ì–´ ìˆì–´, ìƒì†ì„ í—ˆìš©í•˜ë ¤ë©´ open í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ì•¼í•œë‹¤.
- ì—…ìºìŠ¤íŒ… : ìì‹ í´ë˜ìŠ¤ì˜ ê°ì²´ë¥¼ ë¶€ëª¨ í´ë˜ìŠ¤ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •, Dog ê°ì²´ë¥¼ Mammal íƒ€ì…ì˜ ë³€ìˆ˜ì— í• ë‹¹í•˜ëŠ” ê²ƒ.
    
     
    
    ```kotlin
    val dog = Dog()  // Dog í´ë˜ìŠ¤ì˜ ê°ì²´ ìƒì„±
    val mammal: Mammal = dog  // Dog ê°ì²´ë¥¼ Mammal íƒ€ì…ìœ¼ë¡œ ì—…ìºìŠ¤íŒ…
    ```
    
    mammal ë³€ìˆ˜ëŠ” Mammal íƒ€ì…ì¸ë°, ì‹¤ì œë¡œëŠ” Dog ê°ì²´ë¥¼ ì°¸ì¡°(= Dog í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¸ì¡°)í•˜ê³  ìˆë‹¤.
    
- ì—…ìºìŠ¤íŒ…ì´ í•„ìš”í•œ ì´ìœ 
    - ë‹¤í˜•ì„±: ì—¬ëŸ¬ ìì‹ í´ë˜ìŠ¤ë¥¼ ê³µí†µëœ ë¶€ëª¨ íƒ€ì…ìœ¼ë¡œ ì²˜ë¦¬
    - ìƒì†ë°›ì€ ê¸°ëŠ¥ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ì œí•œ:
        - `Dog` í´ë˜ìŠ¤ëŠ” `Mammal`ì˜ ì†ì„±ê³¼ ë©”ì„œë“œë¥¼ ìƒì†ë°›ê³  ìˆì§€ë§Œ, `Dog`ë§Œì˜ ê¸°ëŠ¥ì¸ `makeVoice()`ëŠ” `Mammal` íƒ€ì…ì—ì„œëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
        - `Dog` ê°ì²´ë¥¼ `Mammal` íƒ€ì…ìœ¼ë¡œ ì—…ìºìŠ¤íŒ…í•˜ë©´ **`Mammal`ì˜ ì†ì„±**ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ì œí•œë©ë‹ˆë‹¤.(`mammal`ë¡œ ë‹¤ë£¨ëŠ” ë™ì•ˆ, `Dog`ì— íŠ¹í™”ëœ `makeVoice()` ë©”ì„œë“œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ì§€ë§Œ, `Mammal`ì— ì •ì˜ëœ **`canFeed`**ì™€ **`feedYoung()`**ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)

## 1. Overriding elements

By default, subclasses cannot override elements defined in
superclasses. To make this possible, these elements need to
allow it with the open modifier, because in Kotlin all elements
are closed by default. Then, subclasses can override their
parentsâ€™ implementation, which looks just like defining the
same function in children but with the override modifier (this
modifier is required in Kotlin).

```kotlin
open class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false

	open fun feedYoung() {
		if (canFeed) {
		println("Feeding young with milk")
		}
	}
}

class Cat : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		} else {
			println("Feeding young with milk from bottle")
		}
	}
}

fun main() {
	val dog = Mammal()
	dog.feedYoung() // Nothing printed
	val cat = Cat()
	cat.feedYoung() // Feeding young with milk from bottle
	cat.canFeed = true
	cat.feedYoung() // Feeding young with milk
}
```

> **`open` í‚¤ì›Œë“œ**ë¡œ ë¶€ëª¨ í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ **ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ìˆê²Œ ì—´ì–´ë‘ê³ **, **`override` í‚¤ì›Œë“œ**ë¡œ ìì‹ í´ë˜ìŠ¤ì—ì„œ ë¶€ëª¨ì˜ ë©”ì„œë“œë¥¼ **ìƒˆë¡œìš´ ë™ì‘ìœ¼ë¡œ ë®ì–´ì“¸ ìˆ˜** ìˆìŠµë‹ˆë‹¤.
> 

## 2. Parents with non-empty constructors

So far, we have inherited only from classes with empty con-
structors; so, when we were specifying the superclass, we

used empty parentheses. However, if the superclass has con-
structor parameters, we need to define some arguments in-
side these parentheses.

```kotlin
open class Animal(val name: String)

class Dodo : Animal("Dodo")
```

- **`Animal` í´ë˜ìŠ¤**ëŠ” `name`ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” ìƒì„±ìë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
- **`Dodo` í´ë˜ìŠ¤**ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ `Animal`ì„ ìƒì†í•˜ê³ , `Animal("Dodo")`ì™€ ê°™ì´ ë¶€ëª¨ì˜ ìƒì„±ìì— `"Dodo"`ë¥¼ ì „ë‹¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.
    - `Dodo` ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ìƒì„±ìì— ê°’ì„ ì „ë‹¬í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

We can use primary constructor properties as superclass con-
structor arguments or to construct these arguments.

```kotlin
open class Animal(val name: String)

class Dog(name: String) : Animal(name)

class Cat(name: String) : Animal("Mr $name")

class Human(
	firstName: String,
	lastName: String,
) : Animal("$firstName $lastName")

fun main() {
	val dog = Dog("Cookie")
	println(dog.name) // Cookie
	val cat = Cat("MiauMiau")
	println(cat.name) // Mr MiauMiau
}
```

- `Dog("Cookie")`ëŠ” `name`ì„ `"Cookie"`ë¡œ ì „ë‹¬í•˜ì—¬ `Animal("Cookie")`ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
- `Cat("MiauMiau")`ëŠ” `"Mr "`ì„ ë§ë¶™ì—¬ì„œ `Animal("Mr MiauMiau")`ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
- ìì‹ í´ë˜ìŠ¤ì—ì„œ ë¶€ëª¨ ìƒì„±ìì— ì¸ìë¥¼ ì „ë‹¬í•˜ë ¤ë©´ **`super()`**ë¥¼ ì‚¬ìš© (Kotlinì—ì„œëŠ” ì£¼ë¡œ ë¶€ëª¨ ìƒì„±ìê°€ ìë™ìœ¼ë¡œ í˜¸ì¶œ)

## 3. Super call

When a class extends another class, it takes the behavior from
the superclass but also adds some behavior that is specific to

the subclass. This is why overriding methods often need to in-
clude the behavior of the methods they override. For this, it is

useful to call the superclass implementation in these subclass
methods. We do this using the super keyword, followed by a
dot, and then we call the method we want to override.
Consider the classes Dog and BorderCollie that are presented in
the example below. The default behavior for a dog is to wave
its tail when it sees a dog friend. Border Collies should behave 

the same but additionally lie down. In this case, to call the
superclass implementation, we need to use super.seeFriend().

```kotlin
open class Dog {
	open fun seeFriend() {
		println("Wave its tail")
	}
}

class BorderCollie : Dog() {
	override fun seeFriend() {
		println("Lie down")
		super.seeFriend()
	}
}

fun main() {
	val dog = Dog()
	dog.seeFriend() // Wave its tail
	val borderCollie = BorderCollie()
	borderCollie.seeFriend()
	// Lie down
	// Wave its tail
}
```

> "ìì‹ í´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œí•œ í•¨ìˆ˜ ë‚´ì—ì„œ, `super`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì˜¤ë²„ë¼ì´ë“œ ì „ ë©”ì„œë“œë„ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤."
> 

> **`super`ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°**ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ì˜ **ë©”ì„œë“œë¥¼ í˜¸ì¶œ**í•˜ê±°ë‚˜ **ìƒì„±ìì— ì¸ìë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬**í•  ë•Œì…ë‹ˆë‹¤.
> 

## 4. Abstract class

A mammal is a group of animals, not a concrete species. It
defines a set of characteristics but might not exist in itself.
To define a class that can only be used as a superclass of
other classes but cannot produce an object,we use the abstract
keyword before its class definition. You can interpret the open
modifier as â€œone can inherit from this classâ€,whereas abstract
means â€œone must inherit from this class to use itâ€.

### ğŸ“˜ ì¶”ìƒ í´ë˜ìŠ¤ ê°œë…

- **ì¶”ìƒ í´ë˜ìŠ¤**ëŠ” **êµ¬ì²´ì ì¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ê³ **, **ìƒì†ì„ í†µí•´ì„œë§Œ ì‚¬ìš©**ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì¶”ìƒ í´ë˜ìŠ¤ëŠ” **`abstract` í‚¤ì›Œë“œ**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜í•©ë‹ˆë‹¤.
- **ì¶”ìƒ ë©”ì„œë“œ**ëŠ” ëª¸ì²´ê°€ ì—†ìœ¼ë©°, **ìì‹ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ ì˜¤ë²„ë¼ì´ë“œ**í•´ì•¼ í•©ë‹ˆë‹¤.
- **ë¹„ì¶”ìƒ ë©”ì„œë“œ**ëŠ” ê¸°ë³¸ì ì¸ ë™ì‘ì„ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°, ìì‹ í´ë˜ìŠ¤ì—ì„œ **ì¬ì‚¬ìš©**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
abstract class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false
		fun feedYoung() {
			if (canFeed) {
			println("Feeding young with milk")
		}
	}
}
```

Abstract classes are open, so there is no need to use the open
modifier when a class has the abstract modifier already.
When a class is abstract, it can have abstract functions and

properties. Such functions do not have a body, and each sub-
class needs to override them. Thanks to that,whenwe have an

object whose type is an abstract class, we can call its abstract
functions because whatever the actual class of this object is, it
still needs to define these functions.

```kotlin
abstract class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false
	abstract fun feedYoung()
	
	// ìœ„ 3ê°œì˜ ì¼ë°˜ í”„ë¡œí¼í‹°ëŠ” ìì‹í´ë˜ìŠ¤ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
}
class Dog : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		}
	}
}

class Human : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		} else {
			println("Feeding young with milk from bottle")
		}
	}
}

fun feedYoung(mammal: Mammal) {
	// We can do that, because feedYoung is an abstract
	// function in Mammal
	mammal.feedYoung()
}

fun main() {
	val dog = Dog()
	dog.canFeed = true
	feedYoung(dog) // Feeding young with milk
	feedYoung(Human()) // Feeding young with milk from bottle
}
```

> `feedYoung(mammal: Mammal)` ë©”ì„œë“œë¥¼ ë§Œë“  ì´ìœ ëŠ” `feedYoung()` ë©”ì„œë“œê°€ ì¶”ìƒ ë©”ì„œë“œë¡œ ë¶€ëª¨ í´ë˜ìŠ¤ì—ì„œ ì •ì˜ë˜ì–´ ìˆê¸° ë•Œë¬¸ì´ë©°, `Mammal` íƒ€ì…ì˜ ê°ì²´ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒìœ¼ë¡œì¨ `Dog`, `Human`ì™€ ê°™ì€ ìì‹ í´ë˜ìŠ¤ ê°ì²´ë“¤ì„ í•˜ë‚˜ì˜ ë¶€ëª¨ íƒ€ì…ìœ¼ë¡œ ë‹¤ë£° ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.
> 

An abstract class can also have non-abstract methods, which
have a body. Such methods can be used by other methods.
Therefore, abstract classes can be used as templates with
partial implementation for other classes. Consider the
CoffeeMachine abstract class below, which specifies how latte
or doppio can be prepared, but it needs a subclass to override
the prepareEspresso and addMilk methods. This class provides
implementation for only some methods, so it is a partial
implementation.

```kotlin
abstract class CoffeeMachine {
	abstract fun prepareEspresso()
	abstract fun addMilk()
	fun prepareLatte() {
		prepareEspresso()
		addMilk()
	}
	
	fun prepareDoppio() {
		prepareEspresso()
		prepareEspresso()
	}
}
```

- **`CoffeeMachine`** í´ë˜ìŠ¤ëŠ” **ë¶€ë¶„ì ìœ¼ë¡œ êµ¬í˜„**ëœ ì¶”ìƒ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
    - **ì¶”ìƒ ë©”ì„œë“œ**: `prepareEspresso()`, `addMilk()`ëŠ” ìì‹ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
    - **ë¹„ì¶”ìƒ ë©”ì„œë“œ**: `prepareLatte()`, `prepareDoppio()`ëŠ” ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•˜ë©°, ìì‹ í´ë˜ìŠ¤ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ìì‹ í´ë˜ìŠ¤ëŠ” **`prepareEspresso()`ì™€ `addMilk()`*ë¥¼ êµ¬í˜„í•´ì•¼ í•˜ì§€ë§Œ, **`prepareLatte()`ì™€ `prepareDoppio()`*ëŠ” ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

Kotlin does not support multiple inheritance, so a class can
inherit only from one open class. I do not find this a problem
because inheritance is not so popular nowadays - interfaces
are implemented instead.

## 5. Interfaces

An interface defines a set of properties and methods that a
class should have. We define interfaces with the interface
keyword, a name, and a body with the expected properties
and methods.

```kotlin
interface CoffeeMaker {
	val type: String
	fun makeCoffee(size: Size): Coffee
}
```

When a class implements an interface, this class has to over-
ride all the elements defined by this interface. Thanks to that,

we can treat an instance of a class as an instance of an inter-
face. We implement interfaces similarly to how we extend

classes, but without calling a constructor because interfaces
cannot have constructors.

```kotlin
class User(val id: Int, val name: String)
	interface UserRepository {
		fun findUser(id: Int): User?
		fun addUser(user: User)
}

class FakeUserRepository : UserRepository {
	private var users = mapOf<Int, User>()
	
	override fun findUser(id: Int): User? = users[id]
	override fun addUser(user: User) {
		users += user.id to user
	}
}

fun main() {
	val repo: UserRepository = FakeUserRepository()
	repo.addUser(User(123, "Zed"))
	val user = repo.findUser(123)
	println(user?.name) // Zed
}
```

`FakeUserRepository`ëŠ” ì´ ë‘ ë©”ì„œë“œë¥¼ **êµ¬í˜„(override)** í•´ì•¼ í•˜ë©°, í•´ë‹¹ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì ì •ë³´ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

As mentioned already, interfaces can specify that they expect
a class to have a particular property. Such properties can
either be defined as regular properties, or they can be defined
by accessors (getter for val, or getter and setter for var).

```kotlin
interface Named {
	val name: String
	val fullName: String
}

class User(
	override val name: String,
	val surname: String,
	) : Named {
	override val fullName: String
		get() = "$name $surname"
}
```

`User` í´ë˜ìŠ¤ëŠ” **`fullName`**ì„ **`name`ê³¼ `surname`ì„ ê²°í•©í•œ ê°’**ìœ¼ë¡œ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤.

The read-only val property can be overridden with a read-
write var property. This is because the val property expects

a getter, and the var property provides a getter as well as an
additional setter.

```kotlin
interface Named {
	val name: String
}

class NameBox : Named {
	override var name = "(default)"
}
```

`NameBox` í´ë˜ìŠ¤ì—ì„œëŠ” **`name`**ì„ **ì½ê¸°/ì“°ê¸° `var`**ë¡œ ì˜¤ë²„ë¼ì´ë“œí•˜ì—¬ **ê°’ì„ ë³€ê²½**í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

A class can implement multiple interfaces.

```kotlin
interface Drinkable {
	fun drink()
}

interface Spillable {
	fun spill()
}

class Mug : Drinkable, Spillable {
	override fun drink() {
		println("Ummm")
	}

	override fun spill() {
		println("Ow, ow, OWWW")
	}
}
```

Interfaces can specify default bodies for their methods. Such

methods do not need to (but can) be implemented by sub-
classes.

```kotlin
class User(val id: Int, val name: String)
	interface UserRepository {
		fun findUser(id: Int): User? =
		getUsers().find { it.id == id }
		fun getUsers(): List<User>
}

class FakeUserRepository : UserRepository {
	private var users = listOf<User>()
	override fun getUsers(): List<User> = users
	fun addUser(user: User) {
		users += user
	}
}

fun main() {
	val repo = FakeUserRepository()
	repo.addUser(User(123, "Zed"))
	val user = repo.findUser(123)
	println(user?.name) // Zed
}
```

When we override a method, we can still call its default body using the super keyword and a regular method call.

Default methods make interfaces more than what they
were traditionally considered to be. They make it possible for
interfaces to define behavior that is inherited by classes that
implement these interfaces. The concept which represents a
set ofmethods that can be used to extend the functionality of a
class is known in programming as a trait. This is why in early
versions of Kotlin, we used the trait keyword instead of the

interface keyword. However, version 8 of Java introduced de-
fault bodies for interfacemethods, so Kotlin creators assumed

that the JVM community would expand the meaning of an
interface, and this is why we now use the interface keyword.
The concept of traits is used in Kotlin. An example can be
found in my article Traits for testing in Kotlin, which you can
find under kt.academy/article/traits-testing.

```kotlin
interface NicePerson {
	fun cheer() {
		println("Hello")
	}
}

class Alex : NicePerson
class Ben : NicePerson {
	override fun cheer() {
		super.cheer()
		println("My name is Ben")
	}
}

fun main() {
	val alex = Alex()
	alex.cheer() // Hello
	val ben = Ben()
	ben.cheer()
	// Hello
	// My name is Ben
}
```

When two interfaces define a method with the same name

and parameters, the class that implements both these inter-
faces must override this method. To call the default bodies

of these methods, we need to use super with the name of the
class we want to use in angle brackets. So, to call start from
Boat use super<Boat>.start(). Or, to call start from Car use
super<Car>.start().

```kotlin
interface Boat {
	fun start() {
		println("Ready to swim")
	}
}

interface Car {
	fun start() {
		println("Ready to drive")
	}
}

class Amphibian: Car, Boat {
	override fun start() {
		super<Car>.start()
		super<Boat>.start()
	}
}

fun main() {
	val vehicle = Amphibian()
	vehicle.start()
	// Ready to drive
	// Ready to swim
}
```

- `Car`ì™€ `Boat` ì¸í„°í˜ì´ìŠ¤ì— **ê°™ì€ ì´ë¦„ì˜ `start()` ë©”ì„œë“œ**ê°€ ì •ì˜ë˜ì–´ ìˆì„ ë•Œ, `Amphibian` í´ë˜ìŠ¤ëŠ” **ê°ê°ì˜ ì¸í„°í˜ì´ìŠ¤ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œ**í•˜ê¸° ìœ„í•´ `super<Car>.start()`ì™€ `super<Boat>.start()`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì´ ë°©ë²•ì€ **ë©”ì„œë“œ ì¶©ëŒ í•´ê²°**ì— ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### 1. **ì²« ë²ˆì§¸ ì½”ë“œ (ì¶”ìƒ ë©”ì„œë“œ)**

```kotlin

interface UserRepository {
    fun findUser(id: Int): User?
    fun addUser(user: User)
}

```

- *`findUser`*ì™€ **`addUser`** ë©”ì„œë“œëŠ” **ì¶”ìƒ ë©”ì„œë“œ**ì…ë‹ˆë‹¤.
    - ì¦‰, **ì¸í„°í˜ì´ìŠ¤**ì—ì„œ ë©”ì„œë“œì— **ëª¸ì²´(êµ¬í˜„ ë‚´ìš©)ì´ ì—†ë‹¤**ëŠ” ëœ»ì…ë‹ˆë‹¤.
    - ì´ ë©”ì„œë“œë“¤ì€ **`UserRepository` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” í´ë˜ìŠ¤**ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´ **`FakeUserRepository`** í´ë˜ìŠ¤ì—ì„œ `findUser()`ì™€ `addUser()` ë©”ì„œë“œê°€ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

### í•µì‹¬:

- `UserRepository`ì—ì„œ **ì¶”ìƒ ë©”ì„œë“œ**ëŠ” **ëª¸ì²´ê°€ ì—†ê³ , ì´ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ì—ì„œ ì§ì ‘ êµ¬í˜„**í•©ë‹ˆë‹¤.

---

### 2. **ë‘ ë²ˆì§¸ ì½”ë“œ (ê¸°ë³¸ êµ¬í˜„ ì œê³µ)**

```kotlin

interface UserRepository {
    fun findUser(id: Int): User? = getUsers().find { it.id == id }
    fun getUsers(): List<User>
}

```

- ì—¬ê¸°ì„œ **`findUser()`*ëŠ” **ê¸°ë³¸ êµ¬í˜„**ì´ ì œê³µëœ ë©”ì„œë“œì…ë‹ˆë‹¤.
    - ê¸°ë³¸ êµ¬í˜„ì—ì„œëŠ” **`getUsers()`** ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ **IDì— ë§ëŠ” ì‚¬ìš©ìë¥¼ ë°˜í™˜**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë©”ì„œë“œì˜ ë™ì‘ì„ ì •ì˜í•©ë‹ˆë‹¤.
    - `getUsers()`ëŠ” **ì¶”ìƒ ë©”ì„œë“œ**ë¡œ ì—¬ì „íˆ ëª¸ì²´ê°€ ì—†ê³ , ì´ë¥¼ **êµ¬í˜„í•˜ëŠ” í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„**í•´ì•¼ í•©ë‹ˆë‹¤.

### í•µì‹¬:

- **`findUser()`** ë©”ì„œë“œëŠ” **ê¸°ë³¸ êµ¬í˜„**ì´ ì œê³µë˜ë©°, **ìì‹ í´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œí•˜ì§€ ì•Šì•„ë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤**.
- `getUsers()`ëŠ” **ì—¬ì „íˆ ì¶”ìƒ ë©”ì„œë“œ**ë¡œ, **ìì‹ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„**í•´ì•¼ í•©ë‹ˆë‹¤.

---

## âœ… í•µì‹¬ ì°¨ì´ì 

1. **ì²« ë²ˆì§¸ ì½”ë“œ**ì—ì„œëŠ” ëª¨ë“  ë©”ì„œë“œê°€ **ì¶”ìƒ ë©”ì„œë“œ**ë¡œ ì •ì˜ë˜ì–´ ìˆì–´ **ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” í´ë˜ìŠ¤**ì—ì„œ **ëª¨ë“  ë©”ì„œë“œë¥¼ ë°˜ë“œì‹œ êµ¬í˜„**í•´ì•¼ í•©ë‹ˆë‹¤.
2. **ë‘ ë²ˆì§¸ ì½”ë“œ**ì—ì„œëŠ” **`findUser()` ë©”ì„œë“œì— ê¸°ë³¸ êµ¬í˜„**ì„ ì œê³µí•˜ê³ , **`getUsers()`ëŠ” ì¶”ìƒ ë©”ì„œë“œ**ë¡œ ë‘ì–´, **ê¸°ë³¸ êµ¬í˜„ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©**í•˜ê±°ë‚˜ **ì˜¤ë²„ë¼ì´ë“œ**í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### âœ… í•œ ì¤„ ìš”ì•½

> ì²« ë²ˆì§¸ ì½”ë“œëŠ” ëª¨ë“  ë©”ì„œë“œê°€ ì¶”ìƒìœ¼ë¡œ ì •ì˜ë˜ì–´, ìì‹ í´ë˜ìŠ¤ì—ì„œ ëª¨ë‘ êµ¬í˜„í•´ì•¼ í•˜ë©°, ë‘ ë²ˆì§¸ ì½”ë“œëŠ” findUser() ë©”ì„œë“œì— ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•˜ì—¬ ìì‹ í´ë˜ìŠ¤ì—ì„œ ì„ íƒì ìœ¼ë¡œ ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
> 

## 6. Visibility

When we design our classes, we prefer to expose as little as
possible46. If there is no reason for an element to be visible47,

we prefer to keep it hidden. This is why if there is no good rea-
son to have a less restrictive visibility type, it is good practice

to make the visibility of classes and elements as restrictive as
possible. We do this using visibility modifiers.
For class members, these are the 4 visibility modifiers we can
use:
â€¢ public (default) - visible everywhere for clients which
can see the declaring class.
â€¢ private - visible inside this class only.
â€¢ protected - visible inside this class and in subclasses.
â€¢ internal - visible inside thismodule for clients which can
see the declaring class.
Top-level elements have 3 visibility modifiers:
â€¢ public (default) - visible everywhere.
â€¢ private - visible inside the same file only.
â€¢ internal - visible inside this module.
Note that a module is not the same as a package. In Kotlin, a
module is defined as a set of Kotlin sources that are compiled
together. This might mean:
â€¢ a Gradle source set,
â€¢ a Maven project,

- an IntelliJ IDEA module,
â€¢ a set of files compiled with one invocation of an Ant task.

Letâ€™s see some examples, starting with the default visibility,

which makes elements visible everywhere and can be explic-
itly specified using the public modifier.

A deeper explanation of the reasons behind this general
programming rule is presented in Effective Kotlin, Item 30:
Minimize elementsâ€™ visibility.
Visibility defines where an element can be used. If an
element is not visible, it will not be suggested by the IDE and
cannot be used.

```kotlin
// File1.kt
open class A {
	public val a = 10
	public fun b() {
		println(a) // Can use it
	}
}

public val c = 20
public fun d() {}

class B: A() {
	fun e() {
		println(a) // Can use it
		println(b()) // Can use it
	}
}

fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
```

The private modifier can be interpreted as â€œvisible in the
creation scopeâ€; so, if we define an element in a class, it will
be visible only in this class; if we define an element in a file, it
will be visible only in this file.

```kotlin
// File1.kt
open class A {
	private val a = 10
	private fun b() {
		println(a) // Can use it
	}
}

private val c = 20
private fun d() {}

class B : A() {
	fun e() {
		println(a) // Error, cannot use a!
		println(b()) // Error, cannot use b!
	}
}

fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Can use it
	println(d()) // Can use it
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Error, cannot use c!
	println(d()) // Error, cannot use d!
}
```

The protected modifier can be interpreted as â€œvisible in the 

class and its subclassesâ€. protected only makes sense for el-
ements defined inside classes. It is similar to private, but

protected elements are also visible inside subclasses of the
class where these elements are defined.

```kotlin
// File1.kt
open class A {
	protected val a = 10
	protected fun b() {
		println(a) // Can use it
	}
}

open class B: A() {
	fun e() {
		println(a) // Can use it!
		println(b()) // Can use it!
	}
}

class C: A() {
	fun f() {
		println(a) // Can use it!
		println(b()) // Can use it!
	}
}

fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
}
```

**`protected`**ëŠ” ìì‹ í´ë˜ìŠ¤ì—ì„œ **ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì†ì„±**ê³¼ **ë©”ì„œë“œì— ì ‘ê·¼**í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ **ì™¸ë¶€ í´ë˜ìŠ¤ì—ì„œëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.**

The internal modifier makes elements visible in the same 

module. It is useful for library creators who use the internal
modifier for elements they want to be visible in their project
but donâ€™t want to expose to library users. It is also useful in
multi-module projects to limit access to a single module. Itâ€™s
useless in single-module projects.

However, Iâ€™ve seen cases where teams used the internal
visibility modifier as a substitute for the Java package-private

modifier. Even though it has different behavior, some devel-
opers treat this modifier as a form of documentation that

should be interpreted as â€œthis element should not be used in
different packagesâ€. I am not a fan of such practices, therefore
I suggest using annotation instead.

```kotlin
// File1.kt
open class A {
	internal val a = 10
	internal fun b() {
		println(a) // Can use it
	}
}

internal val c = 20
internal fun d() {}

class B: A() {
	fun e() {
		println(a) // Can use it
		println(b()) // Can use it
	}
}

fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
```

**`internal`**ì€ **ê°™ì€ ëª¨ë“ˆ ë‚´ì—ì„œë§Œ ì ‘ê·¼** ê°€ëŠ¥í•©ë‹ˆë‹¤. ëª¨ë“ˆì€ Kotlin ì†ŒìŠ¤ íŒŒì¼ë“¤ì„ ì»´íŒŒì¼í•œ ë‹¨ìœ„ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ Gradle í”„ë¡œì íŠ¸ë‚˜ IntelliJ IDEAì˜ ëª¨ë“ˆì„ ê¸°ì¤€ìœ¼ë¡œ í•©ë‹ˆë‹¤.

```kotlin
// File2.kt in the same module as File1.kt
fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
// File3.kt in a different module than File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Error, cannot use c!
	println(d()) // Error, cannot use d!
}
```

If your module might be used by another module, change the
visibility of public elements that you donâ€™t want to expose to
internal. If an element is designed for inheritance and is only
used in a class and subclasses, make it protected. If you use an
element only in the same file or class, make it private.
Changing the visibility of a property means changing the
visibility of its accessors. A propertyâ€™s field is always private.
To change setter visibility, place the visibility modifier before
the set keyword. The getter must have the same visibility as
the property.

```kotlin
class View {
	var isVisible: Boolean = true
	private set
		fun hide() {
			isVisible = false
	}
}

fun main() {
	val view = View()
	println(view.isVisible) // true
	view.hide()
	println(view.isVisible) // false
	view.isVisible = true // ERROR
	// Cannot assign to 'isVisible',
	// the setter is private in 'View'
}
```

**`isVisible`** í”„ë¡œí¼í‹°ëŠ” **ì½ê¸° ì „ìš©**ìœ¼ë¡œ ë§Œë“¤ê³ , ì™¸ë¶€ì—ì„œëŠ” **ìˆ˜ì •í•  ìˆ˜ ì—†ë„ë¡** `private set`ì„ ì‚¬ìš©í•˜ì—¬ **`setter`ì˜ ê°€ì‹œì„±ì„ ì œí•œ**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**Kotlinì˜ ê°€ì‹œì„± ìˆ˜ì •ì**(`public`, `private`, `protected`, `internal`)ëŠ” í´ë˜ìŠ¤, ë©”ì„œë“œ, í”„ë¡œí¼í‹°ì˜ **ì‚¬ìš© ê°€ëŠ¥ ë²”ìœ„ë¥¼ ì„¤ì •**í•˜ì—¬, **ìº¡ìŠí™”(encapsulation)**ë¥¼ í†µí•´ ì½”ë“œì˜ ì•ˆì „ì„±ì„ ë†’ì´ê³  **ë¶ˆí•„ìš”í•œ ì ‘ê·¼ì„ ì œí•œ**í•©ë‹ˆë‹¤.

## 7. Any

If a class has no explicit parent, its implicit parent is Any,
which is a superclass of all the classes in Kotlin. This means
that when we expect the Any? type parameter, we accept all
possible objects as arguments.

```kotlin
fun consumeAnything(a: Any?) {
	println("Om nom $a")
}

fun main() {
	consumeAnything(null) // Om nom null
	consumeAnything(123) // Om nom 123
	consumeAnything("ABC") // Om nom ABC
}
```

Kotlinì—ì„œ **`Any`**ëŠ” **ëª¨ë“  í´ë˜ìŠ¤ì˜ ë¶€ëª¨**ì¸ **ìµœìƒìœ„ í´ë˜ìŠ¤**ë¡œ, ëª¨ë“  í´ë˜ìŠ¤ëŠ” **`Any`**ë¥¼ ìƒì†ë°›ê³  ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ **`Any`** íƒ€ì…ì€ **ëª¨ë“  ê°ì²´ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì„ ìˆ˜ ìˆê²Œ** í•´ì¤ë‹ˆë‹¤.

**`Any?`**ëŠ” **ëª¨ë“  ê°ì²´**ì™€ **`null`**ì„ í—ˆìš©í•˜ëŠ” íƒ€ì…, **`toString()`**, **`equals()`**, **`hashCode()`**ì™€ ê°™ì€ ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œë“¤ì€ **`Any` í´ë˜ìŠ¤**ì— ê¸°ë³¸ì ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ ìˆìœ¼ë©°, **ëª¨ë“  í´ë˜ìŠ¤**ëŠ” ì´ ë©”ì„œë“œë“¤ì„ **ìƒì†**í•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œë“¤ì„ **ì˜¤ë²„ë¼ì´ë“œ**í•˜ëŠ” ê²ƒì€ **ì„ íƒì **ì…ë‹ˆë‹¤. ì¦‰, íŠ¹ë³„í•œ ì´ìœ ê°€ ì—†ìœ¼ë©´ **ê¸°ë³¸ êµ¬í˜„ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜** ìˆìŠµë‹ˆë‹¤.

`toString()`, `equals()`, `hashCode()`ëŠ” ëª¨ë“  ê°ì²´ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, **íŠ¹ë³„íˆ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„** ê¸°ë³¸ì ì¸ ë™ì‘ì„ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì›í•˜ëŠ” ëŒ€ë¡œ **ì˜¤ë²„ë¼ì´ë“œ**í•˜ì—¬ ë™ì‘ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

You can think of Any as an open class with three methods:
toString, equals and hashCode. These will be better explained in
the next chapter, Data classes. Overridingmethods defined by
Any is optional because each is an open function with a default
body.

Summary

In this chapter, weâ€™ve learned how to use inheritance in
Kotlin. Weâ€™ve got familiar with open and abstract classes,
interfaces, and visibility modifiers. These are useful when
we want to represent hierarchies of classes.
Instead of using classes to represent hierarchies, we can also
treat them as holders of data; for this we use the data modifier,
which is presented in the next chapter.

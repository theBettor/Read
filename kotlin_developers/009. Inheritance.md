Ancient philosophers observed that many classes of objects
share the same characteristics. For instance, all mammals
have hair or fur, are warm-blooded, and feed their young with
milk. In programming, we represent such relationships
using inheritance.
When a class inherits from another class, it has all its member
functions and properties. The class that inherits is known
as a subclass of the class it inherits from, which is called a
superclass. They are also known as child and parent.
In Kotlin, all classes are closed by default, which means we
cannot inherit from them. We need to open a class using the
open keyword to allow inheritance from it. To inherit from a
class, we place a colon after the primary constructor (or after
the class name if there is no primary constructor), and then
we invoke the superclass constructor. In the example below,
the class Dog inherits from the class Mammal. Since Mammal has no
constructor specified, we call it without arguments, so with
Mammal(). This way, Dog inherits all the properties andmethods
from Mammal.

```kotlin
open class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false

	fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		}
	}
}

class Dog : Mammal() {
	fun makeVoice() {
		println("Bark bark")
	}
}

fun main() {
	val dog = Dog()
	dog.makeVoice() // Bark bark
	println(dog.haveHairOrFur) // true
	println(dog.warmBlooded) // true
	// Dog is Mammal, so we can up-cast it
	val mammal: Mammal = dog
	mammal.canFeed = true
	mammal.feedYoung() // Feeding young with milk
}
```

Conceptually, we treat subclasses as if they are their super-
classes: so, if Dog inherits from Mammal, we say that Dog is a

Mammal. Likewise, wherever Mammal is expected, we can use an
instance of Dog. Taking this into account, inheritance should
only be used if a real “is a” relationship between two classes
exists.

- 상속 : 자식 클래스가 부모 클래스의 속성이나 메서드를 물려받는 것.
- open : Kotlin에서는 기본적으로 클래스가 final로 선언되어 있어, 상속을 허용하려면 open 키워드를 사용해야한다.
- 업캐스팅 : 자식 클래스의 객체를 부모 클래스 타입으로 변환하는 과정, Dog 객체를 Mammal 타입의 변수에 할당하는 것.
    
     
    
    ```kotlin
    val dog = Dog()  // Dog 클래스의 객체 생성
    val mammal: Mammal = dog  // Dog 객체를 Mammal 타입으로 업캐스팅
    ```
    
    mammal 변수는 Mammal 타입인데, 실제로는 Dog 객체를 참조(= Dog 클래스의 인스턴스를 참조)하고 있다.
    
- 업캐스팅이 필요한 이유
    - 다형성: 여러 자식 클래스를 공통된 부모 타입으로 처리
    - 상속받은 기능만 사용할 수 있게 제한:
        - `Dog` 클래스는 `Mammal`의 속성과 메서드를 상속받고 있지만, `Dog`만의 기능인 `makeVoice()`는 `Mammal` 타입에서는 접근할 수 없습니다.
        - `Dog` 객체를 `Mammal` 타입으로 업캐스팅하면 **`Mammal`의 속성**만 사용할 수 있게 제한됩니다.(`mammal`로 다루는 동안, `Dog`에 특화된 `makeVoice()` 메서드는 사용할 수 없지만, `Mammal`에 정의된 **`canFeed`**와 **`feedYoung()`**을 사용할 수 있습니다.)

## 1. Overriding elements

By default, subclasses cannot override elements defined in
superclasses. To make this possible, these elements need to
allow it with the open modifier, because in Kotlin all elements
are closed by default. Then, subclasses can override their
parents’ implementation, which looks just like defining the
same function in children but with the override modifier (this
modifier is required in Kotlin).

```kotlin
open class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false

	open fun feedYoung() {
		if (canFeed) {
		println("Feeding young with milk")
		}
	}
}

class Cat : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		} else {
			println("Feeding young with milk from bottle")
		}
	}
}

fun main() {
	val dog = Mammal()
	dog.feedYoung() // Nothing printed
	val cat = Cat()
	cat.feedYoung() // Feeding young with milk from bottle
	cat.canFeed = true
	cat.feedYoung() // Feeding young with milk
}
```

> **`open` 키워드**로 부모 클래스 메서드를 **오버라이드할 수 있게 열어두고**, **`override` 키워드**로 자식 클래스에서 부모의 메서드를 **새로운 동작으로 덮어쓸 수** 있습니다.
> 

## 2. Parents with non-empty constructors

So far, we have inherited only from classes with empty con-
structors; so, when we were specifying the superclass, we

used empty parentheses. However, if the superclass has con-
structor parameters, we need to define some arguments in-
side these parentheses.

```kotlin
open class Animal(val name: String)

class Dodo : Animal("Dodo")
```

- **`Animal` 클래스**는 `name`을 매개변수로 받는 생성자를 가지고 있습니다.
- **`Dodo` 클래스**는 부모 클래스 `Animal`을 상속하고, `Animal("Dodo")`와 같이 부모의 생성자에 `"Dodo"`를 전달하고 있습니다.
    - `Dodo` 객체를 생성할 때 부모 클래스의 생성자에 값을 전달하는 방식입니다.

We can use primary constructor properties as superclass con-
structor arguments or to construct these arguments.

```kotlin
open class Animal(val name: String)

class Dog(name: String) : Animal(name)

class Cat(name: String) : Animal("Mr $name")

class Human(
	firstName: String,
	lastName: String,
) : Animal("$firstName $lastName")

fun main() {
	val dog = Dog("Cookie")
	println(dog.name) // Cookie
	val cat = Cat("MiauMiau")
	println(cat.name) // Mr MiauMiau
}
```

- `Dog("Cookie")`는 `name`을 `"Cookie"`로 전달하여 `Animal("Cookie")`가 실행됩니다.
- `Cat("MiauMiau")`는 `"Mr "`을 덧붙여서 `Animal("Mr MiauMiau")`가 실행됩니다.
- 자식 클래스에서 부모 생성자에 인자를 전달하려면 **`super()`**를 사용 (Kotlin에서는 주로 부모 생성자가 자동으로 호출)

## 3. Super call

When a class extends another class, it takes the behavior from
the superclass but also adds some behavior that is specific to

the subclass. This is why overriding methods often need to in-
clude the behavior of the methods they override. For this, it is

useful to call the superclass implementation in these subclass
methods. We do this using the super keyword, followed by a
dot, and then we call the method we want to override.
Consider the classes Dog and BorderCollie that are presented in
the example below. The default behavior for a dog is to wave
its tail when it sees a dog friend. Border Collies should behave 

the same but additionally lie down. In this case, to call the
superclass implementation, we need to use super.seeFriend().

```kotlin
open class Dog {
	open fun seeFriend() {
		println("Wave its tail")
	}
}

class BorderCollie : Dog() {
	override fun seeFriend() {
		println("Lie down")
		super.seeFriend()
	}
}

fun main() {
	val dog = Dog()
	dog.seeFriend() // Wave its tail
	val borderCollie = BorderCollie()
	borderCollie.seeFriend()
	// Lie down
	// Wave its tail
}
```

> "자식 클래스에서 오버라이드한 함수 내에서, `super`를 사용하여 부모 클래스의 오버라이드 전 메서드도 호출할 수 있다."
> 

> **`super`를 사용해야 하는 경우**는 부모 클래스의 **메서드를 호출**하거나 **생성자에 인자를 명시적으로 전달**할 때입니다.
> 

## 4. Abstract class

A mammal is a group of animals, not a concrete species. It
defines a set of characteristics but might not exist in itself.
To define a class that can only be used as a superclass of
other classes but cannot produce an object,we use the abstract
keyword before its class definition. You can interpret the open
modifier as “one can inherit from this class”,whereas abstract
means “one must inherit from this class to use it”.

### 📘 추상 클래스 개념

- **추상 클래스**는 **구체적인 인스턴스를 만들 수 없고**, **상속을 통해서만 사용**될 수 있습니다.
- 추상 클래스는 **`abstract` 키워드**를 사용하여 정의합니다.
- **추상 메서드**는 몸체가 없으며, **자식 클래스에서 반드시 오버라이드**해야 합니다.
- **비추상 메서드**는 기본적인 동작을 정의할 수 있으며, 자식 클래스에서 **재사용**할 수 있습니다.

```kotlin
abstract class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false
		fun feedYoung() {
			if (canFeed) {
			println("Feeding young with milk")
		}
	}
}
```

Abstract classes are open, so there is no need to use the open
modifier when a class has the abstract modifier already.
When a class is abstract, it can have abstract functions and

properties. Such functions do not have a body, and each sub-
class needs to override them. Thanks to that,whenwe have an

object whose type is an abstract class, we can call its abstract
functions because whatever the actual class of this object is, it
still needs to define these functions.

```kotlin
abstract class Mammal {
	val haveHairOrFur = true
	val warmBlooded = true
	var canFeed = false
	abstract fun feedYoung()
	
	// 위 3개의 일반 프로퍼티는 자식클래스에서 사용할 수 있다.
}
class Dog : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		}
	}
}

class Human : Mammal() {
	override fun feedYoung() {
		if (canFeed) {
			println("Feeding young with milk")
		} else {
			println("Feeding young with milk from bottle")
		}
	}
}

fun feedYoung(mammal: Mammal) {
	// We can do that, because feedYoung is an abstract
	// function in Mammal
	mammal.feedYoung()
}

fun main() {
	val dog = Dog()
	dog.canFeed = true
	feedYoung(dog) // Feeding young with milk
	feedYoung(Human()) // Feeding young with milk from bottle
}
```

> `feedYoung(mammal: Mammal)` 메서드를 만든 이유는 `feedYoung()` 메서드가 추상 메서드로 부모 클래스에서 정의되어 있기 때문이며, `Mammal` 타입의 객체를 매개변수로 받음으로써 `Dog`, `Human`와 같은 자식 클래스 객체들을 하나의 부모 타입으로 다룰 수 있게 해줍니다.
> 

An abstract class can also have non-abstract methods, which
have a body. Such methods can be used by other methods.
Therefore, abstract classes can be used as templates with
partial implementation for other classes. Consider the
CoffeeMachine abstract class below, which specifies how latte
or doppio can be prepared, but it needs a subclass to override
the prepareEspresso and addMilk methods. This class provides
implementation for only some methods, so it is a partial
implementation.

```kotlin
abstract class CoffeeMachine {
	abstract fun prepareEspresso()
	abstract fun addMilk()
	fun prepareLatte() {
		prepareEspresso()
		addMilk()
	}
	
	fun prepareDoppio() {
		prepareEspresso()
		prepareEspresso()
	}
}
```

- **`CoffeeMachine`** 클래스는 **부분적으로 구현**된 추상 클래스입니다.
    - **추상 메서드**: `prepareEspresso()`, `addMilk()`는 자식 클래스에서 반드시 구현해야 합니다.
    - **비추상 메서드**: `prepareLatte()`, `prepareDoppio()`는 기본 구현을 제공하며, 자식 클래스에서 사용할 수 있습니다.
- 자식 클래스는 **`prepareEspresso()`와 `addMilk()`*를 구현해야 하지만, **`prepareLatte()`와 `prepareDoppio()`*는 그대로 사용할 수 있습니다.

Kotlin does not support multiple inheritance, so a class can
inherit only from one open class. I do not find this a problem
because inheritance is not so popular nowadays - interfaces
are implemented instead.

## 5. Interfaces

An interface defines a set of properties and methods that a
class should have. We define interfaces with the interface
keyword, a name, and a body with the expected properties
and methods.

```kotlin
interface CoffeeMaker {
	val type: String
	fun makeCoffee(size: Size): Coffee
}
```

When a class implements an interface, this class has to over-
ride all the elements defined by this interface. Thanks to that,

we can treat an instance of a class as an instance of an inter-
face. We implement interfaces similarly to how we extend

classes, but without calling a constructor because interfaces
cannot have constructors.

```kotlin
class User(val id: Int, val name: String)
	interface UserRepository {
		fun findUser(id: Int): User?
		fun addUser(user: User)
}

class FakeUserRepository : UserRepository {
	private var users = mapOf<Int, User>()
	
	override fun findUser(id: Int): User? = users[id]
	override fun addUser(user: User) {
		users += user.id to user
	}
}

fun main() {
	val repo: UserRepository = FakeUserRepository()
	repo.addUser(User(123, "Zed"))
	val user = repo.findUser(123)
	println(user?.name) // Zed
}
```

`FakeUserRepository`는 이 두 메서드를 **구현(override)** 해야 하며, 해당 구현에서는 사용자 정보를 관리합니다.

As mentioned already, interfaces can specify that they expect
a class to have a particular property. Such properties can
either be defined as regular properties, or they can be defined
by accessors (getter for val, or getter and setter for var).

```kotlin
interface Named {
	val name: String
	val fullName: String
}

class User(
	override val name: String,
	val surname: String,
	) : Named {
	override val fullName: String
		get() = "$name $surname"
}
```

`User` 클래스는 **`fullName`**을 **`name`과 `surname`을 결합한 값**으로 구현하고 있습니다.

The read-only val property can be overridden with a read-
write var property. This is because the val property expects

a getter, and the var property provides a getter as well as an
additional setter.

```kotlin
interface Named {
	val name: String
}

class NameBox : Named {
	override var name = "(default)"
}
```

`NameBox` 클래스에서는 **`name`**을 **읽기/쓰기 `var`**로 오버라이드하여 **값을 변경**할 수 있도록 합니다.

A class can implement multiple interfaces.

```kotlin
interface Drinkable {
	fun drink()
}

interface Spillable {
	fun spill()
}

class Mug : Drinkable, Spillable {
	override fun drink() {
		println("Ummm")
	}

	override fun spill() {
		println("Ow, ow, OWWW")
	}
}
```

Interfaces can specify default bodies for their methods. Such

methods do not need to (but can) be implemented by sub-
classes.

```kotlin
class User(val id: Int, val name: String)
	interface UserRepository {
		fun findUser(id: Int): User? =
		getUsers().find { it.id == id }
		fun getUsers(): List<User>
}

class FakeUserRepository : UserRepository {
	private var users = listOf<User>()
	override fun getUsers(): List<User> = users
	fun addUser(user: User) {
		users += user
	}
}

fun main() {
	val repo = FakeUserRepository()
	repo.addUser(User(123, "Zed"))
	val user = repo.findUser(123)
	println(user?.name) // Zed
}
```

When we override a method, we can still call its default body using the super keyword and a regular method call.

Default methods make interfaces more than what they
were traditionally considered to be. They make it possible for
interfaces to define behavior that is inherited by classes that
implement these interfaces. The concept which represents a
set ofmethods that can be used to extend the functionality of a
class is known in programming as a trait. This is why in early
versions of Kotlin, we used the trait keyword instead of the

interface keyword. However, version 8 of Java introduced de-
fault bodies for interfacemethods, so Kotlin creators assumed

that the JVM community would expand the meaning of an
interface, and this is why we now use the interface keyword.
The concept of traits is used in Kotlin. An example can be
found in my article Traits for testing in Kotlin, which you can
find under kt.academy/article/traits-testing.

```kotlin
interface NicePerson {
	fun cheer() {
		println("Hello")
	}
}

class Alex : NicePerson
class Ben : NicePerson {
	override fun cheer() {
		super.cheer()
		println("My name is Ben")
	}
}

fun main() {
	val alex = Alex()
	alex.cheer() // Hello
	val ben = Ben()
	ben.cheer()
	// Hello
	// My name is Ben
}
```

When two interfaces define a method with the same name

and parameters, the class that implements both these inter-
faces must override this method. To call the default bodies

of these methods, we need to use super with the name of the
class we want to use in angle brackets. So, to call start from
Boat use super<Boat>.start(). Or, to call start from Car use
super<Car>.start().

```kotlin
interface Boat {
	fun start() {
		println("Ready to swim")
	}
}

interface Car {
	fun start() {
		println("Ready to drive")
	}
}

class Amphibian: Car, Boat {
	override fun start() {
		super<Car>.start()
		super<Boat>.start()
	}
}

fun main() {
	val vehicle = Amphibian()
	vehicle.start()
	// Ready to drive
	// Ready to swim
}
```

- `Car`와 `Boat` 인터페이스에 **같은 이름의 `start()` 메서드**가 정의되어 있을 때, `Amphibian` 클래스는 **각각의 인터페이스에서 메서드를 호출**하기 위해 `super<Car>.start()`와 `super<Boat>.start()`를 사용합니다.
- 이 방법은 **메서드 충돌 해결**에 유용하게 사용됩니다.

### 1. **첫 번째 코드 (추상 메서드)**

```kotlin

interface UserRepository {
    fun findUser(id: Int): User?
    fun addUser(user: User)
}

```

- *`findUser`*와 **`addUser`** 메서드는 **추상 메서드**입니다.
    - 즉, **인터페이스**에서 메서드에 **몸체(구현 내용)이 없다**는 뜻입니다.
    - 이 메서드들은 **`UserRepository` 인터페이스를 구현하는 클래스**에서 반드시 구현해야 합니다.
- 예를 들어 **`FakeUserRepository`** 클래스에서 `findUser()`와 `addUser()` 메서드가 구현되어 있습니다.

### 핵심:

- `UserRepository`에서 **추상 메서드**는 **몸체가 없고, 이를 구현한 클래스에서 직접 구현**합니다.

---

### 2. **두 번째 코드 (기본 구현 제공)**

```kotlin

interface UserRepository {
    fun findUser(id: Int): User? = getUsers().find { it.id == id }
    fun getUsers(): List<User>
}

```

- 여기서 **`findUser()`*는 **기본 구현**이 제공된 메서드입니다.
    - 기본 구현에서는 **`getUsers()`** 메서드를 호출하여 **ID에 맞는 사용자를 반환**하는 방식으로 메서드의 동작을 정의합니다.
    - `getUsers()`는 **추상 메서드**로 여전히 몸체가 없고, 이를 **구현하는 클래스에서 구현**해야 합니다.

### 핵심:

- **`findUser()`** 메서드는 **기본 구현**이 제공되며, **자식 클래스에서 오버라이드하지 않아도 사용할 수 있습니다**.
- `getUsers()`는 **여전히 추상 메서드**로, **자식 클래스에서 반드시 구현**해야 합니다.

---

## ✅ 핵심 차이점

1. **첫 번째 코드**에서는 모든 메서드가 **추상 메서드**로 정의되어 있어 **인터페이스를 구현하는 클래스**에서 **모든 메서드를 반드시 구현**해야 합니다.
2. **두 번째 코드**에서는 **`findUser()` 메서드에 기본 구현**을 제공하고, **`getUsers()`는 추상 메서드**로 두어, **기본 구현을 그대로 사용**하거나 **오버라이드**하여 사용할 수 있습니다.

---

### ✅ 한 줄 요약

> 첫 번째 코드는 모든 메서드가 추상으로 정의되어, 자식 클래스에서 모두 구현해야 하며, 두 번째 코드는 findUser() 메서드에 기본 구현을 제공하여 자식 클래스에서 선택적으로 오버라이드할 수 있도록 합니다.
> 

## 6. Visibility

When we design our classes, we prefer to expose as little as
possible46. If there is no reason for an element to be visible47,

we prefer to keep it hidden. This is why if there is no good rea-
son to have a less restrictive visibility type, it is good practice

to make the visibility of classes and elements as restrictive as
possible. We do this using visibility modifiers.
For class members, these are the 4 visibility modifiers we can
use:
• public (default) - visible everywhere for clients which
can see the declaring class.
• private - visible inside this class only.
• protected - visible inside this class and in subclasses.
• internal - visible inside thismodule for clients which can
see the declaring class.
Top-level elements have 3 visibility modifiers:
• public (default) - visible everywhere.
• private - visible inside the same file only.
• internal - visible inside this module.
Note that a module is not the same as a package. In Kotlin, a
module is defined as a set of Kotlin sources that are compiled
together. This might mean:
• a Gradle source set,
• a Maven project,

- an IntelliJ IDEA module,
• a set of files compiled with one invocation of an Ant task.

Let’s see some examples, starting with the default visibility,

which makes elements visible everywhere and can be explic-
itly specified using the public modifier.

A deeper explanation of the reasons behind this general
programming rule is presented in Effective Kotlin, Item 30:
Minimize elements’ visibility.
Visibility defines where an element can be used. If an
element is not visible, it will not be suggested by the IDE and
cannot be used.

```kotlin
// File1.kt
open class A {
	public val a = 10
	public fun b() {
		println(a) // Can use it
	}
}

public val c = 20
public fun d() {}

class B: A() {
	fun e() {
		println(a) // Can use it
		println(b()) // Can use it
	}
}

fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
```

The private modifier can be interpreted as “visible in the
creation scope”; so, if we define an element in a class, it will
be visible only in this class; if we define an element in a file, it
will be visible only in this file.

```kotlin
// File1.kt
open class A {
	private val a = 10
	private fun b() {
		println(a) // Can use it
	}
}

private val c = 20
private fun d() {}

class B : A() {
	fun e() {
		println(a) // Error, cannot use a!
		println(b()) // Error, cannot use b!
	}
}

fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Can use it
	println(d()) // Can use it
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Error, cannot use c!
	println(d()) // Error, cannot use d!
}
```

The protected modifier can be interpreted as “visible in the 

class and its subclasses”. protected only makes sense for el-
ements defined inside classes. It is similar to private, but

protected elements are also visible inside subclasses of the
class where these elements are defined.

```kotlin
// File1.kt
open class A {
	protected val a = 10
	protected fun b() {
		println(a) // Can use it
	}
}

open class B: A() {
	fun e() {
		println(a) // Can use it!
		println(b()) // Can use it!
	}
}

class C: A() {
	fun f() {
		println(a) // Can use it!
		println(b()) // Can use it!
	}
}

fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
}

// File2.kt in the same or different module as File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
}
```

**`protected`**는 자식 클래스에서 **부모 클래스의 속성**과 **메서드에 접근**할 수 있게 합니다. 그러나 **외부 클래스에서는 접근할 수 없습니다.**

The internal modifier makes elements visible in the same 

module. It is useful for library creators who use the internal
modifier for elements they want to be visible in their project
but don’t want to expose to library users. It is also useful in
multi-module projects to limit access to a single module. It’s
useless in single-module projects.

However, I’ve seen cases where teams used the internal
visibility modifier as a substitute for the Java package-private

modifier. Even though it has different behavior, some devel-
opers treat this modifier as a form of documentation that

should be interpreted as “this element should not be used in
different packages”. I am not a fan of such practices, therefore
I suggest using annotation instead.

```kotlin
// File1.kt
open class A {
	internal val a = 10
	internal fun b() {
		println(a) // Can use it
	}
}

internal val c = 20
internal fun d() {}

class B: A() {
	fun e() {
		println(a) // Can use it
		println(b()) // Can use it
	}
}

fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
```

**`internal`**은 **같은 모듈 내에서만 접근** 가능합니다. 모듈은 Kotlin 소스 파일들을 컴파일한 단위입니다. 일반적으로 Gradle 프로젝트나 IntelliJ IDEA의 모듈을 기준으로 합니다.

```kotlin
// File2.kt in the same module as File1.kt
fun main() {
	println(A().a) // Can use it
	println(A().b()) // Can use it
	println(c) // Can use it
	println(d()) // Can use it
}
// File3.kt in a different module than File1.kt
fun main() {
	println(A().a) // Error, cannot use a!
	println(A().b()) // Error, cannot use b!
	println(c) // Error, cannot use c!
	println(d()) // Error, cannot use d!
}
```

If your module might be used by another module, change the
visibility of public elements that you don’t want to expose to
internal. If an element is designed for inheritance and is only
used in a class and subclasses, make it protected. If you use an
element only in the same file or class, make it private.
Changing the visibility of a property means changing the
visibility of its accessors. A property’s field is always private.
To change setter visibility, place the visibility modifier before
the set keyword. The getter must have the same visibility as
the property.

```kotlin
class View {
	var isVisible: Boolean = true
	private set
		fun hide() {
			isVisible = false
	}
}

fun main() {
	val view = View()
	println(view.isVisible) // true
	view.hide()
	println(view.isVisible) // false
	view.isVisible = true // ERROR
	// Cannot assign to 'isVisible',
	// the setter is private in 'View'
}
```

**`isVisible`** 프로퍼티는 **읽기 전용**으로 만들고, 외부에서는 **수정할 수 없도록** `private set`을 사용하여 **`setter`의 가시성을 제한**할 수 있습니다.

**Kotlin의 가시성 수정자**(`public`, `private`, `protected`, `internal`)는 클래스, 메서드, 프로퍼티의 **사용 가능 범위를 설정**하여, **캡슐화(encapsulation)**를 통해 코드의 안전성을 높이고 **불필요한 접근을 제한**합니다.

## 7. Any

If a class has no explicit parent, its implicit parent is Any,
which is a superclass of all the classes in Kotlin. This means
that when we expect the Any? type parameter, we accept all
possible objects as arguments.

```kotlin
fun consumeAnything(a: Any?) {
	println("Om nom $a")
}

fun main() {
	consumeAnything(null) // Om nom null
	consumeAnything(123) // Om nom 123
	consumeAnything("ABC") // Om nom ABC
}
```

Kotlin에서 **`Any`**는 **모든 클래스의 부모**인 **최상위 클래스**로, 모든 클래스는 **`Any`**를 상속받고 있습니다. 따라서 **`Any`** 타입은 **모든 객체를 인수로 받을 수 있게** 해줍니다.

**`Any?`**는 **모든 객체**와 **`null`**을 허용하는 타입, **`toString()`**, **`equals()`**, **`hashCode()`**와 같은 메서드를 제공합니다. 이 메서드들은 **`Any` 클래스**에 기본적으로 구현되어 있으며, **모든 클래스**는 이 메서드들을 **상속**합니다. 이 메서드들을 **오버라이드**하는 것은 **선택적**입니다. 즉, 특별한 이유가 없으면 **기본 구현을 그대로 사용할 수** 있습니다.

`toString()`, `equals()`, `hashCode()`는 모든 객체에서 사용할 수 있으며, **특별히 구현하지 않아도** 기본적인 동작을 합니다. 하지만 원하는 대로 **오버라이드**하여 동작을 변경할 수 있습니다.

You can think of Any as an open class with three methods:
toString, equals and hashCode. These will be better explained in
the next chapter, Data classes. Overridingmethods defined by
Any is optional because each is an open function with a default
body.

Summary

In this chapter, we’ve learned how to use inheritance in
Kotlin. We’ve got familiar with open and abstract classes,
interfaces, and visibility modifiers. These are useful when
we want to represent hierarchies of classes.
Instead of using classes to represent hierarchies, we can also
treat them as holders of data; for this we use the data modifier,
which is presented in the next chapter.

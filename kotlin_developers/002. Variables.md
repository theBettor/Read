## 1. Variables

### 1. 변수의 특징과 타입 추론

- 변수는 명시적으로 타입을 지정할 필요가 없지만, 이는 변수가 타입이 없다는 뜻은 아니다
    - Kotlin은 정적 타입 언어이므로 모든 변수는 타입이 지정 되어야 한다.
    - 쉽게 이야기하면 Kotlin은 타입을 명시하지 않아도 초기화 값에 따라 타입 추론을 할 수 있다.

```kotlin
fun main() {
	val a = 10
	var b: String = "ABC"
	print(a) // 10
	print(b) // ABC
	// a = 12 is not possible, because a is read-only!
	b = "CDE"
	print(b) // CDE
}
```

### 2. 변수의 초기화

- 변수를 초기화할 때는 값을 부여해야 합니다. 아래 예시처럼, Kotlin이 값이 설정되기 전에 변수가 사용되지 않을 것이라고 확신할 수 있는 경우 변수의 정의와 초기화를 분리할 수 있습니다. 불필요한 경우 이 관행을 피하는 것이 좋습니다.

```kotlin
fun main() {
	val a: Int
	a = 10
	println(a) // 10
}
```

- 오른쪽은 무엇으로 초기화할 수 있을까? 값을 반환하는 코드 조각인 모든 표현식이 될 수 있다.
    - 기본 타입 리터럴(예: 1 또는 "ABC")
    - 표현식으로 사용되는 조건문(예: if-표현식, when-표현식, try-catch 표현식)
    - 생성자 호출
    - 함수 호출
    - 객체 표현식 또는 객체 선언
    - 함수 리터럴(예: 람다 표현식, 익명 함수 또는 함수 참조)
    - 요소 참조

## 2. **Basic types, their literals and operations**

- 모든 언어는 내장된 타입과 리터럴을 가져서 기본적인 값 유형을 표현해야 합니다.
- 타입은 알겠는데 리터럴은 인스턴스를 생성하는 데 사용되는 내장된 표기법입니다.
    - 따옴표로 묶인 문자열 리터럴(예: "test")이나 숫자 자체인 정수 리터럴(예: 1) 등이 있습니다.
- Kotlin에는 배열 기본 타입도 있는데 [컬렉션](https://www.notion.so/kotlin-developer-Functional-md-2965c025e1ec80d592b7d74f6801f8ad?pvs=21)에서 다뤄봅시다.
- Kotlin에서는 모든 값이 객체로 간주됩니다(기본형은 존재하지 않음). 따라서 모든 값은 메서드를 가지며, 해당 유형은 제네릭 유형 인자로 사용될 수 있습니다. 숫자, 부울, 문자를 나타내는 유형은 Kotlin 컴파일러에 의해 최적화되어 기본형으로 사용될 수 있지만, 이 최적화는 Kotlin 개발자에게 영향을 미치지 않으므로 고려할 필요조차 없습니다.
    
    ```kotlin
    // ===== C (프리미티브 중심) =====
    #include <stdio.h>
    #include <stdbool.h>
    
    // C에서는 int/char/bool 등이 "기본형(프리미티브)"이고, 메서드가 없다.
    // -> 숫자에 x.toString() 같은 걸 호출할 수 없고, 항상 함수로 처리한다.
    int is_even(int x) { return x % 2 == 0; }
    
    // C에는 제네릭이 없다. 타입을 섞어 쓰려면 보통 void*로 캐스팅을 직접 관리해야 한다.
    // (아래는 단순 예라 생략. 핵심: "제네릭 없음", "캐스팅/메모리 직접 관리")
    
    int main(void) {
        int    n   = 42;      // 프리미티브
        bool   ok  = true;    // 프리미티브
        char   ch  = 'A';     // 프리미티브
    
        // 메서드 호출 불가 → 함수 사용
        printf("n = %d\n", n);
        printf("n is even? %s\n", is_even(n) ? "yes" : "no");
    
        // 정리:
        // - C는 모든 값이 객체가 아님(= 대부분 프리미티브).
        // - 따라서 값 자체에 메서드가 없고, 제네릭 타입 인자 같은 개념도 언어 차원에 없다.
        // - 성능/메모리/표현은 전부 개발자가 직접 관리한다.
        return 0;
    }
    
    ```
    
    ```kotlin
    // ===== Kotlin (코드 레벨에선 "모든 값이 객체처럼") =====
    
    fun main() {
        val n: Int = 42
        val ok: Boolean = true
        val ch: Char = 'A'
    
        // (핵심1) Kotlin에서는 "모든 값이 객체로 간주"되는 것처럼 쓴다.
        // → 숫자/불리언/문자도 메서드를 가진다(객체처럼 보임).
        println(n.toString())               // "42"
        println(ok.not())                   // false
        println(ch.lowercaseChar())         // 'a'
    
        // (핵심2) "해당 유형은 제네릭 타입 인자로 사용 가능"
        // → 기본 숫자 타입(Int/Double 등)도 제네릭 컨테이너에 그대로 넣는다.
        val xs: List<Int> = listOf(1, 2, 3)
        println(xs.joinToString())          // "1, 2, 3"
    
        // (핵심3) "숫자/부울/문자 타입은 컴파일러가 프리미티브로 최적화할 수 있음"
        // → 개발자는 신경 쓸 필요 없음(박싱/언박싱/성능 최적화는 컴파일러가 알아서).
        // 즉, 코드는 항상 '객체처럼' 일관되게 쓰고, 성능은 자동 최적화.
        println(10 + 20)                    // 산술도 자연스럽게 사용
    
        // 보너스: 확장 함수도 기본 타입에 붙일 수 있다(객체처럼 취급하니까 가능).
        println(10.isEven())                // true
    }
    
    // Int도 "객체처럼" 확장 가능
    fun Int.isEven(): Boolean = this % 2 == 0
    
    /* 정리
       - Kotlin: "코드 관점"에서 모든 값이 객체처럼 동작 → 메서드 호출/확장 함수/제네릭 인자 OK
       - 런타임 최적화(프리미티브 사용 여부)는 컴파일러 담당 → 우리는 고려하지 않아도 됨
    */ 
    ```

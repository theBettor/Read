Classes and interfaces in Kotlin are not only used to repre-
sent a set of operations or data; we can also use classes and

inheritance to represent hierarchies through polymorphism.
For instance, let’s say that you send a network request; as
a result, you either successfully receive the requested data,
or the request fails with some information about what went
wrong. These two outcomes can be represented using two
classes that implement an interface:

```kotlin
interface Result
class Success(val data: String) : Result
class Failure(val exception: Throwable) : Result
```

- 일반 **interface**나 **abstract class**를 쓰면, 누군가 다른 모듈/파일에서 **새로운 서브클래스**를 정의할 수 있습니다.
- 즉, `Result`라는 타입이 있더라도 `Success`, `Failure` 말고도 누군가 `FakeSuccess` 같은 것을 추가할 수 있음 → **열린 계층(Non-restricted hierarchy)**

Alternatively, you could use an abstract class:

```kotlin
abstract class Result
class Success(val data: String) : Result()
class Failure(val exception: Throwable) : Result()
```

With either of these, we know that when a function returns
Result, it can be Success or Failure.

```kotlin
val result: Result = getSomeData()
when (result) {
    is Success -> handleSuccess(result.data)
    is Failure -> handleFailure(result.exception)
    // else 필요 없음 (sealed라 모든 경우를 이미 알고 있음)
}
```

- **네트워크 요청 결과**: `Success(data)` / `Failure(exception)`
- **UI 상태**: `Loading`, `Loaded`, `Error`
- **도메인 이벤트**: 정해진 경우만 발생하는 이벤트 집합

The problem is that when a regular interface or abstract class
is used, there is no guarantee that its defined subclasses are all
possible subtypes of this interface or abstract class. Someone
might define another class and make it implement Result.
Someone might also implement an object expression that
implements Result.

```kotlin
class FakeSuccess : Result
val res: Result = object : Result {}
```

A hierarchy whose subclasses are not known in advance is
known as a non-restricted hierarchy. For Result, we prefer to
define a restricted hierarchy, which we do by using a sealed
modifier before a class or an interface.

Restricted hierarchies are used to represent values that

could take on several different but fixed types. In other lan-
guages, restricted hierarchies might be represented by sum

types, coproducts, or tagged unions.

```kotlin
sealed interface Result
class Success(val data: String) : Result
class Failure(val exception: Throwable) : Result
// or
sealed class Result
class Success(val data: String) : Result()
class Failure(val exception: Throwable) : Result()
```

- **`sealed`** 키워드를 붙이면 → **계층을 제한(restricted)**
- `sealed` 클래스/인터페이스는 **동일한 패키지 + 동일한 모듈** 안에서만 서브클래스 정의 가능.
- 따라서 라이브러리 사용자(client)는 새 서브클래스를 추가할 수 없음.
- Kotlin 컴파일러가 계층을 “닫힌(closed)” 것으로 인식 → `when` 분기에서 모든 경우를 exhaustively 체크 가능.

When we use the sealed modifier before a class, it
makes this class abstract already, so we don’t use
the abstract modifier.

There are a few requirements that all sealed class or interface
children must meet:
• they need to be defined in the same package and module
where the sealed class or interface is,
• they can’t be local or defined using object expression.

This means that when you use the sealed modifier, you con-
trol which subclasses a class or interface has. The clients 

of your library or module cannot add their own direct sub-
classes63. No one can quietly add a local class or object expres-
sion that extends a sealed class or interface. Kotlin has made

this impossible. The hierarchy of subclasses is restricted.

Sealed interfaces were introduced in more recent
versions of Kotlin to allow classes to implement
multiple sealed hierarchies. The relation between
a sealed class and a sealed interface is similar to the
relation between an abstract class and an interface.
The power of classes is that they can keep a state

(non-abstract properties) and control their mem-
bers’ openness (can have final methods and prop-
erties). The power of interfaces is that a class can

inherit from only one class but it can implement
multiple interfaces.

You could still declare an abstract class or an interface as
a part of a sealed hierarchy that the client would be able to
inherit from another module.

## 특징

- **sealed class**
    - 자동으로 `abstract`이므로 `abstract` 키워드를 따로 붙이지 않음.
    - 상태(프로퍼티)를 가질 수 있고, 멤버를 `final`, `open`, `abstract`로 제어 가능.
- **sealed interface**
    - 다중 구현(multiple inheritance)을 가능하게 함.
    - 클래스는 하나의 클래스만 상속 가능하지만, 여러 sealed 인터페이스는 동시에 구현 가능.

---

## 제약 조건

- 자식 클래스는 반드시:
    - 같은 **패키지** + **같은 모듈** 안에 정의돼야 함.
    - 로컬 클래스(함수 안)이나 `object expression`으로 정의할 수 없음.
- 이유: 외부에서 마음대로 서브클래스를 추가할 수 없게 막기 위함.

## 1. Sealed classes and when expressions

Using when as an expressionmust return some value, so itmust
be exhaustive. In most cases, the only way to achieve this is to
specify an else clause.

```kotlin
fun commentValue(value: String) = when {
		value.isEmpty() -> "Should not be empty"
		value.length < 5 -> "Too short"
		else -> "Correct"
}
fun main() {
		println(commentValue("")) // Should not be empty
		println(commentValue("ABC")) // Too short
		println(commentValue("ABCDEF")) // Correct
}
```

**when은 표현식(expression)** → 반드시 값을 반환해야함. 대부분 else 분기가 꼭 필요.

However, there are also cases in which Kotlin knows that we
have specified all possible values. For example, when we use
a when-expression with an enum value and we compare this
value to all possible enum values.

```kotlin
enum class PaymentType { CASH, CARD, CHECK }

fun commentDecision(type: PaymentType) = when (type) {
    PaymentType.CASH -> "I will pay with cash"
    PaymentType.CARD -> "I will pay with card"
    PaymentType.CHECK -> "I will pay with check"
    // else 필요 없음
}
```

enum처럼 **모든 경우의 수가 고정**돼 있으면 `else`가 필요 없음. 컴파일러가 모든 경우를 커버했는지 체크해줌.

The power of having a finite set of types as an argumentmakes
it possible to have an exhaustive when with a branch for every
possible value. In the case of sealed classes or interfaces, this
means having is checks for all possible subtypes.

```kotlin
sealed class Response<out V>
class Success<V>(val value: V) : Response<V>()
class Failure(val error: Throwable) : Response<Nothing>()

fun handle(response: Response<String>) {
    val text = when (response) {
        is Success -> "Success with ${response.value}"
        is Failure -> "Error"
        // else 필요 없음
    }
    print(text)
}
```

- sealed 클래스도 **닫힌 계층**이므로 모든 서브타입을 나열하면 `else` 필요 없음.
- → “exhaustive when” (모든 경우의 수를 빠짐없이 다루는 when).

Also, IntelliJ automatically suggests adding the remaining
branches. Thismakes sealed classes very convenient when we
need to cover all possible types.

<img width="543" height="187" alt="스크린샷 2025-08-26 오후 9 30 00" src="https://github.com/user-attachments/assets/5c71bf00-0ce3-4bfb-b2e0-f9fd17d02221" />


Note that when an else clause is not used and we add another
subclass of this sealed class, the usage needs to be adjusted
by including this new type. This is convenient in local code
as it forces us to handle this new class in exhaustive when
expressions. The inconvenient part is that when this sealed
class is part of the public API of a library or shared module,
adding a subtype is a breaking change because all modules
that use exhaustive when need to cover one more possible type.

## 장점과 주의점

- **장점**
    - 컴파일러가 모든 경우를 강제로 다루게 해줌 → 안전성 ↑
    - IntelliJ IDEA 등 IDE가 자동으로 **남은 분기 추가** 제안 → 생산성 ↑
- **주의점**
    - 만약 sealed 클래스에 **새로운 서브클래스**를 추가하면?
        - 기존 exhaustive when 구문은 **컴파일 에러** 발생 → 모든 분기를 수정해야 함.
        - 로컬 코드에서는 좋은 피드백(새 경우를 놓치지 않음).
        - 하지만 **라이브러리 공개 API**라면 → 사용자의 모든 코드가 깨질 수 있어 **호환성 문제(Breaking change)** 발생.

## 2. Sealed vs enum

Enum classes are used to represent a set of values. Sealed
classes or interfaces represent a set of subtypes that can be
made with classes or object declarations. This is a significant
difference. A class is more than a value. It can have many
instances and can be a data holder. Think of Response: if it
were an enum class, it couldn’t hold value or error. Sealed
subclasses can each store different data, whereas an enum is
just a set of values.

### Enum

- **목적**: 고정된 **값 집합** 표현 (ex: 요일, 결제 방식).
- 각 값은 단순한 상수(enum instance).
- 확장성 제한 → 값마다 서로 다른 데이터 구조를 가질 수 없음.

### Sealed Class / Interface

- **목적**: 고정된 **서브클래스 집합** 표현.
- 각 서브클래스는 **클래스/오브젝트**로 정의되며, **필드/상태**를 가질 수 있음.
- 예: `Success(data: String)` / `Failure(exception: Throwable)` 처럼 서로 다른 데이터 보관 가능.

👉 따라서 **enum = 값 집합**, **sealed = 타입(클래스) 집합**.

값만 필요하다면 enum, 데이터/행동이 다르다면 sealed가 적합.

## 3. Use cases

We use sealed classes whenever we want to express that there
is a concrete number of subclasses of a class.

```kotlin
sealed class MathOperation
class Plus(val left: Int, val right: Int) : MathOperation()
class Minus(val left: Int, val right: Int) : MathOperation()
class Times(val left: Int, val right: Int) : MathOperation()
class Divide(val left: Int, val right: Int) : MathOperation()

sealed interface Tree
class Leaf(val value: Any?) : Tree
class Node(val left: Tree, val right: Tree) : Tree
// Tree 타입은 반드시 Leaf 또는 Node.
// 재귀적 구조 표현에 적합.

sealed interface Either<out L, out R>
class Left<out L>(val value: L) : Either<L, Nothing>
class Right<out R>(val value: R) : Either<Nothing, R>
// 함수 결과가 성공/실패처럼 두 가지 의미만 가질 때 자주 사용.

sealed interface AdView
object FacebookAd : AdView
object GoogleAd : AdView
class OwnAd(val text: String, val imgUrl: String) : AdView
// 특정 집합으로만 고정된 구현체를 강제할 때.
```

The key benefit is that when-expression can easily cover

all possible types in a hierarchy using is-checks. A when-
condition with a sealed element as a value ensures the

compiler performs exhaustive type checking, and our
program can only represent valid states.

```kotlin
fun BinaryTree.height(): Int = when (this) {
    is Leaf -> 1
    is Node -> maxOf(this.left.height(), this.right.height())
}
```

However, expressing that a hierarchy is restricted improves
readability. Finally, when we use the sealed modifier, we can
use reflection to find all the subclasses:

```kotlin
sealed interface Parent
class A : Parent
class B : Parent
class C : Parent

fun main() {
    println(Parent::class.sealedSubclasses)
    // [class A, class B, class C]
}

```

sealed 클래스의 모든 서브타입을 리플렉션으로 가져올 수도 있음.

## 4. Summary

Sealed classes and interfaces should be used to represent re-
stricted hierarchies. The when-statement makes it easier to

handle each possible sealed subtype and, as a result, to add
new methods to sealed elements using extension functions.

Abstract classes leave space for new classes to join this hier-
archy. If we want to control what the subclasses of a class are,

we should use the sealed modifier.
Next, we will talk about the last special kind of class that
is used to add extra information about our code elements:
annotations.

- **enum**: 값 집합 (상태만 표현).
- **sealed class/interface**: 타입 집합 (서브클래스마다 데이터/행동 달리할 수 있음).
- 주요 장점:
    - **exhaustive when** → 타입 안전성 ↑
    - **표현 가능성** ↑ (각 서브클래스가 데이터/메서드 보유 가능)
- 주요 용도:
    - 네트워크 결과 (`Success`/`Failure`)
    - 수학 연산(`Plus`, `Minus` 등)
    - UI 상태(`Loading`, `Loaded`, `Error`)
    - 제한된 트리/데이터 구조

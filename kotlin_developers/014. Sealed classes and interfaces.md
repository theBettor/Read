Classes and interfaces in Kotlin are not only used to repre-
sent a set of operations or data; we can also use classes and

inheritance to represent hierarchies through polymorphism.
For instance, letâ€™s say that you send a network request; as
a result, you either successfully receive the requested data,
or the request fails with some information about what went
wrong. These two outcomes can be represented using two
classes that implement an interface:

```kotlin
interface Result
class Success(val data: String) : Result
class Failure(val exception: Throwable) : Result
```

- ì¼ë°˜ **interface**ë‚˜ **abstract class**ë¥¼ ì“°ë©´, ëˆ„êµ°ê°€ ë‹¤ë¥¸ ëª¨ë“ˆ/íŒŒì¼ì—ì„œ **ìƒˆë¡œìš´ ì„œë¸Œí´ë˜ìŠ¤**ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì¦‰, `Result`ë¼ëŠ” íƒ€ì…ì´ ìˆë”ë¼ë„ `Success`, `Failure` ë§ê³ ë„ ëˆ„êµ°ê°€ `FakeSuccess` ê°™ì€ ê²ƒì„ ì¶”ê°€í•  ìˆ˜ ìˆìŒ â†’ **ì—´ë¦° ê³„ì¸µ(Non-restricted hierarchy)**

Alternatively, you could use an abstract class:

```kotlin
abstract class Result
class Success(val data: String) : Result()
class Failure(val exception: Throwable) : Result()
```

With either of these, we know that when a function returns
Result, it can be Success or Failure.

```kotlin
val result: Result = getSomeData()
when (result) {
    is Success -> handleSuccess(result.data)
    is Failure -> handleFailure(result.exception)
    // else í•„ìš” ì—†ìŒ (sealedë¼ ëª¨ë“  ê²½ìš°ë¥¼ ì´ë¯¸ ì•Œê³  ìˆìŒ)
}
```

- **ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ê²°ê³¼**: `Success(data)` / `Failure(exception)`
- **UI ìƒíƒœ**: `Loading`, `Loaded`, `Error`
- **ë„ë©”ì¸ ì´ë²¤íŠ¸**: ì •í•´ì§„ ê²½ìš°ë§Œ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ ì§‘í•©

The problem is that when a regular interface or abstract class
is used, there is no guarantee that its defined subclasses are all
possible subtypes of this interface or abstract class. Someone
might define another class and make it implement Result.
Someone might also implement an object expression that
implements Result.

```kotlin
class FakeSuccess : Result
val res: Result = object : Result {}
```

A hierarchy whose subclasses are not known in advance is
known as a non-restricted hierarchy. For Result, we prefer to
define a restricted hierarchy, which we do by using a sealed
modifier before a class or an interface.

Restricted hierarchies are used to represent values that

could take on several different but fixed types. In other lan-
guages, restricted hierarchies might be represented by sum

types, coproducts, or tagged unions.

```kotlin
sealed interface Result
class Success(val data: String) : Result
class Failure(val exception: Throwable) : Result
// or
sealed class Result
class Success(val data: String) : Result()
class Failure(val exception: Throwable) : Result()
```

- **`sealed`** í‚¤ì›Œë“œë¥¼ ë¶™ì´ë©´ â†’ **ê³„ì¸µì„ ì œí•œ(restricted)**
- `sealed` í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤ëŠ” **ë™ì¼í•œ íŒ¨í‚¤ì§€ + ë™ì¼í•œ ëª¨ë“ˆ** ì•ˆì—ì„œë§Œ ì„œë¸Œí´ë˜ìŠ¤ ì •ì˜ ê°€ëŠ¥.
- ë”°ë¼ì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ì(client)ëŠ” ìƒˆ ì„œë¸Œí´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•  ìˆ˜ ì—†ìŒ.
- Kotlin ì»´íŒŒì¼ëŸ¬ê°€ ê³„ì¸µì„ â€œë‹«íŒ(closed)â€ ê²ƒìœ¼ë¡œ ì¸ì‹ â†’ `when` ë¶„ê¸°ì—ì„œ ëª¨ë“  ê²½ìš°ë¥¼ exhaustively ì²´í¬ ê°€ëŠ¥.

When we use the sealed modifier before a class, it
makes this class abstract already, so we donâ€™t use
the abstract modifier.

There are a few requirements that all sealed class or interface
children must meet:
â€¢ they need to be defined in the same package and module
where the sealed class or interface is,
â€¢ they canâ€™t be local or defined using object expression.

This means that when you use the sealed modifier, you con-
trol which subclasses a class or interface has. The clients 

of your library or module cannot add their own direct sub-
classes63. No one can quietly add a local class or object expres-
sion that extends a sealed class or interface. Kotlin has made

this impossible. The hierarchy of subclasses is restricted.

Sealed interfaces were introduced in more recent
versions of Kotlin to allow classes to implement
multiple sealed hierarchies. The relation between
a sealed class and a sealed interface is similar to the
relation between an abstract class and an interface.
The power of classes is that they can keep a state

(non-abstract properties) and control their mem-
bersâ€™ openness (can have final methods and prop-
erties). The power of interfaces is that a class can

inherit from only one class but it can implement
multiple interfaces.

You could still declare an abstract class or an interface as
a part of a sealed hierarchy that the client would be able to
inherit from another module.

## íŠ¹ì§•

- **sealed class**
    - ìë™ìœ¼ë¡œ `abstract`ì´ë¯€ë¡œ `abstract` í‚¤ì›Œë“œë¥¼ ë”°ë¡œ ë¶™ì´ì§€ ì•ŠìŒ.
    - ìƒíƒœ(í”„ë¡œí¼í‹°)ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³ , ë©¤ë²„ë¥¼ `final`, `open`, `abstract`ë¡œ ì œì–´ ê°€ëŠ¥.
- **sealed interface**
    - ë‹¤ì¤‘ êµ¬í˜„(multiple inheritance)ì„ ê°€ëŠ¥í•˜ê²Œ í•¨.
    - í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë§Œ ìƒì† ê°€ëŠ¥í•˜ì§€ë§Œ, ì—¬ëŸ¬ sealed ì¸í„°í˜ì´ìŠ¤ëŠ” ë™ì‹œì— êµ¬í˜„ ê°€ëŠ¥.

---

## ì œì•½ ì¡°ê±´

- ìì‹ í´ë˜ìŠ¤ëŠ” ë°˜ë“œì‹œ:
    - ê°™ì€ **íŒ¨í‚¤ì§€** + **ê°™ì€ ëª¨ë“ˆ** ì•ˆì— ì •ì˜ë¼ì•¼ í•¨.
    - ë¡œì»¬ í´ë˜ìŠ¤(í•¨ìˆ˜ ì•ˆ)ì´ë‚˜ `object expression`ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ì—†ìŒ.
- ì´ìœ : ì™¸ë¶€ì—ì„œ ë§ˆìŒëŒ€ë¡œ ì„œë¸Œí´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•  ìˆ˜ ì—†ê²Œ ë§‰ê¸° ìœ„í•¨.

## 1. Sealed classes and when expressions

Using when as an expressionmust return some value, so itmust
be exhaustive. In most cases, the only way to achieve this is to
specify an else clause.

```kotlin
fun commentValue(value: String) = when {
		value.isEmpty() -> "Should not be empty"
		value.length < 5 -> "Too short"
		else -> "Correct"
}
fun main() {
		println(commentValue("")) // Should not be empty
		println(commentValue("ABC")) // Too short
		println(commentValue("ABCDEF")) // Correct
}
```

**whenì€ í‘œí˜„ì‹(expression)** â†’ ë°˜ë“œì‹œ ê°’ì„ ë°˜í™˜í•´ì•¼í•¨. ëŒ€ë¶€ë¶„ else ë¶„ê¸°ê°€ ê¼­ í•„ìš”.

However, there are also cases in which Kotlin knows that we
have specified all possible values. For example, when we use
a when-expression with an enum value and we compare this
value to all possible enum values.

```kotlin
enum class PaymentType { CASH, CARD, CHECK }

fun commentDecision(type: PaymentType) = when (type) {
    PaymentType.CASH -> "I will pay with cash"
    PaymentType.CARD -> "I will pay with card"
    PaymentType.CHECK -> "I will pay with check"
    // else í•„ìš” ì—†ìŒ
}
```

enumì²˜ëŸ¼ **ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ê°€ ê³ ì •**ë¼ ìˆìœ¼ë©´ `else`ê°€ í•„ìš” ì—†ìŒ. ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë“  ê²½ìš°ë¥¼ ì»¤ë²„í–ˆëŠ”ì§€ ì²´í¬í•´ì¤Œ.

The power of having a finite set of types as an argumentmakes
it possible to have an exhaustive when with a branch for every
possible value. In the case of sealed classes or interfaces, this
means having is checks for all possible subtypes.

```kotlin
sealed class Response<out V>
class Success<V>(val value: V) : Response<V>()
class Failure(val error: Throwable) : Response<Nothing>()

fun handle(response: Response<String>) {
    val text = when (response) {
        is Success -> "Success with ${response.value}"
        is Failure -> "Error"
        // else í•„ìš” ì—†ìŒ
    }
    print(text)
}
```

- sealed í´ë˜ìŠ¤ë„ **ë‹«íŒ ê³„ì¸µ**ì´ë¯€ë¡œ ëª¨ë“  ì„œë¸Œíƒ€ì…ì„ ë‚˜ì—´í•˜ë©´ `else` í•„ìš” ì—†ìŒ.
- â†’ â€œexhaustive whenâ€ (ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ë¹ ì§ì—†ì´ ë‹¤ë£¨ëŠ” when).

Also, IntelliJ automatically suggests adding the remaining
branches. Thismakes sealed classes very convenient when we
need to cover all possible types.

<img width="543" height="187" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2025-08-26 á„‹á…©á„’á…® 9 30 00" src="https://github.com/user-attachments/assets/5c71bf00-0ce3-4bfb-b2e0-f9fd17d02221" />


Note that when an else clause is not used and we add another
subclass of this sealed class, the usage needs to be adjusted
by including this new type. This is convenient in local code
as it forces us to handle this new class in exhaustive when
expressions. The inconvenient part is that when this sealed
class is part of the public API of a library or shared module,
adding a subtype is a breaking change because all modules
that use exhaustive when need to cover one more possible type.

## ì¥ì ê³¼ ì£¼ì˜ì 

- **ì¥ì **
    - ì»´íŒŒì¼ëŸ¬ê°€ ëª¨ë“  ê²½ìš°ë¥¼ ê°•ì œë¡œ ë‹¤ë£¨ê²Œ í•´ì¤Œ â†’ ì•ˆì „ì„± â†‘
    - IntelliJ IDEA ë“± IDEê°€ ìë™ìœ¼ë¡œ **ë‚¨ì€ ë¶„ê¸° ì¶”ê°€** ì œì•ˆ â†’ ìƒì‚°ì„± â†‘
- **ì£¼ì˜ì **
    - ë§Œì•½ sealed í´ë˜ìŠ¤ì— **ìƒˆë¡œìš´ ì„œë¸Œí´ë˜ìŠ¤**ë¥¼ ì¶”ê°€í•˜ë©´?
        - ê¸°ì¡´ exhaustive when êµ¬ë¬¸ì€ **ì»´íŒŒì¼ ì—ëŸ¬** ë°œìƒ â†’ ëª¨ë“  ë¶„ê¸°ë¥¼ ìˆ˜ì •í•´ì•¼ í•¨.
        - ë¡œì»¬ ì½”ë“œì—ì„œëŠ” ì¢‹ì€ í”¼ë“œë°±(ìƒˆ ê²½ìš°ë¥¼ ë†“ì¹˜ì§€ ì•ŠìŒ).
        - í•˜ì§€ë§Œ **ë¼ì´ë¸ŒëŸ¬ë¦¬ ê³µê°œ API**ë¼ë©´ â†’ ì‚¬ìš©ìì˜ ëª¨ë“  ì½”ë“œê°€ ê¹¨ì§ˆ ìˆ˜ ìˆì–´ **í˜¸í™˜ì„± ë¬¸ì œ(Breaking change)** ë°œìƒ.

## 2. Sealed vs enum

Enum classes are used to represent a set of values. Sealed
classes or interfaces represent a set of subtypes that can be
made with classes or object declarations. This is a significant
difference. A class is more than a value. It can have many
instances and can be a data holder. Think of Response: if it
were an enum class, it couldnâ€™t hold value or error. Sealed
subclasses can each store different data, whereas an enum is
just a set of values.

### Enum

- **ëª©ì **: ê³ ì •ëœ **ê°’ ì§‘í•©** í‘œí˜„ (ex: ìš”ì¼, ê²°ì œ ë°©ì‹).
- ê° ê°’ì€ ë‹¨ìˆœí•œ ìƒìˆ˜(enum instance).
- í™•ì¥ì„± ì œí•œ â†’ ê°’ë§ˆë‹¤ ì„œë¡œ ë‹¤ë¥¸ ë°ì´í„° êµ¬ì¡°ë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ìŒ.

### Sealed Class / Interface

- **ëª©ì **: ê³ ì •ëœ **ì„œë¸Œí´ë˜ìŠ¤ ì§‘í•©** í‘œí˜„.
- ê° ì„œë¸Œí´ë˜ìŠ¤ëŠ” **í´ë˜ìŠ¤/ì˜¤ë¸Œì íŠ¸**ë¡œ ì •ì˜ë˜ë©°, **í•„ë“œ/ìƒíƒœ**ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŒ.
- ì˜ˆ: `Success(data: String)` / `Failure(exception: Throwable)` ì²˜ëŸ¼ ì„œë¡œ ë‹¤ë¥¸ ë°ì´í„° ë³´ê´€ ê°€ëŠ¥.

ğŸ‘‰ ë”°ë¼ì„œ **enum = ê°’ ì§‘í•©**, **sealed = íƒ€ì…(í´ë˜ìŠ¤) ì§‘í•©**.

ê°’ë§Œ í•„ìš”í•˜ë‹¤ë©´ enum, ë°ì´í„°/í–‰ë™ì´ ë‹¤ë¥´ë‹¤ë©´ sealedê°€ ì í•©.

## 3. Use cases

We use sealed classes whenever we want to express that there
is a concrete number of subclasses of a class.

```kotlin
sealed class MathOperation
class Plus(val left: Int, val right: Int) : MathOperation()
class Minus(val left: Int, val right: Int) : MathOperation()
class Times(val left: Int, val right: Int) : MathOperation()
class Divide(val left: Int, val right: Int) : MathOperation()

sealed interface Tree
class Leaf(val value: Any?) : Tree
class Node(val left: Tree, val right: Tree) : Tree
// Tree íƒ€ì…ì€ ë°˜ë“œì‹œ Leaf ë˜ëŠ” Node.
// ì¬ê·€ì  êµ¬ì¡° í‘œí˜„ì— ì í•©.

sealed interface Either<out L, out R>
class Left<out L>(val value: L) : Either<L, Nothing>
class Right<out R>(val value: R) : Either<Nothing, R>
// í•¨ìˆ˜ ê²°ê³¼ê°€ ì„±ê³µ/ì‹¤íŒ¨ì²˜ëŸ¼ ë‘ ê°€ì§€ ì˜ë¯¸ë§Œ ê°€ì§ˆ ë•Œ ìì£¼ ì‚¬ìš©.

sealed interface AdView
object FacebookAd : AdView
object GoogleAd : AdView
class OwnAd(val text: String, val imgUrl: String) : AdView
// íŠ¹ì • ì§‘í•©ìœ¼ë¡œë§Œ ê³ ì •ëœ êµ¬í˜„ì²´ë¥¼ ê°•ì œí•  ë•Œ.
```

The key benefit is that when-expression can easily cover

all possible types in a hierarchy using is-checks. A when-
condition with a sealed element as a value ensures the

compiler performs exhaustive type checking, and our
program can only represent valid states.

```kotlin
fun BinaryTree.height(): Int = when (this) {
    is Leaf -> 1
    is Node -> maxOf(this.left.height(), this.right.height())
}
```

However, expressing that a hierarchy is restricted improves
readability. Finally, when we use the sealed modifier, we can
use reflection to find all the subclasses:

```kotlin
sealed interface Parent
class A : Parent
class B : Parent
class C : Parent

fun main() {
    println(Parent::class.sealedSubclasses)
    // [class A, class B, class C]
}

```

sealed í´ë˜ìŠ¤ì˜ ëª¨ë“  ì„œë¸Œíƒ€ì…ì„ ë¦¬í”Œë ‰ì…˜ìœ¼ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ë„ ìˆìŒ.

## 4. Summary

Sealed classes and interfaces should be used to represent re-
stricted hierarchies. The when-statement makes it easier to

handle each possible sealed subtype and, as a result, to add
new methods to sealed elements using extension functions.

Abstract classes leave space for new classes to join this hier-
archy. If we want to control what the subclasses of a class are,

we should use the sealed modifier.
Next, we will talk about the last special kind of class that
is used to add extra information about our code elements:
annotations.

- **enum**: ê°’ ì§‘í•© (ìƒíƒœë§Œ í‘œí˜„).
- **sealed class/interface**: íƒ€ì… ì§‘í•© (ì„œë¸Œí´ë˜ìŠ¤ë§ˆë‹¤ ë°ì´í„°/í–‰ë™ ë‹¬ë¦¬í•  ìˆ˜ ìˆìŒ).
- ì£¼ìš” ì¥ì :
    - **exhaustive when** â†’ íƒ€ì… ì•ˆì „ì„± â†‘
    - **í‘œí˜„ ê°€ëŠ¥ì„±** â†‘ (ê° ì„œë¸Œí´ë˜ìŠ¤ê°€ ë°ì´í„°/ë©”ì„œë“œ ë³´ìœ  ê°€ëŠ¥)
- ì£¼ìš” ìš©ë„:
    - ë„¤íŠ¸ì›Œí¬ ê²°ê³¼ (`Success`/`Failure`)
    - ìˆ˜í•™ ì—°ì‚°(`Plus`, `Minus` ë“±)
    - UI ìƒíƒœ(`Loading`, `Loaded`, `Error`)
    - ì œí•œëœ íŠ¸ë¦¬/ë°ì´í„° êµ¬ì¡°

Take a look at the world around you and you will likely notice plenty of objects. It might be a book, an Ebook reader, a monitor, or a mug of coffee. We are surrounded by objects. This idea leads to the conclusion that we are living in a world of objects, therefore our programs should be constructed in the same way. This is the conceptual basis of the Object-Oriented Programming approach. Not everyone shares this worldview some prefer to see the world as a place of possible actions, which is the conceptual basis of the Functional Programming approach but whichever approach we prefer, classes and objects are important structures in Kotlin programming.

A class is a template that is used to create an object with concrete characteristics. To create a class in Kotlin, we use the class keyword followed by the name. This is literally all that is needed to create the simplest class because a class body is optional. To create an object, which is an instance of a class, we use the default constructor function, which is the class name and round brackets. Unlike in other languages like C++ or Java, we do not use the new keyword in Kotlin.

```kotlin
class A // Simplest class definition

fun main() {
	// object creation from a class
	val a: A = A()
	
	// javaë‚˜ c++ì—ëŠ” newê°€ í•„ìš”í•˜ë‹¤ê³ ..
}
```

## 1. Member functions

Inside classes, we can define functions. To do that, we first need to open braces in the class definition in order to specify the class body.

```kotlin
class A {
	// class body
}
```

Therefore, we can specify functions. Functions defined this way have two important characteristics:

- Functions need to be called on an instance of this class. This means that to call a method, an object needs to be created first.
- Inside methods, we can use this, which is a reference to the instance of the class we called this function on.

```kotlin
class A {
	fun printMe() {
		println(this)
	}
}

fun main() {
	val a = A()
	println(a) // A@ADDRESS
	a.printMe() // A@ADDRESS (the same address)
}
```

All the elements defined inside a class body are called members, so a function define inside a class body is called a member function. Functions that are associated with classes are called methods, so all member functions are methods, but extension functions(which will be covered in a later chapter) are methods too.

Conceptually speaking, methods represent what an objet can do. For instance, a coffee machine should be able to produce coffee, which we might represent by the method makeCoffe in the CoffeeMachine class. This is how classes with methods help us model the world.

## 2. Properties

Inside class bodies, we can also define variables. Variables defined inside classes are called fields. There is an important idea known as â€œencapsulationâ€ which means that fields should never be used directly from outside the class because if that happens, we lose control over their state. Instead, fields should be used through accessors:

- getter - the function that is used to get the current value of this field,
- setter - the function that is used to set new values for this field

This pattern is highly influential; in Java projects, you can see plenty of getter and setter functions, which are mainly used in classes that hold data. They are needed to achieve encapsulation, but they are also disturbing boilerplate code. So, language creators invented a more powerful concept called â€œpropertiesâ€. A property is a variable in a class that is automatically encapsulated so that it uses a getter and a setter under the hood. In Kotlin, all variables defined inside classes are properties, not fileds.

Some languages, like JavaScript, have built-in support for properties, but Java does not. So, in Kotlin/JVM, accessor functions are generated for each property : a getter for val, and a getter and a setter for var.

 

```kotlin
// Kotlin code

class User {
	var name: String = "" // í•„ë“œë¼ê³  ë¶€ë¦„
}

fun main(args: Array<String>) {
	val user = User()
	user.name = "Alex" // setter call
	println(user.name) // getter call
}
```

```jsx
// equivalent JavaScript code

function User() {
	this.name = '';
}

function main(args) {
	val user = new User();
	user.name = 'Alex';
	println(user.name);
}
```

```java
// equivalent Java code
public final class User {
	@NotNull
	private String name = "";

	// getter
	@NotNull
	public final String getName() {
		return this.name;
	}

	// setter
	public final void setName(@NotNull String name) {
		this.name = name;
	}
}

public final class PlaygroundKt {
	public static void main(String[] var0) {
		User user = new User();
		user.setName("Alex"); // setter call
		System.out.println(user.getName()); // getter call
	}
}
```

> í•„ë“œëŠ” í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ ì ‘ê·¼í•  ìˆ˜ëŠ” ìˆì§€ë§Œ, ê·¸ë ‡ê²Œ í•˜ë©´ ë‚´ë¶€ ìƒíƒœì— ëŒ€í•œ í†µì œê°€ ì–´ë ¤ì›Œì ¸ ì˜ˆê¸°ì¹˜ ì•Šì€ ë²„ê·¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ **ìº¡ìŠí™”**ë¥¼ ì ìš©í•´ í•„ë“œë¥¼ `private`ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ , Javaì—ì„œëŠ” **setterë¡œ ê°’ì„ í• ë‹¹í•˜ê³  getterë¡œ ê°’ì„ ì½ëŠ” ë°©ì‹**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
> 

> Kotlinì—ì„œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ getterì™€ setterë¥¼ ìƒì„±í•˜ì§€ë§Œ, í•„ìš”ì— ë”°ë¼ `get()`ê³¼ `set()`ì„ ì´ìš©í•´ **ì»¤ìŠ¤í„°ë§ˆì´ì§•**í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
> 

> Kotlinì—ì„œ `name`ê³¼ ê°™ì€ ë³€ìˆ˜ëŠ” ë‚´ë¶€ì ìœ¼ë¡œëŠ” ë©”ëª¨ë¦¬ì— ì¡´ì¬í•˜ëŠ” **field**ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ì™¸ë¶€ì—ì„œëŠ” **getter/setterë¥¼ í†µí•´ ì ‘ê·¼**í•˜ë¯€ë¡œ ì´ë¥¼ **property**ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.
> 

Each property in Kotlin has accessors, therefore we should not define getters or setters using explicit functions. If you want to change the default accessor, there is a special syntax for that.

```kotlin
class User() {
	private var name: String = ""
	
	// DO NOT DO THAT! DEFINE PROPERTY GETTER INSTEAD
	fun getName() = name
	
	// DO NOT DO THAT! DEFINE PROPERTY SETTER INSTEAD
	fun setName(name: String) {
		this.name = name
	}
}
```

To specify a custom getter, we use the get keyword after the property definition. The rest is equivalent to defining a function with no parameters. Inside this function, we use the field keyword to reference the backing field. The default getter returns the field value, but we can change this behavior so that this value is modified in some way before it is returned. When we define a getter, we can use single-expression syntax or a regular body and the return keyword.

```kotlin
class User {
	var name: String = ""
		get() = field.uppercase()
		// or
		//var name: String = ""
		//	get() {
		//		return field.uppercase()
		//	}
}

fun main() {
	val user = User()
	user.name = "norbert" // setter: ê·¸ëƒ¥ ì €ì¥ë¨
	println(user.name) // getter: field.uppercase() í˜¸ì¶œë¨ â†’ NORBERT
}
```

> fieldëŠ” í”„ë¡œí¼í‹°ê°€ ë‚´ë¶€ì ìœ¼ë¡œ ê°’ì„ ì €ì¥í•˜ëŠ” ê³µê°„ìœ¼ë¡œ, get()ì„ í†µí•´ ì˜¤ë²„ë¼ì´ë“œí•˜ë©´ì„œ fieldë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ StackOverflowErrorê°€ ë°œìƒí•œë‹¤.
> 

A getter must always have the same visibility and result type as the property. Getters should not throw exceptions and should not perform intensive calculations.

Beware that all property usages are accessorsâ€™ usages. Inside accessors, you should use field instead of the property name because, otherwise, you will likely end up with infinite recursion.

```kotlin
class User {
	// DON'T DO THAT
	var name: String = ""
		// Using property name inside getter
		// leads to infinitibe recursion
		get() = name.uppercase()
}

fun main() {
	val user = User()
	user.name = "norbert"
	println(user.name) // Error: java.lang.StackOverflowError
}

```

- ì´ `get()`ì—ì„œ `name`ì„ ì°¸ì¡°í•˜ê³  ìˆì£ ?
- ê·¸ëŸ°ë° `name` ìì²´ê°€ ì§€ê¸ˆ ì •ì˜ ì¤‘ì¸ **ê·¸ í”„ë¡œí¼í‹°**ì˜ˆìš”.

### ê·¸ëŸ¼ ì–´ë–»ê²Œ ë ê¹Œìš”?

- `user.name`ì„ í˜¸ì¶œí•˜ë©´ â†’ `get()`ì´ í˜¸ì¶œë¨
- `get()` ë‚´ë¶€ì—ì„œ ë˜ `name`ì„ í˜¸ì¶œ â†’ ë˜ `get()`ì´ í˜¸ì¶œë¨
- ë‹¤ì‹œ `get()` ë‚´ë¶€ì—ì„œ ë˜ `name` í˜¸ì¶œ â†’ ë˜ `get()` í˜¸ì¶œ...

- ì—¬ê¸°ì„œ `field`ëŠ” `name`ì´ë¼ëŠ” í”„ë¡œí¼í‹°ì˜ **ë°±í‚¹ í•„ë“œ(backing field)**ì…ë‹ˆë‹¤.
- `field`ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë‚´ë¶€ì ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” **ì§„ì§œ ì €ì¥ì†Œ**ì´ê³ ,
- `get()`ì´ë‚˜ `set()` ë‚´ë¶€ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.

Setters can be specified similarly, but we need to use the set keyword, and we need a single parameter that represents the value that is set. The default setter is used to assign a new value to the field, but we can modify this behavior, for instance, to set a new value only if it satisfies some conditions.

```kotlin
class User {
	var name: String = ""
		get() = field.uppercase()
		set(value) {
			if (value.isNotBlank()) {
				field = value
			}
		}
}

fun main() {
	val user = User()
	user.name = "norbert"  // âœ… "norbert"ëŠ” ê³µë°±ì´ ì•„ë‹ˆë¯€ë¡œ ì €ì¥ë¨
  user.name = ""         // âŒ ë¹ˆ ë¬¸ìì—´ â†’ ë¬´ì‹œ
  user.name = "  "       // âŒ ê³µë°± ë¬¸ìì—´ â†’ ë¬´ì‹œ
  println(user.name)     // ì¶œë ¥: NORBERT
}
```

Setters might have more restrictive visibility than properties, which we will show in the next chapter.

If a propertyâ€™s custom accessors do not use the field keyword, then the backing field will not be generated. For example, we can define a property to represent a full name that is calculated based on a name and surname. This means that some properties might not need a field at all.

```kotlin
class User {
	var name: String = ""
	var surname: String = ""
	val fullName: String
		get() = "$name $surname"
}

fun main() {
	val user = User()
	user.name = "Maja"
	user.surname = "Moskala"
	println(user.fullName) // Maja Moskala
}
```

Kotlinì—ì„œëŠ” í”„ë¡œí¼í‹°ë¥¼ ë§¤ë²ˆ ê³„ì‚°í•  ìˆ˜ ìˆë„ë¡ **backing field ì—†ì´ ì •ì˜**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŸ° ê³„ì‚°í˜• í”„ë¡œí¼í‹°ëŠ” **ê°’ì„ ì €ì¥í•˜ì§€ ì•Šê³ , ìƒí™©ì— ë”°ë¼ ìœ ë™ì ìœ¼ë¡œ ê²°ê³¼ë¥¼ ì œê³µ**í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.

â†’ ê³„ì‚°í˜• í”„ë¡œí¼í‹°ë¼ì„œ ê°’ì„ ë”°ë¡œ ì €ì¥í•´ë‘˜ í•„ìš”ê°€ ì—†ìœ¼ë‹ˆ, backing fieldë„ í•„ìš” ì—†ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.

The fullName property needs only a getter because it is a read-only val property. 33Whenever we ask for this propertyâ€™s value, a full name will be calculated based on the name and surname. Notice that this property is calculated on demand, which is an advantage over using a regular property.

```kotlin
class User(
	val name: String,
	val surname: String,
) {
	val fullName1: String
		get() = "$name $surname"
	val fullName2: String = "$name $surname"
}

fun main() {
	val user = User("Maja", "Markiewicz")
	println(user.fullName1) // ğŸ‘‰ "Maja Markiewicz"
	println(user.fullName2) // ğŸ‘‰ "Maja Markiewicz"

	user.surname = "MoskaÅ‚a"

	println(user.fullName1) // ğŸ‘‰ "Maja MoskaÅ‚a" â† í•­ìƒ ìµœì‹  ê°’!
	println(user.fullName2) // ğŸ‘‰ "Maja Markiewicz" â† ë³€ê²½ ì•ˆ ë¨!
}
```

`fullName1`ì€ í”„ë¡œí¼í‹°ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ `get()`ì´ ì‹¤í–‰ë˜ë¯€ë¡œ, `name`ê³¼ `surname`ì˜ ìµœì‹  ê°’ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì‚°í•´ ë°˜í™˜í•œë‹¤.

This difference is only visible when the values our property is based on are mutable; therefore, when we define an immutable object, either calculating the property value on the getter or during class creation should both produce the same result. The difference is in performance: we calculated constant property values during object creation, but getter values are calculated on demand every time they are asked for.

```kotlin
class Holder {
	val v1: Int get() = calculate("v1")
	val v2: Int = calculate("v2")
	
	private fun calculate(propertyName: String): Int {
		println("Calculating $propertyName")
		return 42
	}
}

fun main() {
	val h1 = Holder() 
	// ì¶œë ¥: Calculating v2
	// â†’ v2ëŠ” ìƒì„± ì‹œì ì— ê³„ì‚°ë¨
	// â†’ v1ì€ ì•„ì§ í˜¸ì¶œ ì•ˆ í–ˆìœ¼ë¯€ë¡œ ê³„ì‚° ì•ˆ ë¨

	val h2 = Holder()
	// ì¶œë ¥: Calculating v2

	println(h2.v1)
	// ì¶œë ¥: Calculating v1 â†’ 42

	println(h2.v1)
	// ì¶œë ¥: Calculating v1 â†’ 42 (ë§¤ë²ˆ ë‹¤ì‹œ ê³„ì‚°ë¨!)

	println(h2.v2)
	// ì¶œë ¥ ì—†ìŒ (ì´ë¯¸ ê³„ì‚°ëœ ê°’ ì‚¬ìš©) â†’ 42

	println(h2.v2)
	// ì¶œë ¥ ì—†ìŒ (í•œ ë²ˆ ê³„ì‚°ëœ ê°’ ì¬ì‚¬ìš©) â†’ 42
}
```

As another example, letâ€™s imagine we need to keep the useâ€™s birthdate. Initially, we represented it with Date from the Java Standard Library.

```kotlin
import java.util.Date

class User {
	// ...
	var birthdate: Date? = null
}
```

Time has passed, and Date is no longer a good way to represent this attribute. Maybe we have problems with serialization; maybe we need to make our objet multiplatform; or maybe we need to represent time in another calendar not supported by Date. So, weâ€™ve decided to use a different type instead of Date. Letâ€™s say that weâ€™ve decided to use a Long property to keep milliseconds, but we cannot get rid of the previous property because it is used by many other parts of our code. To have our cake and eat it, we can transform our birthdate property to fully depend on the new representation. This way, we have changed how the birthdate is represented without changing the previous usage.

```kotlin
class User {
	// ...
	var birthdateMillis: Long? = null // ë‚´ë¶€ ì €ì¥ìš© (ms ë‹¨ìœ„)
	
	var birthdate: Date? // ì™¸ë¶€ APIì™€ í˜¸í™˜ë˜ëŠ” ê°€ìƒ í•„ë“œ
		get() {
			val millis = birthdateMillis
			return if (millis == null) null else Date(millis)
		}
		set(value) {
			birthdateMillis = value?.time
		}
}
```

In the above getter, I use let and a constructor reference.

Such a birthdate property can also be defined as an extension function, which will be presented in the chapter Extensions.

- ì›ë˜ëŠ” Javaì˜ `Date` íƒ€ì…ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í–ˆì–´ìš”.
- ê·¸ëŸ°ë° ì´ì œëŠ” ë¬¸ì œë“¤ì´ ìƒê²¼ìŠµë‹ˆë‹¤:
    - ì§ë ¬í™”(Serialization)ì— ë¶ˆí¸í•¨
    - Kotlin Multiplatformì—ì„œ `Date`ëŠ” ì§€ì›ë˜ì§€ ì•ŠìŒ
    - ë‹¤ë¥¸ ë‹¬ë ¥ ì‹œìŠ¤í…œ(ìŒë ¥ ë“±)ì„ ì“°ê³  ì‹¶ì„ ìˆ˜ë„ ìˆìŒ

ê·¸ë˜ì„œ ì´ì œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `Long` íƒ€ì…(ë°€ë¦¬ì´ˆ ê¸°ì¤€ ì‹œê°„)ì„ ì‚¬ìš©í•˜ê¸°ë¡œ ê²°ì •í•©ë‹ˆë‹¤.

âŒ ì§ë ¬í™” ë¬¸ì œ

Kotlinx.serializationì´ë‚˜ Moshi, kotlinx-datetime ë“±ì—ì„œëŠ”Dateë¥¼ ê¸°ë³¸ì ìœ¼ë¡œ ì§€ì›í•˜ì§€ ì•ŠìŒ

`birthdate`ëŠ” ì™¸ë¶€ì—ì„œëŠ” ì—¬ì „íˆ `Date` íƒ€ì…ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ, ì‹¤ì œë¡œëŠ” ë‚´ë¶€ì—ì„œ `birthdateMillis`ë¼ëŠ” Long íƒ€ì…ìœ¼ë¡œ ì €ì¥í•˜ê³ , getter/setterë¥¼ í†µí•´ **Dateì™€ ë°€ë¦¬ì´ˆ(Long) ê°„ ë³€í™˜ì„ ìë™ ì²˜ë¦¬**í•¨ìœ¼ë¡œì¨ ê¸°ì¡´ APIì˜ í˜¸í™˜ì„±ê³¼ ìƒˆë¡œìš´ êµ¬í˜„ì˜ ìœ ì—°ì„±ì„ ëª¨ë‘ ë§Œì¡±ì‹œí‚¨ ê³„ì‚°í˜• í”„ë¡œí¼í‹°ì´ë‹¤.

## 3. Constructors

When we create an object, we often want to initialize it with specific values. This is what we use constructors for. As weâ€™ve seen already, when no constructors are specified, an empty default constructor is generated with no parameter.

```kotlin
class A

val a = A()
```

To specify our custom constructor, the classic way is to use the constructor keyword inside the class body, and then we define its parameter and body.

```kotlin
class User {
	var name: String = ""
	var surname: String = ""
	
	constructor(name: String, surname: String) {
		this.name = name
		this.surname = surname
	}
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

Constructors are typically used to set initial values of our properties. To simplify this, Kotlin introduced a special kind of constructor called the primary constructor. It is defined just after the class name, and its parameters can be used during the initialization of properties.

```kotlin
class User constructor(name: String, surname: String) {
	var name : String = name
	var surname: String = surname
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

When we specify a primary constructor, use of the constructor keyword is optional, so we can just skip it.

```kotlin
class User(name: String, surname: String) {
	// ìœ„ì˜ ì½”ë“œì™€ ë‹¤ë¥´ê²Œ constructorê°€ ìƒëµë„ ê°€ëŠ¥í•˜ë‹¤.
	var name : String = name
	var surname: String = surname
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johhny
	println(user.surname) // Depp
}
```

There can be only one primary constructor. We can define another constructor, called secondary constructor, but it needs to call the primary constructor using the this keyword.

```kotlin
class User(name: String, surname: String) {
	var name: String = name
	var surname: String = surname
	
	// ë³´ì¡° ìƒì„±ì (User ê°ì²´ë¥¼ ë°›ì•„ì„œ ë³µì‚¬ ìƒì„±)
	constructor(user: User) : this(user.name, user.surname) {
		// optional body
	}
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
	
	val user2 = User(user) // ë³´ì¡° ìƒì„±ì í˜¸ì¶œ â†’ this(user.name, user.surname)
	println(user2.name) // Johnny
	println(user2.surname) // Depp
	
	// ì¦‰, user2ëŠ” userì˜ ê°’ì„ ê·¸ëŒ€ë¡œ ë³µì‚¬í•´ì„œ ìƒˆ ê°ì²´ë¡œ ë§Œë“  ê²ƒì…ë‹ˆë‹¤.
}
```

ğŸ‘‰Â : this(...)

ë³´ì¡° ìƒì„±ìëŠ” ë°˜ë“œì‹œ í´ë˜ìŠ¤ì˜ **ë‹¤ë¥¸ ìƒì„±ì(ë³´í†µ primary)**ë¥¼ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

| ìƒí™© | ì˜ˆì‹œ |
| --- | --- |
| ê¸°ì¡´ ê°ì²´ë¥¼ ë³µì‚¬í•˜ê³  ì‹¶ì„ ë•Œ | `constructor(user: User)` |
| ë””í´íŠ¸ ê°’ ì™¸ì— ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  ì‹¶ì„ ë•Œ | `constructor(email: String)` ë“± |
| ì™¸ë¶€ì—ì„œ ì£¼ì–´ì§€ëŠ” ë°ì´í„° í˜•íƒœê°€ ë‹¤ë¥¸ ê²½ìš° | `constructor(json: JSONObject)` |

The primary constructor is typically used to specify initial values for our properties. These properties often have the same names as other parameter, so Kotlin introduced better supprot for this: we can define properties inside the primary constructor. Such properties define a class property and a constructor parameter, both of which have the same name.

```kotlin
class User(
	var name: Strirng,
	var surname: String
	
	// var ë˜ëŠ” valì„ ìƒì„±ì íŒŒë¼ë¯¸í„°ì— ë¶™ì´ë©´, í´ë˜ìŠ¤ í”„ë¡œí¼í‹° ì„ ì–¸ê³¼ ìƒì„±ì ì´ˆê¸°í™”ê°€ ë™ì‹œì— ì´ë£¨ì–´ì ¸, ë” ê°„ê²°í•˜ê³  ëª…í™•í•œ Kotlin ìŠ¤íƒ€ì¼ì˜ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
) {
		// optional body
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

Ths is how the vast majority of Kotlin classes are defined: using a primary constructor with properties. We rarely use other kinds of constructors.

We often define primary. constructors with default values. Here, we create na instance of User without providing the surname argument, so the default value we specified will be used during User creation.

```kotlin
class User(
	var name: String = "",
	var surname: String = "Anonim",
)

fun main() {
	var user = User("Johnny")
	println(user.name) // Johnny
	println(user.surname) // Anonim
}
```

## 4. Classes representing data in Kotlin and Java

When comparing classes defined in Kotlin and Java, we can see how much boilerplate code Kotlin has eliminated. In Java, to represent a simple user, with a name, surname, and age, the typical implementation looks as follows:

```java
public final class User {
	@NotNull 
	private final String name;
	@NotNull 
	private final String surname;
	private final int age;

	public User(
		@NotNull String name,
		@NotNull String surname,
		int age
	) {
		this.name = name;
		this.surname = surname;
		this.age = age;
	}

	@NotNull
	public String getName() {
		return name;
	}
	@NotNull
	public String getSurname() {
		return surname;
	}
	public int getAge() {
		return age;
	}
}
```

In Kotlin, we represent the same class in the following way:

```kotlin
class User(
	val name: String,
	val surname: String,
	val age: Int?,
)
```

The result of the compilation is practically the same. Getters and constructors are there. Kotlin is a concise but powerful language.

## 5. Inner classes

In Kotlin, we can define classes inside classes. They are static by default, which means that they do not have access to outer classes; therefore they can be created without a reference to an outer class.

```kotlin
class Puppy(val name: String) {
	class InnerPuppy {
		fun think() {
			// we have no access to name here
			println("Inner puppy is thinking")
		}
	}
}

fun main() {
	val innerPuppy = Puppy.InnerPuppy()
	// We create InnerPuppy on class, not object
	innerPuppy.think() // Inner puppy is thinking
}
```

If you want your inner class to have a reference to its outer class, you need to make it inner using the inner modifier. However, creating objects from such classes requires an instance of the outer class.

```kotlin
class Puppy(val name: String) {
	inner class InnerPuppy {
		fun think() {
			println("Inner $name is thinking")
		}
	}
}

fun main() {
	val puppy = Puppy("Cookie")
	val innerPuppy = puppy.InnerPuppy() // We need puppy 
	innerPuppy.think() // Inner Cookie is thinking
}
```

Example of inner classes in the standard library are:

- private implementations of iterators;
- classes, where there is a close association between the outer class and the inner class, and the inner class is used to not define another name in the library namespace.

```kotlin
// A class from Kotlin stdlib
class FileTreeWalk(
    // ...
) : Sequence<File> {
    /** Returns an iterator walking through files. */
    override fun iterator(): Iterator<File> =
        FileTreeWalkIterator()  // ì™¸ë¶€ì—ì„œ í˜¸ì¶œë˜ëŠ” ì´í„°ë ˆì´í„° ë°˜í™˜

    private inner class FileTreeWalkIterator
        : AbstractIterator<File>() {  // ì‹¤ì œ ì´í„°ë ˆì´í„° êµ¬í˜„
        // ì´ê³³ì—ì„œ íŒŒì¼ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ êµ¬í˜„
        }
}
```

### ğŸ§© ì„¤ëª…

- `FileTreeWalk`ëŠ” **íŒŒì¼ì„ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” í´ë˜ìŠ¤**ì…ë‹ˆë‹¤.
- `iterator()` ë©”ì„œë“œëŠ” **`FileTreeWalkIterator`*ë¼ëŠ” **ë‚´ë¶€ ì´í„°ë ˆì´í„°** ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
- *`FileTreeWalkIterator`*ëŠ” `FileTreeWalk` í´ë˜ìŠ¤ì˜ **ë‚´ë¶€ í´ë˜ìŠ¤**ë¡œ ì„ ì–¸ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

### **ë‚´ë¶€ í´ë˜ìŠ¤ ì‚¬ìš© ì´ìœ :**

1. *`FileTreeWalkIterator`*ëŠ” `FileTreeWalk`ì™€ ë§¤ìš° ë°€ì ‘í•œ ê´€ê³„ê°€ ìˆìŠµë‹ˆë‹¤.
    - ì™¸ë¶€ í´ë˜ìŠ¤ì¸ `FileTreeWalk`ì˜ ìƒíƒœë‚˜ í•„ë“œì— ì ‘ê·¼í•  ìˆ˜ ìˆì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì— **ë‚´ë¶€ í´ë˜ìŠ¤**ë¡œ ì •ì˜ëœ ê²ƒì…ë‹ˆë‹¤.
2. ì™¸ë¶€ì—ì„œ ì´ ì´í„°ë ˆì´í„°ë¥¼ ì‚¬ìš©í•  ë•Œ, ë³„ë„ë¡œ **ìƒˆë¡œìš´ ì´ë¦„**ì„ ì •ì˜í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
    - `FileTreeWalkIterator`ëŠ” `FileTreeWalk`ì— ë‚´ë¶€ì ìœ¼ë¡œ ì¡´ì¬í•˜ëŠ” ì´í„°ë ˆì´í„°ë¡œ, ì™¸ë¶€ì—ì„œëŠ” `FileTreeWalk`ë§Œ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

### `private inner class`ì˜ ì˜ë¯¸

- `private inner class`ëŠ” **`FileTreeWalk` í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡** **ìˆ¨ê²¨ì§„(private)** ë‚´ë¶€ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
- ì´ ë‚´ë¶€ í´ë˜ìŠ¤ëŠ” **`FileTreeWalk`ì˜ ê°ì²´ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥**í•©ë‹ˆë‹¤. ë”°ë¼ì„œ **ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ì„œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ê³ , `FileTreeWalk`ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ì„œë§Œ ì‚¬ìš©**ë©ë‹ˆë‹¤.

## â–¶ ì‹¤ì œ ë™ì‘ íë¦„

1. `FileTreeWalk` ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
2. `iterator()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ `FileTreeWalkIterator`ë¥¼ ìƒì„±í•˜ê³  ë°˜í™˜ë°›ìŠµë‹ˆë‹¤.
3. `FileTreeWalkIterator`ëŠ” íŒŒì¼ì„ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.

## 6. Summary

As you can see, in Kotlin we can define classes using really concise syntax, and the result is very readable. The primary constructor is an amazing invention, as is the fact that Kotlin uses properties instead of fields. You have also learned about inner classes. This is all great, but we havenâ€™t yet touched on inheritance, which is so important for developers who like Object-Oriented style. We will discuss this along with interfaces and abstract classes in the next chapter

Take a look at the world around you and you will likely notice plenty of objects. It might be a book, an Ebook reader, a monitor, or a mug of coffee. We are surrounded by objects. This idea leads to the conclusion that we are living in a world of objects, therefore our programs should be constructed in the same way. This is the conceptual basis of the Object-Oriented Programming approach. Not everyone shares this worldview some prefer to see the world as a place of possible actions, which is the conceptual basis of the Functional Programming approach but whichever approach we prefer, classes and objects are important structures in Kotlin programming.

A class is a template that is used to create an object with concrete characteristics. To create a class in Kotlin, we use the class keyword followed by the name. This is literally all that is needed to create the simplest class because a class body is optional. To create an object, which is an instance of a class, we use the default constructor function, which is the class name and round brackets. Unlike in other languages like C++ or Java, we do not use the new keyword in Kotlin.

```kotlin
class A // Simplest class definition

fun main() {
	// object creation from a class
	val a: A = A()
	
	// java나 c++에는 new가 필요하다고..
}
```

## 1. Member functions

Inside classes, we can define functions. To do that, we first need to open braces in the class definition in order to specify the class body.

```kotlin
class A {
	// class body
}
```

Therefore, we can specify functions. Functions defined this way have two important characteristics:

- Functions need to be called on an instance of this class. This means that to call a method, an object needs to be created first.
- Inside methods, we can use this, which is a reference to the instance of the class we called this function on.

```kotlin
class A {
	fun printMe() {
		println(this)
	}
}

fun main() {
	val a = A()
	println(a) // A@ADDRESS
	a.printMe() // A@ADDRESS (the same address)
}
```

All the elements defined inside a class body are called members, so a function define inside a class body is called a member function. Functions that are associated with classes are called methods, so all member functions are methods, but extension functions(which will be covered in a later chapter) are methods too.

Conceptually speaking, methods represent what an objet can do. For instance, a coffee machine should be able to produce coffee, which we might represent by the method makeCoffe in the CoffeeMachine class. This is how classes with methods help us model the world.

## 2. Properties

Inside class bodies, we can also define variables. Variables defined inside classes are called fields. There is an important idea known as “encapsulation” which means that fields should never be used directly from outside the class because if that happens, we lose control over their state. Instead, fields should be used through accessors:

- getter - the function that is used to get the current value of this field,
- setter - the function that is used to set new values for this field

This pattern is highly influential; in Java projects, you can see plenty of getter and setter functions, which are mainly used in classes that hold data. They are needed to achieve encapsulation, but they are also disturbing boilerplate code. So, language creators invented a more powerful concept called “properties”. A property is a variable in a class that is automatically encapsulated so that it uses a getter and a setter under the hood. In Kotlin, all variables defined inside classes are properties, not fileds.

Some languages, like JavaScript, have built-in support for properties, but Java does not. So, in Kotlin/JVM, accessor functions are generated for each property : a getter for val, and a getter and a setter for var.

 

```kotlin
// Kotlin code

class User {
	var name: String = "" // 필드라고 부름
}

fun main(args: Array<String>) {
	val user = User()
	user.name = "Alex" // setter call
	println(user.name) // getter call
}
```

```jsx
// equivalent JavaScript code

function User() {
	this.name = '';
}

function main(args) {
	val user = new User();
	user.name = 'Alex';
	println(user.name);
}
```

```java
// equivalent Java code
public final class User {
	@NotNull
	private String name = "";

	// getter
	@NotNull
	public final String getName() {
		return this.name;
	}

	// setter
	public final void setName(@NotNull String name) {
		this.name = name;
	}
}

public final class PlaygroundKt {
	public static void main(String[] var0) {
		User user = new User();
		user.setName("Alex"); // setter call
		System.out.println(user.getName()); // getter call
	}
}
```

> 필드는 클래스 외부에서 접근할 수는 있지만, 그렇게 하면 내부 상태에 대한 통제가 어려워져 예기치 않은 버그가 발생할 수 있습니다. 이를 방지하기 위해 **캡슐화**를 적용해 필드를 `private`으로 처리하고, Java에서는 **setter로 값을 할당하고 getter로 값을 읽는 방식**을 사용합니다.
> 

> Kotlin에서는 컴파일러가 자동으로 getter와 setter를 생성하지만, 필요에 따라 `get()`과 `set()`을 이용해 **커스터마이징**할 수도 있습니다.
> 

> Kotlin에서 `name`과 같은 변수는 내부적으로는 메모리에 존재하는 **field**를 사용하지만, 외부에서는 **getter/setter를 통해 접근**하므로 이를 **property**라고 부릅니다.
> 

Each property in Kotlin has accessors, therefore we should not define getters or setters using explicit functions. If you want to change the default accessor, there is a special syntax for that.

```kotlin
class User() {
	private var name: String = ""
	
	// DO NOT DO THAT! DEFINE PROPERTY GETTER INSTEAD
	fun getName() = name
	
	// DO NOT DO THAT! DEFINE PROPERTY SETTER INSTEAD
	fun setName(name: String) {
		this.name = name
	}
}
```

To specify a custom getter, we use the get keyword after the property definition. The rest is equivalent to defining a function with no parameters. Inside this function, we use the field keyword to reference the backing field. The default getter returns the field value, but we can change this behavior so that this value is modified in some way before it is returned. When we define a getter, we can use single-expression syntax or a regular body and the return keyword.

```kotlin
class User {
	var name: String = ""
		get() = field.uppercase()
		// or
		//var name: String = ""
		//	get() {
		//		return field.uppercase()
		//	}
}

fun main() {
	val user = User()
	user.name = "norbert" // setter: 그냥 저장됨
	println(user.name) // getter: field.uppercase() 호출됨 → NORBERT
}
```

> field는 프로퍼티가 내부적으로 값을 저장하는 공간으로, get()을 통해 오버라이드하면서 field를 사용하지 않으면 StackOverflowError가 발생한다.
> 

A getter must always have the same visibility and result type as the property. Getters should not throw exceptions and should not perform intensive calculations.

Beware that all property usages are accessors’ usages. Inside accessors, you should use field instead of the property name because, otherwise, you will likely end up with infinite recursion.

```kotlin
class User {
	// DON'T DO THAT
	var name: String = ""
		// Using property name inside getter
		// leads to infinitibe recursion
		get() = name.uppercase()
}

fun main() {
	val user = User()
	user.name = "norbert"
	println(user.name) // Error: java.lang.StackOverflowError
}

```

- 이 `get()`에서 `name`을 참조하고 있죠?
- 그런데 `name` 자체가 지금 정의 중인 **그 프로퍼티**예요.

### 그럼 어떻게 될까요?

- `user.name`을 호출하면 → `get()`이 호출됨
- `get()` 내부에서 또 `name`을 호출 → 또 `get()`이 호출됨
- 다시 `get()` 내부에서 또 `name` 호출 → 또 `get()` 호출...

- 여기서 `field`는 `name`이라는 프로퍼티의 **백킹 필드(backing field)**입니다.
- `field`는 컴파일러가 내부적으로 만들어주는 **진짜 저장소**이고,
- `get()`이나 `set()` 내부에서만 접근 가능합니다.

Setters can be specified similarly, but we need to use the set keyword, and we need a single parameter that represents the value that is set. The default setter is used to assign a new value to the field, but we can modify this behavior, for instance, to set a new value only if it satisfies some conditions.

```kotlin
class User {
	var name: String = ""
		get() = field.uppercase()
		set(value) {
			if (value.isNotBlank()) {
				field = value
			}
		}
}

fun main() {
	val user = User()
	user.name = "norbert"  // ✅ "norbert"는 공백이 아니므로 저장됨
  user.name = ""         // ❌ 빈 문자열 → 무시
  user.name = "  "       // ❌ 공백 문자열 → 무시
  println(user.name)     // 출력: NORBERT
}
```

Setters might have more restrictive visibility than properties, which we will show in the next chapter.

If a property’s custom accessors do not use the field keyword, then the backing field will not be generated. For example, we can define a property to represent a full name that is calculated based on a name and surname. This means that some properties might not need a field at all.

```kotlin
class User {
	var name: String = ""
	var surname: String = ""
	val fullName: String
		get() = "$name $surname"
}

fun main() {
	val user = User()
	user.name = "Maja"
	user.surname = "Moskala"
	println(user.fullName) // Maja Moskala
}
```

Kotlin에서는 프로퍼티를 매번 계산할 수 있도록 **backing field 없이 정의**할 수 있습니다.

이런 계산형 프로퍼티는 **값을 저장하지 않고, 상황에 따라 유동적으로 결과를 제공**하는 데 유용합니다.

→ 계산형 프로퍼티라서 값을 따로 저장해둘 필요가 없으니, backing field도 필요 없다는 뜻입니다.

The fullName property needs only a getter because it is a read-only val property. 33Whenever we ask for this property’s value, a full name will be calculated based on the name and surname. Notice that this property is calculated on demand, which is an advantage over using a regular property.

```kotlin
class User(
	val name: String,
	val surname: String,
) {
	val fullName1: String
		get() = "$name $surname"
	val fullName2: String = "$name $surname"
}

fun main() {
	val user = User("Maja", "Markiewicz")
	println(user.fullName1) // 👉 "Maja Markiewicz"
	println(user.fullName2) // 👉 "Maja Markiewicz"

	user.surname = "Moskała"

	println(user.fullName1) // 👉 "Maja Moskała" ← 항상 최신 값!
	println(user.fullName2) // 👉 "Maja Markiewicz" ← 변경 안 됨!
}
```

`fullName1`은 프로퍼티가 호출될 때마다 `get()`이 실행되므로, `name`과 `surname`의 최신 값을 실시간으로 계산해 반환한다.

This difference is only visible when the values our property is based on are mutable; therefore, when we define an immutable object, either calculating the property value on the getter or during class creation should both produce the same result. The difference is in performance: we calculated constant property values during object creation, but getter values are calculated on demand every time they are asked for.

```kotlin
class Holder {
	val v1: Int get() = calculate("v1")
	val v2: Int = calculate("v2")
	
	private fun calculate(propertyName: String): Int {
		println("Calculating $propertyName")
		return 42
	}
}

fun main() {
	val h1 = Holder() 
	// 출력: Calculating v2
	// → v2는 생성 시점에 계산됨
	// → v1은 아직 호출 안 했으므로 계산 안 됨

	val h2 = Holder()
	// 출력: Calculating v2

	println(h2.v1)
	// 출력: Calculating v1 → 42

	println(h2.v1)
	// 출력: Calculating v1 → 42 (매번 다시 계산됨!)

	println(h2.v2)
	// 출력 없음 (이미 계산된 값 사용) → 42

	println(h2.v2)
	// 출력 없음 (한 번 계산된 값 재사용) → 42
}
```

As another example, let’s imagine we need to keep the use’s birthdate. Initially, we represented it with Date from the Java Standard Library.

```kotlin
import java.util.Date

class User {
	// ...
	var birthdate: Date? = null
}
```

Time has passed, and Date is no longer a good way to represent this attribute. Maybe we have problems with serialization; maybe we need to make our objet multiplatform; or maybe we need to represent time in another calendar not supported by Date. So, we’ve decided to use a different type instead of Date. Let’s say that we’ve decided to use a Long property to keep milliseconds, but we cannot get rid of the previous property because it is used by many other parts of our code. To have our cake and eat it, we can transform our birthdate property to fully depend on the new representation. This way, we have changed how the birthdate is represented without changing the previous usage.

```kotlin
class User {
	// ...
	var birthdateMillis: Long? = null // 내부 저장용 (ms 단위)
	
	var birthdate: Date? // 외부 API와 호환되는 가상 필드
		get() {
			val millis = birthdateMillis
			return if (millis == null) null else Date(millis)
		}
		set(value) {
			birthdateMillis = value?.time
		}
}
```

In the above getter, I use let and a constructor reference.

Such a birthdate property can also be defined as an extension function, which will be presented in the chapter Extensions.

- 원래는 Java의 `Date` 타입을 그대로 사용했어요.
- 그런데 이제는 문제들이 생겼습니다:
    - 직렬화(Serialization)에 불편함
    - Kotlin Multiplatform에서 `Date`는 지원되지 않음
    - 다른 달력 시스템(음력 등)을 쓰고 싶을 수도 있음

그래서 이제는 내부적으로 `Long` 타입(밀리초 기준 시간)을 사용하기로 결정합니다.

❌ 직렬화 문제

Kotlinx.serialization이나 Moshi, kotlinx-datetime 등에서는Date를 기본적으로 지원하지 않음

`birthdate`는 외부에서는 여전히 `Date` 타입처럼 보이지만, 실제로는 내부에서 `birthdateMillis`라는 Long 타입으로 저장하고, getter/setter를 통해 **Date와 밀리초(Long) 간 변환을 자동 처리**함으로써 기존 API의 호환성과 새로운 구현의 유연성을 모두 만족시킨 계산형 프로퍼티이다.

## 3. Constructors

When we create an object, we often want to initialize it with specific values. This is what we use constructors for. As we’ve seen already, when no constructors are specified, an empty default constructor is generated with no parameter.

```kotlin
class A

val a = A()
```

To specify our custom constructor, the classic way is to use the constructor keyword inside the class body, and then we define its parameter and body.

```kotlin
class User {
	var name: String = ""
	var surname: String = ""
	
	constructor(name: String, surname: String) {
		this.name = name
		this.surname = surname
	}
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

Constructors are typically used to set initial values of our properties. To simplify this, Kotlin introduced a special kind of constructor called the primary constructor. It is defined just after the class name, and its parameters can be used during the initialization of properties.

```kotlin
class User constructor(name: String, surname: String) {
	var name : String = name
	var surname: String = surname
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

When we specify a primary constructor, use of the constructor keyword is optional, so we can just skip it.

```kotlin
class User(name: String, surname: String) {
	// 위의 코드와 다르게 constructor가 생략도 가능하다.
	var name : String = name
	var surname: String = surname
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johhny
	println(user.surname) // Depp
}
```

There can be only one primary constructor. We can define another constructor, called secondary constructor, but it needs to call the primary constructor using the this keyword.

```kotlin
class User(name: String, surname: String) {
	var name: String = name
	var surname: String = surname
	
	// 보조 생성자 (User 객체를 받아서 복사 생성)
	constructor(user: User) : this(user.name, user.surname) {
		// optional body
	}
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
	
	val user2 = User(user) // 보조 생성자 호출 → this(user.name, user.surname)
	println(user2.name) // Johnny
	println(user2.surname) // Depp
	
	// 즉, user2는 user의 값을 그대로 복사해서 새 객체로 만든 것입니다.
}
```

👉 : this(...)

보조 생성자는 반드시 클래스의 **다른 생성자(보통 primary)**를 호출해야 합니다.

| 상황 | 예시 |
| --- | --- |
| 기존 객체를 복사하고 싶을 때 | `constructor(user: User)` |
| 디폴트 값 외에 다른 방식으로 초기화하고 싶을 때 | `constructor(email: String)` 등 |
| 외부에서 주어지는 데이터 형태가 다른 경우 | `constructor(json: JSONObject)` |

The primary constructor is typically used to specify initial values for our properties. These properties often have the same names as other parameter, so Kotlin introduced better supprot for this: we can define properties inside the primary constructor. Such properties define a class property and a constructor parameter, both of which have the same name.

```kotlin
class User(
	var name: Strirng,
	var surname: String
	
	// var 또는 val을 생성자 파라미터에 붙이면, 클래스 프로퍼티 선언과 생성자 초기화가 동시에 이루어져, 더 간결하고 명확한 Kotlin 스타일의 클래스를 만들 수 있다.
) {
		// optional body
}

fun main() {
	val user = User("Johnny", "Depp")
	println(user.name) // Johnny
	println(user.surname) // Depp
}
```

Ths is how the vast majority of Kotlin classes are defined: using a primary constructor with properties. We rarely use other kinds of constructors.

We often define primary. constructors with default values. Here, we create na instance of User without providing the surname argument, so the default value we specified will be used during User creation.

```kotlin
class User(
	var name: String = "",
	var surname: String = "Anonim",
)

fun main() {
	var user = User("Johnny")
	println(user.name) // Johnny
	println(user.surname) // Anonim
}
```

## 4. Classes representing data in Kotlin and Java

When comparing classes defined in Kotlin and Java, we can see how much boilerplate code Kotlin has eliminated. In Java, to represent a simple user, with a name, surname, and age, the typical implementation looks as follows:

```java
public final class User {
	@NotNull 
	private final String name;
	@NotNull 
	private final String surname;
	private final int age;

	public User(
		@NotNull String name,
		@NotNull String surname,
		int age
	) {
		this.name = name;
		this.surname = surname;
		this.age = age;
	}

	@NotNull
	public String getName() {
		return name;
	}
	@NotNull
	public String getSurname() {
		return surname;
	}
	public int getAge() {
		return age;
	}
}
```

In Kotlin, we represent the same class in the following way:

```kotlin
class User(
	val name: String,
	val surname: String,
	val age: Int?,
)
```

The result of the compilation is practically the same. Getters and constructors are there. Kotlin is a concise but powerful language.

## 5. Inner classes

In Kotlin, we can define classes inside classes. They are static by default, which means that they do not have access to outer classes; therefore they can be created without a reference to an outer class.

```kotlin
class Puppy(val name: String) {
	class InnerPuppy {
		fun think() {
			// we have no access to name here
			println("Inner puppy is thinking")
		}
	}
}

fun main() {
	val innerPuppy = Puppy.InnerPuppy()
	// We create InnerPuppy on class, not object
	innerPuppy.think() // Inner puppy is thinking
}
```

If you want your inner class to have a reference to its outer class, you need to make it inner using the inner modifier. However, creating objects from such classes requires an instance of the outer class.

```kotlin
class Puppy(val name: String) {
	inner class InnerPuppy {
		fun think() {
			println("Inner $name is thinking")
		}
	}
}

fun main() {
	val puppy = Puppy("Cookie")
	val innerPuppy = puppy.InnerPuppy() // We need puppy 
	innerPuppy.think() // Inner Cookie is thinking
}
```

Example of inner classes in the standard library are:

- private implementations of iterators;
- classes, where there is a close association between the outer class and the inner class, and the inner class is used to not define another name in the library namespace.

```kotlin
// A class from Kotlin stdlib
class FileTreeWalk(
    // ...
) : Sequence<File> {
    /** Returns an iterator walking through files. */
    override fun iterator(): Iterator<File> =
        FileTreeWalkIterator()  // 외부에서 호출되는 이터레이터 반환

    private inner class FileTreeWalkIterator
        : AbstractIterator<File>() {  // 실제 이터레이터 구현
        // 이곳에서 파일을 순차적으로 처리하는 로직 구현
        }
}
```

### 🧩 설명

- `FileTreeWalk`는 **파일을 순차적으로 탐색하는 클래스**입니다.
- `iterator()` 메서드는 **`FileTreeWalkIterator`*라는 **내부 이터레이터** 객체를 반환합니다.
- *`FileTreeWalkIterator`*는 `FileTreeWalk` 클래스의 **내부 클래스**로 선언되어 있습니다.

### **내부 클래스 사용 이유:**

1. *`FileTreeWalkIterator`*는 `FileTreeWalk`와 매우 밀접한 관계가 있습니다.
    - 외부 클래스인 `FileTreeWalk`의 상태나 필드에 접근할 수 있어야 하기 때문에 **내부 클래스**로 정의된 것입니다.
2. 외부에서 이 이터레이터를 사용할 때, 별도로 **새로운 이름**을 정의할 필요가 없습니다.
    - `FileTreeWalkIterator`는 `FileTreeWalk`에 내부적으로 존재하는 이터레이터로, 외부에서는 `FileTreeWalk`만 사용하면 됩니다.

### `private inner class`의 의미

- `private inner class`는 **`FileTreeWalk` 클래스 외부에서는 사용하지 않도록** **숨겨진(private)** 내부 클래스를 정의합니다.
- 이 내부 클래스는 **`FileTreeWalk`의 객체에서만 접근 가능**합니다. 따라서 **다른 클래스에서는 사용할 수 없고, `FileTreeWalk`의 인스턴스에서만 사용**됩니다.

## ▶ 실제 동작 흐름

1. `FileTreeWalk` 객체를 생성합니다.
2. `iterator()` 메서드를 호출하여 `FileTreeWalkIterator`를 생성하고 반환받습니다.
3. `FileTreeWalkIterator`는 파일을 순차적으로 탐색하는 로직을 담당합니다.

## 6. Summary

As you can see, in Kotlin we can define classes using really concise syntax, and the result is very readable. The primary constructor is an amazing invention, as is the fact that Kotlin uses properties instead of fields. You have also learned about inner classes. This is all great, but we haven’t yet touched on inheritance, which is so important for developers who like Object-Oriented style. We will discuss this along with interfaces and abstract classes in the next chapter

An exception is a generally unwanted event that interrupts
the regular flow of your program. It might occur when you
perform an illegal operation. Exceptions contain information
that helps developers find out what led to this problem.
Let’s take a look at an example. When you divide an integer
by 0, an exception of type ArithmeticException will be thrown.
Each exception might have a message included that should
explain what went wrong. In this case, the message will be “/
by zero”. Each exception also includes its stack trace, which is
a list of themethod calls that the applicationwas in themiddle

of when the exception was thrown. In this example, it in-
cludes information that this exception was thrown from the

calculate function, which was called from the printCalculated
function, which was called from the main function. Exception
interrupts program execution, so statements after it won’t be
executed. In the example below, notice that “After” is never
printed.

```kotlin
private fun calculate(): Int {
	return 1 / 0
}

private fun printCalculated() {
	println(calculate())
}

fun main() {
	println("Before")
	printCalculated()
	println("After")
}
```

```kotlin
Before
Exception java.lang.ArithmeticException: / by zero
    at PlaygroundKt.calculate(Playground.kt:2)
    at PlaygroundKt.printCalculated(Playground.kt:6)
    at PlaygroundKt.main(Playground.kt:11
```

**ArithmeticException**: 잘못된 산술 연산(특히 0으로 나누기).

`ArithmeticException("/ by zero")`가 발생했다. 예외는 `Playground.kt` 2행의 `calculate`에서 던져졌고, `printCalculated`(6행)를 거쳐 `main`(11행)까지 전파되었다. 따라서 `main`의 예외 이후 코드는 실행되지 않는다(예: "After" 출력 없음).

예외란 원치 않는 사건을 말하는데 발생하면 원인 파악을 위해 동시에 메시지와 stack trace를 제공한다.

예외 발생시 이후 코드는 중단되며, stack trace를 통해 코드의 호출 순서를 확인할 수 있다.

As another example, we can parse a string to an integer using
the toInt method, but this only works when the string is a
number. When it isn’t, we will see NumberFormatException with
a message explaining which string was used.

```kotlin
fun main() {
    val i1 = "10".toInt()
    println(i1)

    val i2 = "ABC".toInt()
    println(i2) // 실행 도중 예외 발생
}
```

```php
10
Exception in thread "main" java.lang.NumberFormatException: For input string: "ABC"
    at java.lang.Integer.parseInt(Integer.java:660)
    at PlaygroundKt.main(Playground.kt:4)
```

**NumberFormatException**: 숫자 변환이 불가능한 문자열 입력.

👉 “메인 스레드에서 `NumberFormatException`이 발생했다. 원인은 문자열 `"ABC"`를 정수로 변환하려다 실패했기 때문이다. 이 예외는 `Integer.parseInt`(JDK 내부, 660번째 줄)에서 던져졌고, 내 코드의 `Playground.kt` 파일 `main` 함수 4번째 줄에서 호출된 부분이 그 원인 위치다.”

## 1. Throwing exceptions

We can throw exceptions ourselves using the throw keyword

and a value that can be used as an exception, like the afore-
mentioned ArithmeticException or NumberFormatException.

```kotlin
private fun functionThrowing() {
		throw ArithmeticException("Some message")
}

fun main() {
		println("Before")
		functionThrowing()
		println("After")
}
```

```php
Before
Exception in thread "main" java.lang.ArithmeticException: Some message
    at PlaygroundKt.functionThrowing(Playground.kt:2)
    at PlaygroundKt.main(Playground.kt:7)
```

개발자가 직접 throw 키워드를 사용해 ArithmeticException를 발생시켰다. 메시지도 같이

Exceptions communicate conditions that a function is not pre-
pared to handle or is not responsible for. This isn’t necessarily

an indication of an error; it’s more like a notification event
that can be dealt with in another place that is set up to catch
it.

- 예외는 **에러라기보다는 신호(signal)**에 가까움.
- “이 함수는 이 상황을 처리할 준비가 안 되어 있다” → 다른 곳에서 처리(catch)하라는 뜻.
- 따라서 예외를 통해 “책임을 다른 코드로 넘기는” 구조가 가능하다.

## 2. Defining exceptions

We can also define our own exceptions. These are regular
classes or object declarations that extend the Throwable class.
Every such class can be thrown using throw.

```kotlin
// 클래스 예외: 던질 때마다 새로운 인스턴스 생성
class MyException : Exception("Some message")

// 오브젝트 예외: 싱글턴(항상 같은 인스턴스)
object MyExceptionObject : Exception("Some message")

private fun functionThrowing() {
    throw MyException()
    // 또는
    // throw MyExceptionObject
}

fun main() {
    println("Before")
    functionThrowing()
    println("After") // 실행되지 않음
}

```

```php
Before
Exception in thread "main" MyException: Some message
    at PlaygroundKt.functionThrowing(Playground.kt:...)
    at PlaygroundKt.main(Playground.kt:...)

```

**예외는 `Throwable`을 상속한 클래스(또는 object)** 입니다.

Kotlin/JVM 관례: 실무에서는 보통 `Throwable`보다 **`Exception`**이나 **`RuntimeException`** 같은 하위 클래스를 상속합니다. (의미가 더 명확)

### 언제 `class` vs `object`?

- **class**: 매번 **서로 다른 컨텍스트 정보**(메시지, 원인, 추가 필드 등)를 담아 던지고 싶을 때.
- **object**: “항상 같은 의미의 신호”를 **싱글턴**으로 표현하고 싶을 때(메모리 절약·식별성↑).
    
    단, **stack trace는 매번 새로 찍히지만 예외 인스턴스는 하나**라서, 멀티스레드 환경에서 공유 예외를 던지는 건 권장되지 않습니다. 보통은 **class**가 안전합니다.
    

## 용어부터

- **예외 인스턴스**: `Throwable`의 **실제 객체 1개**를 말해요. 예: `MyException()`을 호출해 생긴 그 객체.
- **공유 예외**: `object MyExceptionObject : Exception(...)`처럼 **싱글턴(객체 1개만 존재)** 예외를 여러 곳에서 **같은 인스턴스**로 던지는 상황.

## 왜 “공유 예외(싱글턴 예외)를 던지면 위험한가?”

- `Throwable`은 **가변(mutable)** 상태를 갖고 있어요:
    - `stackTrace`(배열), `cause`, `suppressed` 등이 **던질 때마다** 바뀌거나 추가될 수 있음.
- **같은 인스턴스**를 여러 스레드/요청에서 던지면:
    - 서로 **스택트레이스를 덮어쓰고**,
    - **suppressed/cause가 섞이고**,
    - 로그가 누가 던진 건지 **뒤엉켜** 디버깅이 어려워져요.
- 즉, “스택트레이스는 매번 새로 찍히지만(갱신되지만) 인스턴스는 하나”라 충돌/오염 위험이 큼.

## 언제 `class`를 쓰고, 언제 `object`를 쓸까?

- **throw할 예외는 기본적으로 `class`**
    - 매번 **새 인스턴스**를 만들어 던지면(예: `throw MyException(...)`) 각 throw가 **자기만의 stack trace / cause**를 가져서 안전하고 정확해요.
- **`object` 예외는 거의 쓰지 않기**
    - 정말 **단일 스레드 실험 코드**나 **절대 동시성 없는** 환경이 아니면 피하세요.
    - 대신 `object`는 **던지지 말고** 결과타입(예: `sealed class Result`의 실패 케이스) 같은 **값 신호**로 쓰는 건 좋아요.
        
        *(= “예외”가 아니라 “상태값”으로서의 `object`)*
        

## 3. Catching exceptions

Just like exceptions can be thrown, they can be caught using

a try-catch structure that contains a try-block and a catch-
block. An exception thrown in a function immediately ends

this function’s execution, and the process repeats in the
function that called the function in which the exception was
thrown. This changes when an exception is thrown inside
a try-block, because then its catch-blocks are checked. Each
catch-block can specify what type of exceptions it catches.
The first catch-block that accepts the exception that was
thrown will catch it and then execute its body. If an exception
is caught, the execution of the program continues after the
try block.

- **예외 발생**: `throw`로 던지면 함수 실행이 즉시 중단되고, 호출한 쪽으로 전파됨.
- **try-catch 블록**: 예외를 잡아서 처리할 수 있는 영역.
- **catch 선택 규칙**:
    - 위에서부터 차례로 확인.
    - 첫 번째로 **타입이 맞는** `catch` 블록이 실행됨.
    - `Throwable`은 모든 예외의 최상위 클래스 → 모든 예외를 잡을 수 있음.

```kotlin
class MyException : Throwable("Some message")

fun someFunction() {
    throw MyException()          // 여기서 예외 발생
    println("Will not be printed") // 실행되지 않음
}

fun main() {
    try {
        someFunction()
        println("Will not be printed") // 실행되지 않음
    } catch (e: MyException) {          // MyException 타입을 잡음
        println("Caught $e")            // 여기 실행됨
    }
}

```

- `someFunction()`에서 `MyException` 던짐.
- 즉시 함수 종료 → `main()`으로 예외 전달.
- `main()`의 `try` 블록도 중단되고, `catch (e: MyException)` 실행.
- `"Caught MyException: Some message"` 출력.

Let’s see try-catch with more catch-blocks in action. Remem-
ber that the first block that accepts an exception is always

chosen. A catch-block accepts an exception if this exception is
a subtype of the type specified in the catch-block. Note that all
exceptionsmust extendThrowable, so catching this typemeans
catching all possible exceptions.

```kotlin
import java.lang.NumberFormatException

class MyException : Throwable("Some message")

fun testTryCatch(exception: Throwable) {
    try {
        throw exception
    } catch (e: ArithmeticException) {
        println("Got ArithmeticException")
    } catch (e: MyException) {
        println("Got MyException")
    } catch (e: Throwable) {
        println("Got some exception")
    }
}

fun main() {
    testTryCatch(ArithmeticException())
    // Got ArithmeticException

    testTryCatch(MyException())
    // Got MyException

    testTryCatch(NumberFormatException())
    // Got some exception
}

```

- `testTryCatch(ArithmeticException())` → 첫 번째 catch와 일치 → `"Got ArithmeticException"`
- `testTryCatch(MyException())` → 두 번째 catch와 일치 → `"Got MyException"`
- `testTryCatch(NumberFormatException())` → 앞의 두 타입과 불일치 → 마지막 `Throwable` catch 실행.

두 가지 질문이 있어.

1. Exception을 상속받는 경우, Throwable을 상속받는 경우가 있던데.. Throwable이 더 상위의 개념인지.. 이 둘의 특징은 무엇이며 각각 어느것이 가능하고 불가능한지가 궁금해
    
    
    ## `Throwable` vs `Exception`
    
    ### 계층 구조
    
    ```scss
    kotlin.Throwable   (최상위, 모든 예외/에러의 부모)
     ├── java.lang.Error        (심각한 시스템 레벨 오류)
     └── java.lang.Exception    (일반적인 프로그램 예외)
          └── java.lang.RuntimeException (Unchecked 예외, 예: NullPointerException, ArithmeticException 등)
    ```
    
    - **`Throwable`**
        - 모든 예외와 에러의 최상위 클래스.
        - `throw` 키워드로 던질 수 있으려면 반드시 `Throwable`을 상속해야 함.
        - `catch` 블록에서 `Throwable`을 쓰면 *모든* 예외/에러를 잡을 수 있음.
        - 하지만 **Error 계열 (예: OutOfMemoryError)** 까지도 잡게 되므로 보통 권장되진 않음.
    - **`Exception`**
        - `Throwable`을 상속한 하위 클래스.
        - 프로그램 실행 중 발생할 수 있는 **회복 가능한 문제 상황**을 표현.
        - 보통 우리가 다루는 `catch` 블록은 `Exception`을 대상으로 함.
        - `RuntimeException` 계열은 "체크하지 않아도 되는(Unchecked)" 예외이고, 나머지는 "Checked" 예외 (Java 관점).
    
2. catch 문에서 (e: ArithmeticException), (e: MyException), (e: Throwable) 이런 것들이 있었는데 ‘에러 중에 ArithmeticException가 있다면 println("Got ArithmeticException")를 호출하겠다’ 라는 의미일까? 이것들은 메시지의 의미보다는 객체를 식별하기 위함인거지? 객체에 오타가 있으면 당연히 에러가 발생할테고?
    
    
    ## `catch (e: ArithmeticException)` 같은 구문 의미
    
    - 문법적으로는 **"타입 패턴 매칭"**입니다.
    - `throw` 된 객체의 실제 타입이 `ArithmeticException`이면 `catch (e: ArithmeticException)` 블록이 실행돼요.
    - 따라서 말씀하신 것처럼 `"ArithmeticException이 발생했다면, 이 블록을 실행하겠다"`라는 의미가 맞습니다.
    
    ### 주의할 점
    
    - `catch (e: MyException)`에서 `MyException`은 **클래스 이름**이지 "메시지"가 아닙니다.
        
        예외 메시지(`e.message`)와는 별개예요.
        
    - `catch` 뒤 타입 이름에 **오타**가 있으면, 컴파일 자체가 안 됩니다 (클래스를 못 찾으니까).
    - 여러 개의 `catch` 블록이 있을 때는 **위에서부터 차례대로 검사** → 처음 매칭되는 블록 실행.
    - 만약 어떤 것도 안 맞으면, 상위 호출 스택으로 전파됩니다.

### ✅ 언제 `Throwable`을 상속하면 좋은가

- **"예외이긴 하지만 `Exception` 계열로 구분하기 애매하고, 저수준/특수한 상황까지 포괄해야 할 때 `Throwable`을 직접 상속한다."**
    
    👉 이유: 모든 예외/에러의 최상위 클래스이므로, 범용적이고 특수한 상황 표현이 가능하지만, 너무 넓어서 일반적으론 잘 쓰지 않음.
    

---

### ✅ 언제 `Exception`을 상속하면 좋은가

- **"일반적인 프로그램 오류나 회복 가능한 문제 상황을 표현할 때는 `Exception`을 상속한다."**
    
    👉 이유: 대부분의 사용자 정의 예외는 `Exception`을 상속하는 것이 관례이며, catch 블록에서 다루기 쉬움.
    

---

즉, **실무에서는 거의 항상 `Exception`을 상속**하고, **`Throwable` 상속은 특별한 경우에만 사용**한다고 기억하면 깔끔합니다 👍

## 4. A try-catch block used as an expression

The try-catch structure can be used as an expression. It re-
turns the result of a try-block if no exception occurred. If an 

exception occurs and is caught, then the try-catch expression
returns the result of the catch-block.

Kotlin에서 **`try-catch`는 단순히 제어 구조(control structure)** 가 아니라 **하나의 표현식(expression)** 으로도 동작할 수 있습니다.

즉, `if-else`처럼 값을 반환할 수 있고, 그 값을 변수에 직접 담아 활용할 수 있습니다.

- **예외가 발생하지 않으면 → try 블록의 결과를 반환**
- **예외가 발생하고 catch에서 처리되면 → 해당 catch 블록의 결과를 반환**

```kotlin
fun main() {
    val a = try {
        1
    } catch (e: Error) {
        2
    }
    println(a) // 1

    val b = try {
        throw Error()
        1
    } catch (e: Error) {
        2
    }
    println(b) // 2
}

```

- 첫 번째 경우: 예외가 없으므로 `1` 반환
- 두 번째 경우: `throw Error()`로 예외 발생 → `catch` 블록 실행 → `2` 반환

👉 따라서 `try-catch`는 **안전한 대체값 제공 도구**로 쓸 수 있습니다.

A try-catch expression can be used to provide an alternative
value for a situation in which a problem occurs:

```kotlin
import java.io.File
import java.io.FileNotFoundException

fun main() {
    val content = try {
        File("AAA").readText()
    } catch (e: FileNotFoundException) {
        ""
    }
    println(content) // (empty string)
}

```

- `AAA`라는 파일이 없으면 `FileNotFoundException` 발생
- `catch` 블록이 실행되어 **빈 문자열("")** 반환

👉 이렇게 하면 프로그램이 **중단되지 않고**, 안전한 기본값으로 대체됩니다.

A practical example might be reading a string containing
an object in JSON format. We use the Gson library, whose
fromJson method throws JsonSyntaxException when a string 

does not contain a proper JSON object. Instead, we would
prefer a function that returns null in such cases; we can
implement this using try-catch as an expression.

```kotlin
fun <T : Any> fromJsonOrNull(
    json: String,
    clazz: KClass<T>
): T? = try {
    gson.fromJson(json, clazz.java)
} catch (e: JsonSyntaxException) {
    null
}

```

예를 들어 `Gson` 라이브러리를 사용해 JSON 문자열을 객체로 변환할 때, 잘못된 문자열이라면 `JsonSyntaxException` 이 발생합니다. 이때 `try-catch` 표현식을 쓰면 예외 대신 `null` 을 반환하도록 안전하게 감쌀 수 있습니다.

- 올바른 JSON → 객체 반환
- 잘못된 JSON → `null` 반환

👉 즉, `try-catch` 표현식은 **“실패하면 안전하게 null 혹은 기본값 반환”** 이라는 패턴을 구현할 때 자주 쓰입니다.

## 5. The finally block

Inside the try-structure,we can also use a finally-block,which
is used to specify what should always be invoked, even if an
exception occurs. This block does not catch any exceptions; it
is used to guarantee that some operations will be executed, no
matter the exceptions.
Take a look at the code below. An exception is thrown inside
someFunction. This exception ends this function’s execution
and skips the rest of the try-block. Since we do not have a
catch-block, this exception will not be caught, thus ending
the execution of the main function. However, there is also
the finally-block, whose body is invoked even if an exception
occurs.

- `finally` 블록은 **try-structure에 추가로 붙는 블록**입니다.
- 특징:
    - **항상 실행된다** → 예외가 발생하든, 발생하지 않든 반드시 호출됨
    - **catch 블록과 다르다** → 예외를 잡지 않고, 단지 “마지막으로 정리 작업”을 보장

👉 따라서, `finally`는 **자원 정리(clean-up)**, **연결 종료(close)**, **로그 남기기** 같은 **무조건 실행해야 할 코드**를 넣는 데 사용합니다.

```kotlin
fun someFunction() {
    throw Throwable("Some error")
}

fun main() {
    try {
        someFunction()
    } finally {
        println("Finally block was called")
    }
    println("Will not be printed")
}

```

- `someFunction()`에서 예외 발생 → `catch`가 없으므로 main 종료
- **하지만** `finally` 블록은 무조건 실행됨

The finally-block is also invoked when the try-block finishes
without an exception.

```kotlin
fun someFunction() {
    println("Function called")
}

fun main() {
    try {
        someFunction()
        println("After call")
    } finally {
        println("Finally block was called")
    }
    println("After try-finally")
}

```

위와 다르게 함수에 예외가 선언되어 있지 않아서 → `try` 블록 끝까지 실행

그 후 **finally 실행** → 그 뒤 이어지는 코드 실행

출력:

```sql
Function called
After call
Finally block was called
After try-finally
```

We use the finally-block to do operations that should always
be done, no matter if an exception occurs or not. It typically
involves closing connections or cleaning up resources.

- **자원 정리 (cleanup)**
    - 파일 닫기 (`file.close()`)
    - 네트워크 연결 해제
    - 데이터베이스 트랜잭션 정리
- **보장된 실행** → 프로그램의 정상/비정상 종료 여부와 무관하게 마지막 정리 로직 실행

## 6. Important exceptions

A few kinds of exceptions are defined in Kotlin that we use in
certain situations. The most important ones are:

- IllegalArgumentException - we use this when an argument
has an incorrect value. For example, when you expect
your argument value to be bigger than 0 but it is not.
- IllegalStateException - we use this when the state of our
system is incorrect. This means the values of properties
are not accepted by a function call.

```kotlin
fun findClusters(number: Int) {
    if (number < 1) {
        throw IllegalArgumentException("number must be >= 1")
    }
}

var userName = ""
fun printUserName() {
    if (userName == "") {
        throw IllegalStateException("Name must not be empty")
    }
}
```

In Kotlin, we use the require and check functions to throw
IllegalArgumentException and IllegalStateException when
their conditions are not satisfied.

```kotlin
fun pop(num: Int): List<T> {
		require(num <= size)
		// throws IllegalArgumentException if num > size
		
		check(isOpen)
		// throws IllegalStateException if is not open

		val ret = collection.take(num)
		collection = collection.drop(num)
		return ret
}
```

There is also an error function from Kotlin stdlib that throws

IllegalArgumentException with a message specified as an ar-
gument. It is often used as a body for a branch in a when-
condition, on the right side of the Elvis operator, or in an if-
else expression.

```kotlin
fun makeOperation(
		operation: String,
		left: Int,
		right: Int? = null
): Int = when (operation) {
		"add" ->
				left + (right ?: error("Two numbers required"))
		"subtract" ->
				left - (right ?: error("Two numbers required"))
		"opposite" -> -left
		else -> error("Unknown operation")
}

fun main() {
		println(makeOperation("add", 1, 2)) // 3
		println(makeOperation("subtract", 1, 2)) // -1
		println(makeOperation("opposite", 10)) // -10
		makeOperation("add", 1) // ERROR!
		// IllegalStateException: Two numbers required
		makeOperation("subtract", 1) // ERROR!
		// IllegalStateException: Two numbers required
		makeOperation("other", 1, 2) // ERROR!
		// IllegalStateException: Unknown operation
}
```

- **IllegalArgumentException** → 잘못된 인자 값 (입력값 체크)
- **IllegalStateException** → 잘못된 상태 (객체/시스템 상태 체크)
- **require(condition)** → `IllegalArgumentException` 자동 던짐
- **check(condition)** → `IllegalStateException` 자동 던짐
- **error(message)** → 무조건 `IllegalStateException` 발생, 주로 “도달하면 안 되는 코드”에 사용

## 7. The hierarchy of exceptions

The most important subtypes of Throwable are Error and
Exception. These represent two types of exceptions:

- Error type represents exceptions that are impossible to
recover from and consequently should not be caught, at
    
    least not without throwing them again in catch-block.
    Exceptions that are impossible to recover from include
    
    OutOfMemoryError, which is thrown when there is insuffi-
    cient space in the JVM heap.
    
- Exception type represents exceptions we can recover
from using a try-catch block. This group includes
IllegalArgumentException, IllegalStateException,
ArithmeticException, and NumberFormatException.

In most cases, when we define custom exceptions, we should
use the Exception superclass; when we catch exceptions, we
should only throw subtypes of Exception.

In Kotlin, we are not forced to catch any kinds of exceptions;
so, unlike in some other languages, there are no checked
exceptions.

## 8. Summary

In this chapter we’ve learned about exceptions, which are an
important part of Kotlin programming.We’ve learned how to
throw, catch, and define exceptions.We’ve also learned about
the finally-block and the exceptions hierarchy.
Continuing with special kinds of classes, let’s talk about enum
classes, which are used to represent a set of object instance
values.

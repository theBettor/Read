An exception is a generally unwanted event that interrupts
the regular flow of your program. It might occur when you
perform an illegal operation. Exceptions contain information
that helps developers find out what led to this problem.
Letâ€™s take a look at an example. When you divide an integer
by 0, an exception of type ArithmeticException will be thrown.
Each exception might have a message included that should
explain what went wrong. In this case, the message will be â€œ/
by zeroâ€. Each exception also includes its stack trace, which is
a list of themethod calls that the applicationwas in themiddle

of when the exception was thrown. In this example, it in-
cludes information that this exception was thrown from the

calculate function, which was called from the printCalculated
function, which was called from the main function. Exception
interrupts program execution, so statements after it wonâ€™t be
executed. In the example below, notice that â€œAfterâ€ is never
printed.

```kotlin
private fun calculate(): Int {
	return 1 / 0
}

private fun printCalculated() {
	println(calculate())
}

fun main() {
	println("Before")
	printCalculated()
	println("After")
}
```

```kotlin
Before
Exception java.lang.ArithmeticException: / by zero
    at PlaygroundKt.calculate(Playground.kt:2)
    at PlaygroundKt.printCalculated(Playground.kt:6)
    at PlaygroundKt.main(Playground.kt:11
```

**ArithmeticException**: ì˜ëª»ëœ ì‚°ìˆ  ì—°ì‚°(íŠ¹íˆ 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸°).

`ArithmeticException("/ by zero")`ê°€ ë°œìƒí–ˆë‹¤. ì˜ˆì™¸ëŠ” `Playground.kt` 2í–‰ì˜ `calculate`ì—ì„œ ë˜ì ¸ì¡Œê³ , `printCalculated`(6í–‰)ë¥¼ ê±°ì³ `main`(11í–‰)ê¹Œì§€ ì „íŒŒë˜ì—ˆë‹¤. ë”°ë¼ì„œ `main`ì˜ ì˜ˆì™¸ ì´í›„ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤(ì˜ˆ: "After" ì¶œë ¥ ì—†ìŒ).

ì˜ˆì™¸ë€ ì›ì¹˜ ì•ŠëŠ” ì‚¬ê±´ì„ ë§í•˜ëŠ”ë° ë°œìƒí•˜ë©´ ì›ì¸ íŒŒì•…ì„ ìœ„í•´ ë™ì‹œì— ë©”ì‹œì§€ì™€ stack traceë¥¼ ì œê³µí•œë‹¤.

ì˜ˆì™¸ ë°œìƒì‹œ ì´í›„ ì½”ë“œëŠ” ì¤‘ë‹¨ë˜ë©°, stack traceë¥¼ í†µí•´ ì½”ë“œì˜ í˜¸ì¶œ ìˆœì„œë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

As another example, we can parse a string to an integer using
the toInt method, but this only works when the string is a
number. When it isnâ€™t, we will see NumberFormatException with
a message explaining which string was used.

```kotlin
fun main() {
    val i1 = "10".toInt()
    println(i1)

    val i2 = "ABC".toInt()
    println(i2) // ì‹¤í–‰ ë„ì¤‘ ì˜ˆì™¸ ë°œìƒ
}
```

```php
10
Exception in thread "main" java.lang.NumberFormatException: For input string: "ABC"
    at java.lang.Integer.parseInt(Integer.java:660)
    at PlaygroundKt.main(Playground.kt:4)
```

**NumberFormatException**: ìˆ«ì ë³€í™˜ì´ ë¶ˆê°€ëŠ¥í•œ ë¬¸ìì—´ ì…ë ¥.

ğŸ‘‰ â€œë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ `NumberFormatException`ì´ ë°œìƒí–ˆë‹¤. ì›ì¸ì€ ë¬¸ìì—´ `"ABC"`ë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ë ¤ë‹¤ ì‹¤íŒ¨í–ˆê¸° ë•Œë¬¸ì´ë‹¤. ì´ ì˜ˆì™¸ëŠ” `Integer.parseInt`(JDK ë‚´ë¶€, 660ë²ˆì§¸ ì¤„)ì—ì„œ ë˜ì ¸ì¡Œê³ , ë‚´ ì½”ë“œì˜ `Playground.kt` íŒŒì¼ `main` í•¨ìˆ˜ 4ë²ˆì§¸ ì¤„ì—ì„œ í˜¸ì¶œëœ ë¶€ë¶„ì´ ê·¸ ì›ì¸ ìœ„ì¹˜ë‹¤.â€

## 1. Throwing exceptions

We can throw exceptions ourselves using the throw keyword

and a value that can be used as an exception, like the afore-
mentioned ArithmeticException or NumberFormatException.

```kotlin
private fun functionThrowing() {
		throw ArithmeticException("Some message")
}

fun main() {
		println("Before")
		functionThrowing()
		println("After")
}
```

```php
Before
Exception in thread "main" java.lang.ArithmeticException: Some message
    at PlaygroundKt.functionThrowing(Playground.kt:2)
    at PlaygroundKt.main(Playground.kt:7)
```

ê°œë°œìê°€ ì§ì ‘ throw í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ ArithmeticExceptionë¥¼ ë°œìƒì‹œì¼°ë‹¤. ë©”ì‹œì§€ë„ ê°™ì´

Exceptions communicate conditions that a function is not pre-
pared to handle or is not responsible for. This isnâ€™t necessarily

an indication of an error; itâ€™s more like a notification event
that can be dealt with in another place that is set up to catch
it.

- ì˜ˆì™¸ëŠ” **ì—ëŸ¬ë¼ê¸°ë³´ë‹¤ëŠ” ì‹ í˜¸(signal)**ì— ê°€ê¹Œì›€.
- â€œì´ í•¨ìˆ˜ëŠ” ì´ ìƒí™©ì„ ì²˜ë¦¬í•  ì¤€ë¹„ê°€ ì•ˆ ë˜ì–´ ìˆë‹¤â€ â†’ ë‹¤ë¥¸ ê³³ì—ì„œ ì²˜ë¦¬(catch)í•˜ë¼ëŠ” ëœ».
- ë”°ë¼ì„œ ì˜ˆì™¸ë¥¼ í†µí•´ â€œì±…ì„ì„ ë‹¤ë¥¸ ì½”ë“œë¡œ ë„˜ê¸°ëŠ”â€ êµ¬ì¡°ê°€ ê°€ëŠ¥í•˜ë‹¤.

## 2. Defining exceptions

We can also define our own exceptions. These are regular
classes or object declarations that extend the Throwable class.
Every such class can be thrown using throw.

```kotlin
// í´ë˜ìŠ¤ ì˜ˆì™¸: ë˜ì§ˆ ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
class MyException : Exception("Some message")

// ì˜¤ë¸Œì íŠ¸ ì˜ˆì™¸: ì‹±ê¸€í„´(í•­ìƒ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤)
object MyExceptionObject : Exception("Some message")

private fun functionThrowing() {
    throw MyException()
    // ë˜ëŠ”
    // throw MyExceptionObject
}

fun main() {
    println("Before")
    functionThrowing()
    println("After") // ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
}

```

```php
Before
Exception in thread "main" MyException: Some message
    at PlaygroundKt.functionThrowing(Playground.kt:...)
    at PlaygroundKt.main(Playground.kt:...)

```

**ì˜ˆì™¸ëŠ” `Throwable`ì„ ìƒì†í•œ í´ë˜ìŠ¤(ë˜ëŠ” object)** ì…ë‹ˆë‹¤.

Kotlin/JVM ê´€ë¡€: ì‹¤ë¬´ì—ì„œëŠ” ë³´í†µ `Throwable`ë³´ë‹¤ **`Exception`**ì´ë‚˜ **`RuntimeException`** ê°™ì€ í•˜ìœ„ í´ë˜ìŠ¤ë¥¼ ìƒì†í•©ë‹ˆë‹¤. (ì˜ë¯¸ê°€ ë” ëª…í™•)

### ì–¸ì œ `class` vs `object`?

- **class**: ë§¤ë²ˆ **ì„œë¡œ ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ ì •ë³´**(ë©”ì‹œì§€, ì›ì¸, ì¶”ê°€ í•„ë“œ ë“±)ë¥¼ ë‹´ì•„ ë˜ì§€ê³  ì‹¶ì„ ë•Œ.
- **object**: â€œí•­ìƒ ê°™ì€ ì˜ë¯¸ì˜ ì‹ í˜¸â€ë¥¼ **ì‹±ê¸€í„´**ìœ¼ë¡œ í‘œí˜„í•˜ê³  ì‹¶ì„ ë•Œ(ë©”ëª¨ë¦¬ ì ˆì•½Â·ì‹ë³„ì„±â†‘).
    
    ë‹¨, **stack traceëŠ” ë§¤ë²ˆ ìƒˆë¡œ ì°íˆì§€ë§Œ ì˜ˆì™¸ ì¸ìŠ¤í„´ìŠ¤ëŠ” í•˜ë‚˜**ë¼ì„œ, ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ê³µìœ  ì˜ˆì™¸ë¥¼ ë˜ì§€ëŠ” ê±´ ê¶Œì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë³´í†µì€ **class**ê°€ ì•ˆì „í•©ë‹ˆë‹¤.
    

## ìš©ì–´ë¶€í„°

- **ì˜ˆì™¸ ì¸ìŠ¤í„´ìŠ¤**: `Throwable`ì˜ **ì‹¤ì œ ê°ì²´ 1ê°œ**ë¥¼ ë§í•´ìš”. ì˜ˆ: `MyException()`ì„ í˜¸ì¶œí•´ ìƒê¸´ ê·¸ ê°ì²´.
- **ê³µìœ  ì˜ˆì™¸**: `object MyExceptionObject : Exception(...)`ì²˜ëŸ¼ **ì‹±ê¸€í„´(ê°ì²´ 1ê°œë§Œ ì¡´ì¬)** ì˜ˆì™¸ë¥¼ ì—¬ëŸ¬ ê³³ì—ì„œ **ê°™ì€ ì¸ìŠ¤í„´ìŠ¤**ë¡œ ë˜ì§€ëŠ” ìƒí™©.

## ì™œ â€œê³µìœ  ì˜ˆì™¸(ì‹±ê¸€í„´ ì˜ˆì™¸)ë¥¼ ë˜ì§€ë©´ ìœ„í—˜í•œê°€?â€

- `Throwable`ì€ **ê°€ë³€(mutable)** ìƒíƒœë¥¼ ê°–ê³  ìˆì–´ìš”:
    - `stackTrace`(ë°°ì—´), `cause`, `suppressed` ë“±ì´ **ë˜ì§ˆ ë•Œë§ˆë‹¤** ë°”ë€Œê±°ë‚˜ ì¶”ê°€ë  ìˆ˜ ìˆìŒ.
- **ê°™ì€ ì¸ìŠ¤í„´ìŠ¤**ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œ/ìš”ì²­ì—ì„œ ë˜ì§€ë©´:
    - ì„œë¡œ **ìŠ¤íƒíŠ¸ë ˆì´ìŠ¤ë¥¼ ë®ì–´ì“°ê³ **,
    - **suppressed/causeê°€ ì„ì´ê³ **,
    - ë¡œê·¸ê°€ ëˆ„ê°€ ë˜ì§„ ê±´ì§€ **ë’¤ì—‰ì¼œ** ë””ë²„ê¹…ì´ ì–´ë ¤ì›Œì ¸ìš”.
- ì¦‰, â€œìŠ¤íƒíŠ¸ë ˆì´ìŠ¤ëŠ” ë§¤ë²ˆ ìƒˆë¡œ ì°íˆì§€ë§Œ(ê°±ì‹ ë˜ì§€ë§Œ) ì¸ìŠ¤í„´ìŠ¤ëŠ” í•˜ë‚˜â€ë¼ ì¶©ëŒ/ì˜¤ì—¼ ìœ„í—˜ì´ í¼.

## ì–¸ì œ `class`ë¥¼ ì“°ê³ , ì–¸ì œ `object`ë¥¼ ì“¸ê¹Œ?

- **throwí•  ì˜ˆì™¸ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ `class`**
    - ë§¤ë²ˆ **ìƒˆ ì¸ìŠ¤í„´ìŠ¤**ë¥¼ ë§Œë“¤ì–´ ë˜ì§€ë©´(ì˜ˆ: `throw MyException(...)`) ê° throwê°€ **ìê¸°ë§Œì˜ stack trace / cause**ë¥¼ ê°€ì ¸ì„œ ì•ˆì „í•˜ê³  ì •í™•í•´ìš”.
- **`object` ì˜ˆì™¸ëŠ” ê±°ì˜ ì“°ì§€ ì•Šê¸°**
    - ì •ë§ **ë‹¨ì¼ ìŠ¤ë ˆë“œ ì‹¤í—˜ ì½”ë“œ**ë‚˜ **ì ˆëŒ€ ë™ì‹œì„± ì—†ëŠ”** í™˜ê²½ì´ ì•„ë‹ˆë©´ í”¼í•˜ì„¸ìš”.
    - ëŒ€ì‹  `object`ëŠ” **ë˜ì§€ì§€ ë§ê³ ** ê²°ê³¼íƒ€ì…(ì˜ˆ: `sealed class Result`ì˜ ì‹¤íŒ¨ ì¼€ì´ìŠ¤) ê°™ì€ **ê°’ ì‹ í˜¸**ë¡œ ì“°ëŠ” ê±´ ì¢‹ì•„ìš”.
        
        *(= â€œì˜ˆì™¸â€ê°€ ì•„ë‹ˆë¼ â€œìƒíƒœê°’â€ìœ¼ë¡œì„œì˜ `object`)*
        

## 3. Catching exceptions

Just like exceptions can be thrown, they can be caught using

a try-catch structure that contains a try-block and a catch-
block. An exception thrown in a function immediately ends

this functionâ€™s execution, and the process repeats in the
function that called the function in which the exception was
thrown. This changes when an exception is thrown inside
a try-block, because then its catch-blocks are checked. Each
catch-block can specify what type of exceptions it catches.
The first catch-block that accepts the exception that was
thrown will catch it and then execute its body. If an exception
is caught, the execution of the program continues after the
try block.

- **ì˜ˆì™¸ ë°œìƒ**: `throw`ë¡œ ë˜ì§€ë©´ í•¨ìˆ˜ ì‹¤í–‰ì´ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ê³ , í˜¸ì¶œí•œ ìª½ìœ¼ë¡œ ì „íŒŒë¨.
- **try-catch ë¸”ë¡**: ì˜ˆì™¸ë¥¼ ì¡ì•„ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì˜ì—­.
- **catch ì„ íƒ ê·œì¹™**:
    - ìœ„ì—ì„œë¶€í„° ì°¨ë¡€ë¡œ í™•ì¸.
    - ì²« ë²ˆì§¸ë¡œ **íƒ€ì…ì´ ë§ëŠ”** `catch` ë¸”ë¡ì´ ì‹¤í–‰ë¨.
    - `Throwable`ì€ ëª¨ë“  ì˜ˆì™¸ì˜ ìµœìƒìœ„ í´ë˜ìŠ¤ â†’ ëª¨ë“  ì˜ˆì™¸ë¥¼ ì¡ì„ ìˆ˜ ìˆìŒ.

```kotlin
class MyException : Throwable("Some message")

fun someFunction() {
    throw MyException()          // ì—¬ê¸°ì„œ ì˜ˆì™¸ ë°œìƒ
    println("Will not be printed") // ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
}

fun main() {
    try {
        someFunction()
        println("Will not be printed") // ì‹¤í–‰ë˜ì§€ ì•ŠìŒ
    } catch (e: MyException) {          // MyException íƒ€ì…ì„ ì¡ìŒ
        println("Caught $e")            // ì—¬ê¸° ì‹¤í–‰ë¨
    }
}

```

- `someFunction()`ì—ì„œ `MyException` ë˜ì§.
- ì¦‰ì‹œ í•¨ìˆ˜ ì¢…ë£Œ â†’ `main()`ìœ¼ë¡œ ì˜ˆì™¸ ì „ë‹¬.
- `main()`ì˜ `try` ë¸”ë¡ë„ ì¤‘ë‹¨ë˜ê³ , `catch (e: MyException)` ì‹¤í–‰.
- `"Caught MyException: Some message"` ì¶œë ¥.

Letâ€™s see try-catch with more catch-blocks in action. Remem-
ber that the first block that accepts an exception is always

chosen. A catch-block accepts an exception if this exception is
a subtype of the type specified in the catch-block. Note that all
exceptionsmust extendThrowable, so catching this typemeans
catching all possible exceptions.

```kotlin
import java.lang.NumberFormatException

class MyException : Throwable("Some message")

fun testTryCatch(exception: Throwable) {
    try {
        throw exception
    } catch (e: ArithmeticException) {
        println("Got ArithmeticException")
    } catch (e: MyException) {
        println("Got MyException")
    } catch (e: Throwable) {
        println("Got some exception")
    }
}

fun main() {
    testTryCatch(ArithmeticException())
    // Got ArithmeticException

    testTryCatch(MyException())
    // Got MyException

    testTryCatch(NumberFormatException())
    // Got some exception
}

```

- `testTryCatch(ArithmeticException())` â†’ ì²« ë²ˆì§¸ catchì™€ ì¼ì¹˜ â†’ `"Got ArithmeticException"`
- `testTryCatch(MyException())` â†’ ë‘ ë²ˆì§¸ catchì™€ ì¼ì¹˜ â†’ `"Got MyException"`
- `testTryCatch(NumberFormatException())` â†’ ì•ì˜ ë‘ íƒ€ì…ê³¼ ë¶ˆì¼ì¹˜ â†’ ë§ˆì§€ë§‰ `Throwable` catch ì‹¤í–‰.

ë‘ ê°€ì§€ ì§ˆë¬¸ì´ ìˆì–´.

1. Exceptionì„ ìƒì†ë°›ëŠ” ê²½ìš°, Throwableì„ ìƒì†ë°›ëŠ” ê²½ìš°ê°€ ìˆë˜ë°.. Throwableì´ ë” ìƒìœ„ì˜ ê°œë…ì¸ì§€.. ì´ ë‘˜ì˜ íŠ¹ì§•ì€ ë¬´ì—‡ì´ë©° ê°ê° ì–´ëŠê²ƒì´ ê°€ëŠ¥í•˜ê³  ë¶ˆê°€ëŠ¥í•œì§€ê°€ ê¶ê¸ˆí•´
    
    
    ## `Throwable` vs `Exception`
    
    ### ê³„ì¸µ êµ¬ì¡°
    
    ```scss
    kotlin.Throwable   (ìµœìƒìœ„, ëª¨ë“  ì˜ˆì™¸/ì—ëŸ¬ì˜ ë¶€ëª¨)
     â”œâ”€â”€ java.lang.Error        (ì‹¬ê°í•œ ì‹œìŠ¤í…œ ë ˆë²¨ ì˜¤ë¥˜)
     â””â”€â”€ java.lang.Exception    (ì¼ë°˜ì ì¸ í”„ë¡œê·¸ë¨ ì˜ˆì™¸)
          â””â”€â”€ java.lang.RuntimeException (Unchecked ì˜ˆì™¸, ì˜ˆ: NullPointerException, ArithmeticException ë“±)
    ```
    
    - **`Throwable`**
        - ëª¨ë“  ì˜ˆì™¸ì™€ ì—ëŸ¬ì˜ ìµœìƒìœ„ í´ë˜ìŠ¤.
        - `throw` í‚¤ì›Œë“œë¡œ ë˜ì§ˆ ìˆ˜ ìˆìœ¼ë ¤ë©´ ë°˜ë“œì‹œ `Throwable`ì„ ìƒì†í•´ì•¼ í•¨.
        - `catch` ë¸”ë¡ì—ì„œ `Throwable`ì„ ì“°ë©´ *ëª¨ë“ * ì˜ˆì™¸/ì—ëŸ¬ë¥¼ ì¡ì„ ìˆ˜ ìˆìŒ.
        - í•˜ì§€ë§Œ **Error ê³„ì—´ (ì˜ˆ: OutOfMemoryError)** ê¹Œì§€ë„ ì¡ê²Œ ë˜ë¯€ë¡œ ë³´í†µ ê¶Œì¥ë˜ì§„ ì•ŠìŒ.
    - **`Exception`**
        - `Throwable`ì„ ìƒì†í•œ í•˜ìœ„ í´ë˜ìŠ¤.
        - í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” **íšŒë³µ ê°€ëŠ¥í•œ ë¬¸ì œ ìƒí™©**ì„ í‘œí˜„.
        - ë³´í†µ ìš°ë¦¬ê°€ ë‹¤ë£¨ëŠ” `catch` ë¸”ë¡ì€ `Exception`ì„ ëŒ€ìƒìœ¼ë¡œ í•¨.
        - `RuntimeException` ê³„ì—´ì€ "ì²´í¬í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ”(Unchecked)" ì˜ˆì™¸ì´ê³ , ë‚˜ë¨¸ì§€ëŠ” "Checked" ì˜ˆì™¸ (Java ê´€ì ).
    
2. catch ë¬¸ì—ì„œ (e: ArithmeticException), (e: MyException), (e: Throwable) ì´ëŸ° ê²ƒë“¤ì´ ìˆì—ˆëŠ”ë° â€˜ì—ëŸ¬ ì¤‘ì— ArithmeticExceptionê°€ ìˆë‹¤ë©´ println("Got ArithmeticException")ë¥¼ í˜¸ì¶œí•˜ê² ë‹¤â€™ ë¼ëŠ” ì˜ë¯¸ì¼ê¹Œ? ì´ê²ƒë“¤ì€ ë©”ì‹œì§€ì˜ ì˜ë¯¸ë³´ë‹¤ëŠ” ê°ì²´ë¥¼ ì‹ë³„í•˜ê¸° ìœ„í•¨ì¸ê±°ì§€? ê°ì²´ì— ì˜¤íƒ€ê°€ ìˆìœ¼ë©´ ë‹¹ì—°íˆ ì—ëŸ¬ê°€ ë°œìƒí• í…Œê³ ?
    
    
    ## `catch (e: ArithmeticException)` ê°™ì€ êµ¬ë¬¸ ì˜ë¯¸
    
    - ë¬¸ë²•ì ìœ¼ë¡œëŠ” **"íƒ€ì… íŒ¨í„´ ë§¤ì¹­"**ì…ë‹ˆë‹¤.
    - `throw` ëœ ê°ì²´ì˜ ì‹¤ì œ íƒ€ì…ì´ `ArithmeticException`ì´ë©´ `catch (e: ArithmeticException)` ë¸”ë¡ì´ ì‹¤í–‰ë¼ìš”.
    - ë”°ë¼ì„œ ë§ì”€í•˜ì‹  ê²ƒì²˜ëŸ¼ `"ArithmeticExceptionì´ ë°œìƒí–ˆë‹¤ë©´, ì´ ë¸”ë¡ì„ ì‹¤í–‰í•˜ê² ë‹¤"`ë¼ëŠ” ì˜ë¯¸ê°€ ë§ìŠµë‹ˆë‹¤.
    
    ### ì£¼ì˜í•  ì 
    
    - `catch (e: MyException)`ì—ì„œ `MyException`ì€ **í´ë˜ìŠ¤ ì´ë¦„**ì´ì§€ "ë©”ì‹œì§€"ê°€ ì•„ë‹™ë‹ˆë‹¤.
        
        ì˜ˆì™¸ ë©”ì‹œì§€(`e.message`)ì™€ëŠ” ë³„ê°œì˜ˆìš”.
        
    - `catch` ë’¤ íƒ€ì… ì´ë¦„ì— **ì˜¤íƒ€**ê°€ ìˆìœ¼ë©´, ì»´íŒŒì¼ ìì²´ê°€ ì•ˆ ë©ë‹ˆë‹¤ (í´ë˜ìŠ¤ë¥¼ ëª» ì°¾ìœ¼ë‹ˆê¹Œ).
    - ì—¬ëŸ¬ ê°œì˜ `catch` ë¸”ë¡ì´ ìˆì„ ë•ŒëŠ” **ìœ„ì—ì„œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ê²€ì‚¬** â†’ ì²˜ìŒ ë§¤ì¹­ë˜ëŠ” ë¸”ë¡ ì‹¤í–‰.
    - ë§Œì•½ ì–´ë–¤ ê²ƒë„ ì•ˆ ë§ìœ¼ë©´, ìƒìœ„ í˜¸ì¶œ ìŠ¤íƒìœ¼ë¡œ ì „íŒŒë©ë‹ˆë‹¤.

### âœ… ì–¸ì œ `Throwable`ì„ ìƒì†í•˜ë©´ ì¢‹ì€ê°€

- **"ì˜ˆì™¸ì´ê¸´ í•˜ì§€ë§Œ `Exception` ê³„ì—´ë¡œ êµ¬ë¶„í•˜ê¸° ì• ë§¤í•˜ê³ , ì €ìˆ˜ì¤€/íŠ¹ìˆ˜í•œ ìƒí™©ê¹Œì§€ í¬ê´„í•´ì•¼ í•  ë•Œ `Throwable`ì„ ì§ì ‘ ìƒì†í•œë‹¤."**
    
    ğŸ‘‰ ì´ìœ : ëª¨ë“  ì˜ˆì™¸/ì—ëŸ¬ì˜ ìµœìƒìœ„ í´ë˜ìŠ¤ì´ë¯€ë¡œ, ë²”ìš©ì ì´ê³  íŠ¹ìˆ˜í•œ ìƒí™© í‘œí˜„ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ë„ˆë¬´ ë„“ì–´ì„œ ì¼ë°˜ì ìœ¼ë¡  ì˜ ì“°ì§€ ì•ŠìŒ.
    

---

### âœ… ì–¸ì œ `Exception`ì„ ìƒì†í•˜ë©´ ì¢‹ì€ê°€

- **"ì¼ë°˜ì ì¸ í”„ë¡œê·¸ë¨ ì˜¤ë¥˜ë‚˜ íšŒë³µ ê°€ëŠ¥í•œ ë¬¸ì œ ìƒí™©ì„ í‘œí˜„í•  ë•ŒëŠ” `Exception`ì„ ìƒì†í•œë‹¤."**
    
    ğŸ‘‰ ì´ìœ : ëŒ€ë¶€ë¶„ì˜ ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ëŠ” `Exception`ì„ ìƒì†í•˜ëŠ” ê²ƒì´ ê´€ë¡€ì´ë©°, catch ë¸”ë¡ì—ì„œ ë‹¤ë£¨ê¸° ì‰¬ì›€.
    

---

ì¦‰, **ì‹¤ë¬´ì—ì„œëŠ” ê±°ì˜ í•­ìƒ `Exception`ì„ ìƒì†**í•˜ê³ , **`Throwable` ìƒì†ì€ íŠ¹ë³„í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©**í•œë‹¤ê³  ê¸°ì–µí•˜ë©´ ê¹”ë”í•©ë‹ˆë‹¤ ğŸ‘

## 4. A try-catch block used as an expression

The try-catch structure can be used as an expression. It re-
turns the result of a try-block if no exception occurred. If an 

exception occurs and is caught, then the try-catch expression
returns the result of the catch-block.

Kotlinì—ì„œ **`try-catch`ëŠ” ë‹¨ìˆœíˆ ì œì–´ êµ¬ì¡°(control structure)** ê°€ ì•„ë‹ˆë¼ **í•˜ë‚˜ì˜ í‘œí˜„ì‹(expression)** ìœ¼ë¡œë„ ë™ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¦‰, `if-else`ì²˜ëŸ¼ ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆê³ , ê·¸ ê°’ì„ ë³€ìˆ˜ì— ì§ì ‘ ë‹´ì•„ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- **ì˜ˆì™¸ê°€ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ â†’ try ë¸”ë¡ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜**
- **ì˜ˆì™¸ê°€ ë°œìƒí•˜ê³  catchì—ì„œ ì²˜ë¦¬ë˜ë©´ â†’ í•´ë‹¹ catch ë¸”ë¡ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜**

```kotlin
fun main() {
    val a = try {
        1
    } catch (e: Error) {
        2
    }
    println(a) // 1

    val b = try {
        throw Error()
        1
    } catch (e: Error) {
        2
    }
    println(b) // 2
}

```

- ì²« ë²ˆì§¸ ê²½ìš°: ì˜ˆì™¸ê°€ ì—†ìœ¼ë¯€ë¡œ `1` ë°˜í™˜
- ë‘ ë²ˆì§¸ ê²½ìš°: `throw Error()`ë¡œ ì˜ˆì™¸ ë°œìƒ â†’ `catch` ë¸”ë¡ ì‹¤í–‰ â†’ `2` ë°˜í™˜

ğŸ‘‰ ë”°ë¼ì„œ `try-catch`ëŠ” **ì•ˆì „í•œ ëŒ€ì²´ê°’ ì œê³µ ë„êµ¬**ë¡œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

A try-catch expression can be used to provide an alternative
value for a situation in which a problem occurs:

```kotlin
import java.io.File
import java.io.FileNotFoundException

fun main() {
    val content = try {
        File("AAA").readText()
    } catch (e: FileNotFoundException) {
        ""
    }
    println(content) // (empty string)
}

```

- `AAA`ë¼ëŠ” íŒŒì¼ì´ ì—†ìœ¼ë©´ `FileNotFoundException` ë°œìƒ
- `catch` ë¸”ë¡ì´ ì‹¤í–‰ë˜ì–´ **ë¹ˆ ë¬¸ìì—´("")** ë°˜í™˜

ğŸ‘‰ ì´ë ‡ê²Œ í•˜ë©´ í”„ë¡œê·¸ë¨ì´ **ì¤‘ë‹¨ë˜ì§€ ì•Šê³ **, ì•ˆì „í•œ ê¸°ë³¸ê°’ìœ¼ë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤.

A practical example might be reading a string containing
an object in JSON format. We use the Gson library, whose
fromJson method throws JsonSyntaxException when a string 

does not contain a proper JSON object. Instead, we would
prefer a function that returns null in such cases; we can
implement this using try-catch as an expression.

```kotlin
fun <T : Any> fromJsonOrNull(
    json: String,
    clazz: KClass<T>
): T? = try {
    gson.fromJson(json, clazz.java)
} catch (e: JsonSyntaxException) {
    null
}

```

ì˜ˆë¥¼ ë“¤ì–´ `Gson` ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ JSON ë¬¸ìì—´ì„ ê°ì²´ë¡œ ë³€í™˜í•  ë•Œ, ì˜ëª»ëœ ë¬¸ìì—´ì´ë¼ë©´ `JsonSyntaxException` ì´ ë°œìƒí•©ë‹ˆë‹¤. ì´ë•Œ `try-catch` í‘œí˜„ì‹ì„ ì“°ë©´ ì˜ˆì™¸ ëŒ€ì‹  `null` ì„ ë°˜í™˜í•˜ë„ë¡ ì•ˆì „í•˜ê²Œ ê°ìŒ€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- ì˜¬ë°”ë¥¸ JSON â†’ ê°ì²´ ë°˜í™˜
- ì˜ëª»ëœ JSON â†’ `null` ë°˜í™˜

ğŸ‘‰ ì¦‰, `try-catch` í‘œí˜„ì‹ì€ **â€œì‹¤íŒ¨í•˜ë©´ ì•ˆì „í•˜ê²Œ null í˜¹ì€ ê¸°ë³¸ê°’ ë°˜í™˜â€** ì´ë¼ëŠ” íŒ¨í„´ì„ êµ¬í˜„í•  ë•Œ ìì£¼ ì“°ì…ë‹ˆë‹¤.

## 5. The finally block

Inside the try-structure,we can also use a finally-block,which
is used to specify what should always be invoked, even if an
exception occurs. This block does not catch any exceptions; it
is used to guarantee that some operations will be executed, no
matter the exceptions.
Take a look at the code below. An exception is thrown inside
someFunction. This exception ends this functionâ€™s execution
and skips the rest of the try-block. Since we do not have a
catch-block, this exception will not be caught, thus ending
the execution of the main function. However, there is also
the finally-block, whose body is invoked even if an exception
occurs.

- `finally` ë¸”ë¡ì€ **try-structureì— ì¶”ê°€ë¡œ ë¶™ëŠ” ë¸”ë¡**ì…ë‹ˆë‹¤.
- íŠ¹ì§•:
    - **í•­ìƒ ì‹¤í–‰ëœë‹¤** â†’ ì˜ˆì™¸ê°€ ë°œìƒí•˜ë“ , ë°œìƒí•˜ì§€ ì•Šë“  ë°˜ë“œì‹œ í˜¸ì¶œë¨
    - **catch ë¸”ë¡ê³¼ ë‹¤ë¥´ë‹¤** â†’ ì˜ˆì™¸ë¥¼ ì¡ì§€ ì•Šê³ , ë‹¨ì§€ â€œë§ˆì§€ë§‰ìœ¼ë¡œ ì •ë¦¬ ì‘ì—…â€ì„ ë³´ì¥

ğŸ‘‰ ë”°ë¼ì„œ, `finally`ëŠ” **ìì› ì •ë¦¬(clean-up)**, **ì—°ê²° ì¢…ë£Œ(close)**, **ë¡œê·¸ ë‚¨ê¸°ê¸°** ê°™ì€ **ë¬´ì¡°ê±´ ì‹¤í–‰í•´ì•¼ í•  ì½”ë“œ**ë¥¼ ë„£ëŠ” ë° ì‚¬ìš©í•©ë‹ˆë‹¤.

```kotlin
fun someFunction() {
    throw Throwable("Some error")
}

fun main() {
    try {
        someFunction()
    } finally {
        println("Finally block was called")
    }
    println("Will not be printed")
}

```

- `someFunction()`ì—ì„œ ì˜ˆì™¸ ë°œìƒ â†’ `catch`ê°€ ì—†ìœ¼ë¯€ë¡œ main ì¢…ë£Œ
- **í•˜ì§€ë§Œ** `finally` ë¸”ë¡ì€ ë¬´ì¡°ê±´ ì‹¤í–‰ë¨

The finally-block is also invoked when the try-block finishes
without an exception.

```kotlin
fun someFunction() {
    println("Function called")
}

fun main() {
    try {
        someFunction()
        println("After call")
    } finally {
        println("Finally block was called")
    }
    println("After try-finally")
}

```

ìœ„ì™€ ë‹¤ë¥´ê²Œ í•¨ìˆ˜ì— ì˜ˆì™¸ê°€ ì„ ì–¸ë˜ì–´ ìˆì§€ ì•Šì•„ì„œ â†’ `try` ë¸”ë¡ ëê¹Œì§€ ì‹¤í–‰

ê·¸ í›„ **finally ì‹¤í–‰** â†’ ê·¸ ë’¤ ì´ì–´ì§€ëŠ” ì½”ë“œ ì‹¤í–‰

ì¶œë ¥:

```sql
Function called
After call
Finally block was called
After try-finally
```

We use the finally-block to do operations that should always
be done, no matter if an exception occurs or not. It typically
involves closing connections or cleaning up resources.

- **ìì› ì •ë¦¬ (cleanup)**
    - íŒŒì¼ ë‹«ê¸° (`file.close()`)
    - ë„¤íŠ¸ì›Œí¬ ì—°ê²° í•´ì œ
    - ë°ì´í„°ë² ì´ìŠ¤ íŠ¸ëœì­ì…˜ ì •ë¦¬
- **ë³´ì¥ëœ ì‹¤í–‰** â†’ í”„ë¡œê·¸ë¨ì˜ ì •ìƒ/ë¹„ì •ìƒ ì¢…ë£Œ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ ë§ˆì§€ë§‰ ì •ë¦¬ ë¡œì§ ì‹¤í–‰

## 6. Important exceptions

A few kinds of exceptions are defined in Kotlin that we use in
certain situations. The most important ones are:

- IllegalArgumentException - we use this when an argument
has an incorrect value. For example, when you expect
your argument value to be bigger than 0 but it is not.
- IllegalStateException - we use this when the state of our
system is incorrect. This means the values of properties
are not accepted by a function call.

```kotlin
fun findClusters(number: Int) {
    if (number < 1) {
        throw IllegalArgumentException("number must be >= 1")
    }
}

var userName = ""
fun printUserName() {
    if (userName == "") {
        throw IllegalStateException("Name must not be empty")
    }
}
```

In Kotlin, we use the require and check functions to throw
IllegalArgumentException and IllegalStateException when
their conditions are not satisfied.

```kotlin
fun pop(num: Int): List<T> {
		require(num <= size)
		// throws IllegalArgumentException if num > size
		
		check(isOpen)
		// throws IllegalStateException if is not open

		val ret = collection.take(num)
		collection = collection.drop(num)
		return ret
}
```

There is also an error function from Kotlin stdlib that throws

IllegalArgumentException with a message specified as an ar-
gument. It is often used as a body for a branch in a when-
condition, on the right side of the Elvis operator, or in an if-
else expression.

```kotlin
fun makeOperation(
		operation: String,
		left: Int,
		right: Int? = null
): Int = when (operation) {
		"add" ->
				left + (right ?: error("Two numbers required"))
		"subtract" ->
				left - (right ?: error("Two numbers required"))
		"opposite" -> -left
		else -> error("Unknown operation")
}

fun main() {
		println(makeOperation("add", 1, 2)) // 3
		println(makeOperation("subtract", 1, 2)) // -1
		println(makeOperation("opposite", 10)) // -10
		makeOperation("add", 1) // ERROR!
		// IllegalStateException: Two numbers required
		makeOperation("subtract", 1) // ERROR!
		// IllegalStateException: Two numbers required
		makeOperation("other", 1, 2) // ERROR!
		// IllegalStateException: Unknown operation
}
```

- **IllegalArgumentException** â†’ ì˜ëª»ëœ ì¸ì ê°’ (ì…ë ¥ê°’ ì²´í¬)
- **IllegalStateException** â†’ ì˜ëª»ëœ ìƒíƒœ (ê°ì²´/ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬)
- **require(condition)** â†’ `IllegalArgumentException` ìë™ ë˜ì§
- **check(condition)** â†’ `IllegalStateException` ìë™ ë˜ì§
- **error(message)** â†’ ë¬´ì¡°ê±´ `IllegalStateException` ë°œìƒ, ì£¼ë¡œ â€œë„ë‹¬í•˜ë©´ ì•ˆ ë˜ëŠ” ì½”ë“œâ€ì— ì‚¬ìš©

## 7. The hierarchy of exceptions

The most important subtypes of Throwable are Error and
Exception. These represent two types of exceptions:

- Error type represents exceptions that are impossible to
recover from and consequently should not be caught, at
    
    least not without throwing them again in catch-block.
    Exceptions that are impossible to recover from include
    
    OutOfMemoryError, which is thrown when there is insuffi-
    cient space in the JVM heap.
    
- Exception type represents exceptions we can recover
from using a try-catch block. This group includes
IllegalArgumentException, IllegalStateException,
ArithmeticException, and NumberFormatException.

In most cases, when we define custom exceptions, we should
use the Exception superclass; when we catch exceptions, we
should only throw subtypes of Exception.

In Kotlin, we are not forced to catch any kinds of exceptions;
so, unlike in some other languages, there are no checked
exceptions.

## 8. Summary

In this chapter weâ€™ve learned about exceptions, which are an
important part of Kotlin programming.Weâ€™ve learned how to
throw, catch, and define exceptions.Weâ€™ve also learned about
the finally-block and the exceptions hierarchy.
Continuing with special kinds of classes, letâ€™s talk about enum
classes, which are used to represent a set of object instance
values.

The most intuitive way to definemethods and properties is in-
side classes. Such elements are called classmembers or, more

concretely, member functions and member properties.

```kotlin
class Telephone(
		// member property
		val number: String
) {
		// member function
		fun call() {
				print("Calling $number")
		}
}

fun main() {
		// Usage
		val telephone = Telephone("123456789")
		println(telephone.number) // 123456789
		telephone.call() // Calling 123456789
}
```

On the other hand, Kotlin allows another way to define func-
tions and properties that are called on an instance: extensions.

Extension functions are defined like regular functions, but
they additionally have an extra type (and dot) before the
function name. In the example below, the call function is
defined as an extension function on Telephone, so it needs to
be called on an instance of this type.

```kotlin
class Telephone(
		val number: String
)

fun Telephone.call() {
		print("Calling $number")
}

fun main() {
		// Usage
		val telephone = Telephone("123456789")
		telephone.call() // Calling 123456789
}
```

**í™•ì¥ í•¨ìˆ˜**: í´ë˜ìŠ¤ ë°”ê¹¥ì—ì„œ, ë§ˆì¹˜ ê·¸ í´ë˜ìŠ¤ì˜ ë©¤ë²„ì¸ ê²ƒì²˜ëŸ¼ ë™ì‘í•˜ëŠ” í•¨ìˆ˜

ğŸ‘‰ ë‘ ê²½ìš° ëª¨ë‘ `telephone.call()`ì²˜ëŸ¼ ë˜‘ê°™ì´ í˜¸ì¶œ ê°€ëŠ¥.

ğŸ‘‰ ì°¨ì´: ë©¤ë²„ í•¨ìˆ˜ëŠ” í´ë˜ìŠ¤ ë‚´ë¶€ ì •ì˜, í™•ì¥ í•¨ìˆ˜ëŠ” í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ "ë¶™ì´ëŠ” ê²ƒì²˜ëŸ¼" ì •ì˜.

Both member functions and extension functions
are referred to as methods.

Extension functions can be defined on types we donâ€™t control,
for instance String. This gives us the power to extend external
APIs with our own functions.

```kotlin
fun String.remove(value: String) = this.replace(value, "")

fun main() {
		println("Who Framed Roger Rabbit?".remove(" "))
		// WhoFramedRogerRabbit?
}
```

- **Receiver type**: í™•ì¥ì„ ì ìš©í•  ëŒ€ìƒ íƒ€ì… â†’ `String`, `Telephone` ë“±
- **Receiver**: í•¨ìˆ˜ê°€ ì‹¤ì œë¡œ ì‹¤í–‰ë  ë•Œ ê·¸ ì¸ìŠ¤í„´ìŠ¤ (`this`)
- `String` â†’ Receiver type
- `this` (`"Who Framed Roger Rabbit?"`) â†’ Receiver

Take a look at the example above. We defined the extension
function remove on String, so we need to call this function on
an object of type String. Inside the function, we reference
this object using the this keyword, just like inside member
functions. The this keyword can also be used implicitly.

```kotlin
// explicit this
fun String.remove(value: String) = this.replace(value, "")
// implicit this
fun String.remove(value: String) = replace(value, "")
```

- `fun <ReceiverType>.<í•¨ìˆ˜ëª…>(íŒŒë¼ë¯¸í„°): ë°˜í™˜íƒ€ì…`
- í•¨ìˆ˜ ë³¸ë¬¸ì—ì„œ `this` í‚¤ì›Œë“œ ì‚¬ìš© â†’ Receiver ê°ì²´ë¥¼ ê°€ë¦¬í‚´
- `this`ëŠ” **ëª…ì‹œì ìœ¼ë¡œ ì¨ë„ ë˜ê³ , ìƒëµ ê°€ëŠ¥**

The this keyword is known as the receiver. Inside extension
functions, we call it an extension receiver. Inside member
functions, we call it a dispatch receiver. The type we extend
with the extension function is called the receiver type.

![á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2025-08-29 á„‹á…©á„Œá…¥á†« 10.24.35.png](attachment:a444b868-b4fe-42e8-80ff-a8997150446d:á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º_2025-08-29_á„‹á…©á„Œá…¥á†«_10.24.35.png)

- ì‚¬ì‹¤ í™•ì¥ í•¨ìˆ˜ëŠ” ë‹¨ìˆœíˆ **ì •ì (Static) í•¨ìˆ˜**ì¼ ë¿.
- ì°¨ì´: ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜(Receiver ê°ì²´)ë¥¼ â€œì•ì— ì (.) ì°ê³  í˜¸ì¶œâ€í•˜ëŠ” ë¬¸ë²•ì  í¸ì˜ë¥¼ ì œê³µ.
- ì¦‰, ì•„ë˜ ë‘ ì½”ë“œëŠ” ë™ì¼:

```kotlin
"abc".remove("a")
remove("abc", "a") // ë‚´ë¶€ì ìœ¼ë¡œ ì´ë ‡ê²Œ ë³€í™˜ë¨
```

- í™•ì¥ í•¨ìˆ˜ëŠ” **í´ë˜ìŠ¤ì˜ private, protected ë©¤ë²„ì— ì ‘ê·¼ ë¶ˆê°€**.
- ì¦‰, ì•ˆì „í•˜ê²Œ â€œì™¸ë¶€ì—ì„œ ë§ë¶™ì´ëŠ” ê¸°ëŠ¥â€ë§Œ ì œê³µ.

- í™•ì¥ í•¨ìˆ˜ = **ì™¸ë¶€ì—ì„œ íƒ€ì…ì— ë©”ì„œë“œë¥¼ â€œë¶™ì—¬ ì“°ëŠ”â€ ë¬¸ë²•ì  ì„¤íƒ•**
- Receiver typeìœ¼ë¡œ ëŒ€ìƒì„ ì§€ì •í•˜ê³ , `this`ë¡œ í•´ë‹¹ ì¸ìŠ¤í„´ìŠ¤ì— ì ‘ê·¼.
- ë©¤ë²„ í•¨ìˆ˜ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ, ì‹¤ì œë¡  ë‹¨ìˆœí•œ ì •ì  í•¨ìˆ˜ â†’ ì•ˆì „í•˜ê²Œ ì™¸ë¶€ APIë¥¼ í™•ì¥ ê°€ëŠ¥.

Extension functions behave a lot like member functions.
When developers learn this, they are often concerned about
objectsâ€™ safety, but this isnâ€™t a problem as extensions do not
have any special access to class elements. The only difference
between top-level extension functions and other top-level
functions is that they are called on an instance instead of
receiving this instance as a regular argument. To see this
more clearly, letâ€™s take a look under the hood of extension
functions.

## 1. Extension functions under the hood

To understand extension functions, letâ€™s again use â€œTools > Kotlin > Show Kotlin bytecodeâ€ and â€œDecompileâ€ (as ex-plained in chapter Your first program in Kotlin in section What is under the hood on JVM?). We will compile and decompile to Java our remove function definition and its call:

```kotlin
fun String.remove(value: String) = this.replace(value, "")

fun main() {
		println("A B C".remove(" ")) // ABC
}
```

As a result, you should see the following code:

```kotlin
public final class PlaygroundKt {
		@NotNull
		public static final String remove(
				@NotNull String $this$remove, // â† ì›ë˜ëŠ” Receiver type (String)
				@NotNull String value
		) {
				// parameters not-null checks
				return StringsKt.replace$default(
						$this$remove, // â† ì‹¤ì œ Receiverê°€ ì²« ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬ë¨
						value,
						"" // êµì²´í•  ë¬¸ìì—´
						// plus default values
				);
		}

		public static final void main(@NotNull String[] args) {
				// parameter not-null check
        String var1 = remove("A B C", " "); // â† static ë©”ì„œë“œ í˜¸ì¶œ
				System.out.println(var1);
		}
}
```

- **Receiver type(String)** â†’ ë‹¨ìˆœíˆ **ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜**ë¡œ ë³€í™˜ë¨ (`$this$remove`).
- **í™•ì¥ í•¨ìˆ˜ í˜¸ì¶œ `"A B C".remove(" ")`** â†’ ì‚¬ì‹¤ìƒ `remove("A B C", " ")`ë¡œ ë³€í™˜ë¨.
- ì¦‰, **í™•ì¥ í•¨ìˆ˜ = ë‹¨ìˆœí•œ ì •ì  í•¨ìˆ˜ + íŠ¹ë³„í•œ ë¬¸ë²•ì  ì„¤íƒ•**.

Notice what happened to the receiver type: it became a param-
eter. You can also see that, under the hood, remove is not called

on an object. It is just a regular static function.
When you define an extension function, you do not really add
anything to a class. It is just syntactic sugar. Letâ€™s compare the
two following implementations of remove.

```kotlin
fun remove(text: String, value: String) = text.replace(value, "")
fun String.remove(value: String) = this.replace(value, "")
```

- **ì‹¤ì œë¡œ ìƒì„±ë˜ëŠ” ë°”ì´íŠ¸ì½”ë“œ**ëŠ” ê±°ì˜ ë™ì¼.
- **ì°¨ì´ì **: í˜¸ì¶œ ë°©ì‹
    - ì¼ë°˜ í•¨ìˆ˜ â†’ `remove("A B C", " ")`
    - í™•ì¥ í•¨ìˆ˜ â†’ `"A B C".remove(" ")` (ë” ìì—°ìŠ¤ëŸ½ê³  ê°ì²´ì§€í–¥ì ìœ¼ë¡œ ë³´ì„)

Under the hood, they are nearly identical. The difference is
in how Kotlin expects them to be called. Regular functions
receive all their arguments in regular argument positions.
Extension functions are called â€œonâ€ a value.

## 2. Extension properties

An extension cannot hold a state, so it cannot have fields.
Although properties do not need fields, they can be defined by
their getters and setters. This is why we can define extension
properties if they do not need a backing field and are defined
by accessors.

- í™•ì¥ í•¨ìˆ˜ì²˜ëŸ¼ **ê¸°ì¡´ íƒ€ì…ì— í”„ë¡œí¼í‹°ë¥¼ â€œë¶™ì´ëŠ” ê²ƒì²˜ëŸ¼â€ ì •ì˜** ê°€ëŠ¥.
- ë‹¨, **ìƒíƒœ(state)**ë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ **ë°±í‚¹ í•„ë“œ(backing field)**ëŠ” ì—†ìŒ.
- ëŒ€ì‹  **getter/setter**ë¡œë§Œ ë™ì‘.

```kotlin
val <T> List<T>.lastIndex: Int
		get() = size - 1
```

List<T>ì— lastIndex í”„ë¡œí¼í‹°ë¥¼ í™•ì¥ìœ¼ë¡œ ì¶”ê°€.

ì‹¤ì œë¡œëŠ” í•¨ìˆ˜ì²˜ëŸ¼ ë™ì‘í•˜ëŠ” ë¬¸ë²•ì  ì„¤íƒ•ì¼ ë¿ â†’ ë‚´ë¶€ì ìœ¼ë¡œ getLastIndex(list) ê°™ì€ static í•¨ìˆ˜ë¡œ ë³€í™˜ë¨.

í˜¸ì¶œ ì˜ˆì‹œ:

```kotlin
val nums = listOf(10, 20, 30)
println(nums.lastIndex) // 2
```

Extension properties are very popular on Android, where ac-
cessing different services is complex and repetitive. Defining

extension properties lets us do this much more easily.

- Android APIëŠ” ì„œë¹„ìŠ¤ ì ‘ê·¼ì´ ë²ˆê±°ë¡­ê³  ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œê°€ ë§ìŒ.
- í™•ì¥ í”„ë¡œí¼í‹°ë¥¼ ì“°ë©´ í›¨ì”¬ ê°„ë‹¨í•˜ê²Œ ì ‘ê·¼ ê°€ëŠ¥.

```kotlin
val Context.inflater: LayoutInflater
    get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater

val Context.notificationManager: NotificationManager
    get() = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

val Context.alarmManager: AlarmManager
    get() = getSystemService(Context.ALARM_SERVICE) as AlarmManager
```

ğŸ‘‰ ì›ë˜ëŠ” `getSystemService(...) as ...` ë¥¼ ë§¤ë²ˆ ì¨ì•¼ í•˜ì§€ë§Œ,

ğŸ‘‰ í™•ì¥ í”„ë¡œí¼í‹° ë•ë¶„ì— `context.inflater`, `context.notificationManager`ì²˜ëŸ¼ ê°„ë‹¨í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥.

Extension properties can define both a getter and a setter.

Here is an extension property that provides a different repre-
sentation of a user birthdate:

í™•ì¥ í”„ë¡œí¼í‹°ë„ **ì½ê¸°(get)**, **ì“°ê¸°(set)** ëª¨ë‘ ì •ì˜ ê°€ëŠ¥.

```kotlin
class User {
		// ...
		var birthdateMillis: Long? = null
}

var User.birthdate: Date?
		get() {
				val millis = birthdateMillis
				return if (millis == null) null else Date(millis)
		}
		set(value) {
				birthdateMillis = value?.time
		}
```

- `User.birthdate`ë¼ëŠ” **Date? íƒ€ì…ì˜ í”„ë¡œí¼í‹°**ë¥¼ ìƒˆë¡œ ì œê³µ.
- ë‚´ë¶€ì—ì„œëŠ” ì›ë˜ ê°€ì§€ê³  ìˆë˜ `birthdateMillis` (Long)ë¥¼ ì‚¬ìš©.
- í˜¸ì¶œ ì˜ˆì‹œ:

```kotlin
val user = User()
user.birthdate = Date()       // setter ë™ì‘
println(user.birthdate)       // getter ë™ì‘

```

1. í´ë˜ìŠ¤ ì•ˆì— ìˆëŠ”ê±´ í”„ë¡œí¼í‹°
2. Kotlinì€ ìë™ìœ¼ë¡œ ë°±í‚¹í•„ë“œë¥¼ ë§Œë“¤ì–´ì„œ ê°’ì„ ì €ì¥í•¨
    - `user.birthdateMillis = 1000L` â†’ ê°’ì„ ë°±í‚¹ í•„ë“œì— ê¸°ë¡
    - `println(user.birthdateMillis)` â†’ ë°±í‚¹ í•„ë“œì—ì„œ ê°’ì„ ì½ìŒ
    - ì¦‰, ë³„ë„ì˜ ë¡œì§ì„ ì•ˆ ì“°ë©´ ë‹¨ìˆœíˆ â€œê°’ì„ ì €ì¥/êº¼ë‚´ëŠ” í†µâ€ì´ë¼ê³  ë³´ì‹œë©´ ë¼ìš”.
3. `birthdate`ë¼ëŠ” **ìƒˆë¡œìš´ í”„ë¡œí¼í‹°**ë¥¼ User í´ë˜ìŠ¤ì— â€œí™•ì¥â€ìœ¼ë¡œ ë¶™ì¸ ê²ë‹ˆë‹¤. **í™•ì¥ í”„ë¡œí¼í‹°ì—ëŠ” ë°±í‚¹ í•„ë“œê°€ ì—†ìŒ** â†’ ê°’ì„ ì§ì ‘ ì €ì¥í•  ìˆ˜ ì—†ì–´ìš”. ëŒ€ì‹  ë‚´ë¶€ì ìœ¼ë¡œ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” `birthdateMillis`ë¥¼ ì´ìš©í•´ì„œ ë™ì‘í•©ë‹ˆë‹¤.
4. **setter** = ê°’ì„ ë„£ì„ ë•Œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ. **getter** = ê°’ì„ êº¼ë‚¼ ë•Œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ.
5. ìœ„ì˜ ì½”ë“œëŠ” ì›ë˜ Longíƒ€ì…ì˜ ë°±í‚¹í•„ë“œë¥¼ ê°–ëŠ” í´ë˜ìŠ¤ë‹¤. 
    - í™•ì¥ í”„ë¡œí¼í‹° `birthdate`ëŠ” **ì‹¤ì œ ì €ì¥ì†ŒëŠ” `birthdateMillis(Long)`** ë¥¼ ì‚¬ìš©í•œë‹¤. ê·¸ë˜ì„œ
    - **setter**ëŠ” ê°œë°œìê°€ ë„£ì€ `Date` ê°’ì„ ë‚´ë¶€ ì €ì¥ì†Œì— ë§ê²Œ `Long`ìœ¼ë¡œ ë³€í™˜í•´ ì €ì¥í•˜ê³ ,
    - **getter**ëŠ” ë‚´ë¶€ì— ì €ì¥ëœ `Long` ê°’ì„ êº¼ë‚´ì„œ ì‚¬ëŒì´ ì“°ê¸° ì¢‹ì€ `Date` ê°ì²´ë¡œ ë³€í™˜í•´ ë°˜í™˜í•œë‹¤.
    - ì¦‰, ì´ í™•ì¥ í”„ë¡œí¼í‹°ëŠ” **ì €ì¥ìš© íƒ€ì…(Long)ê³¼ í‘œí˜„ìš© íƒ€ì…(Date)ì„ ì´ì–´ì£¼ëŠ” ë³€í™˜ê¸°** ì—­í• ì„ í•˜ë©°, ê°œë°œìê°€ ë” ì§ê´€ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

ğŸ‘‰ ì¦‰, **ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…(ì €ì¥ìš© Long â†” í‘œí˜„ìš© Date)ì„ ë§ì¶°ì£¼ëŠ” ë³€í™˜ê¸° ì—­í• **ì„ getter/setterê°€ í•˜ëŠ” ê±°ì˜ˆìš”.

## 3. Extensions vs members

The biggest difference between members and extensions in terms of use is that extensions need to be imported separately. For this reason, they can be located in a different package. This fact is used when we cannot add a member ourselves. It is also used in projects designed to separate data and behavior. Properties with fields need to be located in a class, but methods can be located separately as long as they only access the public API of the class. Thanks to the fact that extensions need to be imported, we can have many extensions with the same name for the same
type. This is good because different libraries can provide extra methods without causing a conflict. On the other hand, it would be dangerous to have two extensions with the same name but different behaviors. If you have such a situation, it is a code smell and is a clue that someone has abused the extension function capability. Another significant difference is that extensions are not virtual, meaning that they cannot be redefined in derived classes. This is why if you have an extension defined on both a supertype and a subtype, the compiler decides which function is chosen based on how the variable is typed, not what its actual class is.

## 1) ì“°ì„ì˜ ì°¨ì´ â€” â€œì–´ë””ì— ë‘ê³ , ì–´ë–»ê²Œ ë¶ˆëŸ¬ì˜¤ë‚˜â€

- **ë©¤ë²„**: í´ë˜ìŠ¤ ì•ˆì— ì •ì˜. ê·¸ í´ë˜ìŠ¤ê°€ ê³§ API.
- **í™•ì¥**: í´ë˜ìŠ¤ ë°–(ë³´í†µ ìµœìƒìœ„)ì— ì •ì˜í•˜ê³  **import**í•´ì„œ ì”€ â†’ ë‹¤ë¥¸ íŒ¨í‚¤ì§€/ëª¨ë“ˆì— ë‘¬ë„ ë¨.
    - ì´ ë•ë¶„ì— **ë‚´ê°€ ì†Œìœ í•˜ì§€ ì•Šì€ íƒ€ì…**(ì˜ˆ: í‘œì¤€/ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬)ì— â€œë‚´ ë©”ì„œë“œâ€ë¥¼ **ë§ë¶™ì´ëŠ” ëŠë‚Œ**ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥.
    - ë°ì´í„°(í•„ë“œ)ëŠ” í´ë˜ìŠ¤ë¡œ, **í–‰ë™(ë©”ì„œë“œ)**ëŠ” í™•ì¥ìœ¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ì„¤ê³„ë„ ê°€ëŠ¥.

> ê°™ì€ ì´ë¦„ì˜ í™•ì¥ì„ ì—¬ëŸ¬ ê³³ì—ì„œ ì œê³µí•´ë„ importë¡œ ì„ íƒí•´ ì“¸ ìˆ˜ ìˆì–´ ì¶©ëŒì„ í”¼í•¨(í•˜ì§€ë§Œ ê°™ì€ ì´ë¦„Â·ë‹¤ë¥¸ ë™ì‘ì„ ì—¬ëŸ¬ êµ°ë°ì„œ ì“°ê²Œ ë˜ë©´ ì½”ë“œ ìŠ¤ë©œ!).
> 

---

## 2) ë””ìŠ¤íŒ¨ì¹˜ì˜ ì°¨ì´ â€” â€œëˆ„ê°€ í˜¸ì¶œë ì§€ ì–´ë–»ê²Œ ê²°ì •ë˜ë‚˜â€

- **ë©¤ë²„ í•¨ìˆ˜**: **ê°€ìƒ(virtual) ë””ìŠ¤íŒ¨ì¹˜** â†’ **ëŸ°íƒ€ì„ì˜ ì‹¤ì œ íƒ€ì…** ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë²„ë¼ì´ë“œê°€ ë™ì‘.

**ì˜ˆì œ 1) í™•ì¥ í•¨ìˆ˜ëŠ” ì •ì  ë””ìŠ¤íŒ¨ì¹˜ (ì£¼ì„ í¬í•¨)**

```kotlin
open class View
class Button : View()

fun View.printMe() {
    println("I'm a View")
}

fun Button.printMe() {
    println("I'm a Button")
}

fun main() {
    val button: Button = Button()
    button.printMe()      // âœ… ì»´íŒŒì¼íƒ€ì„ íƒ€ì…ì´ Button â†’ "I'm a Button"

    val view: View = button
    view.printMe()        // âœ… ì»´íŒŒì¼íƒ€ì„ íƒ€ì…ì´ View   â†’ "I'm a View"
    // ì£¼ì˜: ì‹¤ì œ ê°ì²´ëŠ” Buttonì´ì–´ë„, ë³€ìˆ˜ íƒ€ì…ì´ Viewë¼ì„œ View í™•ì¥ì´ ì„ íƒë¨(ì •ì ).
}

```

The behavior of extension functions is different from member functions. Member functions are virtual, so up-casting the type of an object does not influence which member function is chosen.

**ì˜ˆì œ 2) ë©¤ë²„ í•¨ìˆ˜ëŠ” ê°€ìƒ ë””ìŠ¤íŒ¨ì¹˜ (ì£¼ì„ í¬í•¨)**

```kotlin
open class View {
    open fun printMe() { println("I'm a View") }
}
class Button : View() {
    override fun printMe() { println("I'm a Button") }
}
fun main() {
    val button: Button = Button()
    button.printMe()      // "I'm a Button"

    val view: View = button
    view.printMe()        // âœ… ì‹¤ì œ ê°ì²´(Button) ê¸°ì¤€ â†’ "I'm a Button"
}

```

This behavior is the result of the fact that extension functions are compiled under the hood into normal functions in which the extensionâ€™s receiver is placed as the first argument:

ì™œ ë‹¤ë¥¼ê¹Œ? í™•ì¥ì€ **ë°”ì´íŠ¸ì½”ë“œì—ì„œ ê·¸ëƒ¥ ì¼ë°˜ ì •ì  í•¨ìˆ˜**(ì²« ë²ˆì§¸ ì¸ìì— ë¦¬ì‹œë²„ê°€ ë“¤ì–´ê°€ëŠ”)ë¡œ ì»´íŒŒì¼ë˜ê¸° ë•Œë¬¸ì´ì—ìš”.

## 3) â€œí™•ì¥ì€ ì •ì  ì˜¤ë²„ë¡œë“œâ€ë¡œ ì´í•´í•˜ê¸° (ì–¸ë”ë”í›„ë“œ ëŒ€ì‘ ì˜ˆì‹œ)

```kotlin
open class View
class Button : View()

// í™•ì¥ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ, ì‹¤ì œë¡  ì´ëŸ° ì˜¤ë²„ë¡œë“œëœ ì •ì  í•¨ìˆ˜ ë‘ ê°œì¼ ë¿:
fun printMe(view: View)   { println("I'm a View") }
fun printMe(button: Button) { println("I'm a Button") }

fun main() {
    val button: Button = Button()
    printMe(button)   // Button ì˜¤ë²„ë¡œë“œ
    val view: View = button
    printMe(view)     // View ì˜¤ë²„ë¡œë“œ
}
```

Another consequence of what extensions are under the hood
is that we define extensions on types, not on classes. This

gives us more freedom. For instance, we can define an exten-
sion on a nullable or generic type:

## 4) íƒ€ì…ì„ ëŒ€ìƒìœ¼ë¡œ í™•ì¥í•œë‹¤ â€” â€œí´ë˜ìŠ¤ê°€ ì•„ë‹ˆë¼ â€˜íƒ€ì…â€™â€

í™•ì¥ì€ **í´ë˜ìŠ¤ ì •ì˜ë¥¼ ë°”ê¾¸ëŠ” ê²Œ ì•„ë‹ˆë¼, íƒ€ì… ì‹œê·¸ë‹ˆì²˜**ì— ë¶™ìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ **nullable**ì´ë‚˜ **ì œë„¤ë¦­ íƒ€ì…**ì—ë„ í™•ì¥ ê°€ëŠ¥!

```kotlin
// inline fun CharSequence?.isNullOrBlank(): Boolean {
// // (skipped contract definition)
// return this == null || this.isBlank()
// }
// fun Iterable<Int>.sum(): Int {
// var sum: Int = 0
// for (element in this) {
// sum += element
// }
// return sum
// }

// nullable ë¦¬ì‹œë²„ í™•ì¥
inline fun CharSequence?.isNullOrBlank(): Boolean =
    this == null || this.isBlank()

// ì œë„¤ë¦­ ë¦¬ì‹œë²„ í™•ì¥
fun Iterable<Int>.sum(): Int {
    var s = 0
    for (e in this) s += e
    return s
}

```

## 4) í™•ì¥ì€ í´ë˜ìŠ¤ì˜ ë©¤ë²„ê°€ ì•„ë‹ˆë‹¤ â€” â€œë¦¬í”Œë ‰ì…˜/í”„ë¡œì„¸ì„œ ê´€ì â€

- í™•ì¥ì€ **í´ë˜ìŠ¤ ì°¸ì¡°(ë¦¬í”Œë ‰ì…˜) ìƒ ë©¤ë²„ ëª©ë¡ì— ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŒ**.
- ê·¸ë˜ì„œ **ì–´ë…¸í…Œì´ì…˜ í”„ë¡œì„¸ì„œê°€ í´ë˜ìŠ¤ ë©¤ë²„ë¥¼ ìŠ¤ìº”í•  ë•Œ í™•ì¥ì€ ê³ ë ¤ë˜ì§€ ì•ŠìŒ**.
    - ë°˜ëŒ€ë¡œ ë§í•˜ë©´, **ë¹„í•µì‹¬ ë¡œì§ì„ í™•ì¥ìœ¼ë¡œ ë¶„ë¦¬**í•˜ë©´ í”„ë¡œì„¸ì„œ ìŠ¤ìº” ëŒ€ìƒì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ë¹ ì§.

The last important difference is that extensions are not listed
as members in the class reference. This is why they are not
considered by annotation processors; it is also why, when
we process a class using annotation processing, we cannot
extract elements that should be processed into extensions.
On the other hand, if we extract non-essential elements into
extensions, we donâ€™t need to worry about them being seen by
those processors.We donâ€™t need to hide them because they are
not in the class they extend anyway.

## 5) ì¤‘ìš”í•œ íŒ & ì£¼ì˜ì 

- **ë©¤ë²„ê°€ ì´ê¸°ê³ , í™•ì¥ì€ ì§„ë‹¤**: ê°™ì€ ì‹œê·¸ë‹ˆì²˜ì˜ **ë©¤ë²„ í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ë©´ ë©¤ë²„ê°€ í•­ìƒ ìš°ì„ **ì…ë‹ˆë‹¤.
- **ì´ë¦„ ì¶©ëŒ**: ì„œë¡œ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê°™ì€ ì´ë¦„ í™•ì¥ì„ í•¨ê»˜ ì“°ë©´ í˜¼ë€. í•„ìš”í•˜ë©´ **ëª…ì‹œì  import**ë‚˜ **import alias**ë¡œ êµ¬ë¶„í•˜ì„¸ìš”.
- **ìº¡ìŠí™”**: í™•ì¥ì€ **private/protected ë©¤ë²„ì— ì ‘ê·¼ ë¶ˆê°€** â†’ ë°˜ë“œì‹œ **ê³µê°œëœ API**ë¡œë§Œ êµ¬í˜„í•˜ì„¸ìš”.
- **ìƒíƒœ ì—†ìŒ**: í™•ì¥ í”„ë¡œí¼í‹°ì—ëŠ” **ë°±í‚¹ í•„ë“œê°€ ì—†ë‹¤**(getter/setterë¡œë§Œ êµ¬í˜„).
- **ì„¤ê³„ ì›ì¹™**: í´ë˜ìŠ¤ë¥¼ ì†Œìœ /ì œì–´í•  ìˆ˜ ìˆìœ¼ë©´ **ë©¤ë²„**ë¥¼, ê·¸ë ‡ì§€ ì•Šê±°ë‚˜ APIë¥¼ ê°€ë³ê²Œ ìœ ì§€í•˜ê³  ì‹¶ë‹¤ë©´ **í™•ì¥**ì„ ê³ ë ¤.

## 4. Extension functions on object declarations

We can define extensions on object declarations.

4-1) object ì„ ì–¸ì— í™•ì¥ í•¨ìˆ˜ ë¶™ì´ê¸°

```kotlin
object A

// A ì‹±ê¸€í†¤ì— "foo" ê¸°ëŠ¥ì„ 'ë§ë¶™ì„'
fun A.foo() { /* ... */ }

fun main() {
    A.foo()           // âœ… AëŠ” ì‹±ê¸€í†¤ì´ë¯€ë¡œ ì´ë ‡ê²Œ ë°”ë¡œ í˜¸ì¶œ
    val a: A = A
    a.foo()           // âœ… ë³€ìˆ˜ë¡œ ë°›ì•„ë„ ë™ì¼
}
```

í™•ì¥ í•¨ìˆ˜ëŠ” **í´ë˜ìŠ¤ì— ì§„ì§œë¡œ ì¶”ê°€ë˜ëŠ” ê²Œ ì•„ë‹ˆë¼** ë°”ê¹¥ì˜ **ì •ì  í•¨ìˆ˜**ë¡œ ì»´íŒŒì¼ë©ë‹ˆë‹¤(ë¦¬ì‹œë²„ë¥¼ ì²« ë²ˆì§¸ ì¸ìë¡œ ë°›ëŠ” í˜•íƒœ).

To define an extension function on a companion object, we
need to use the companion objectâ€™s real name. If this name is
not set explicitly, the default one is â€œCompanionâ€. To define
an extension function on a companion object, this companion
object must exist. This is why some classes define companion
objects without bodies.

**4-2) companion ê°ì²´ì— í™•ì¥ í•¨ìˆ˜ ë¶™ì´ê¸°**

```kotlin
class A {
    companion object // â† ë¹„ì–´ ìˆì–´ë„ 'companion'ì´ 'ì¡´ì¬'í•´ì•¼ í™•ì¥ ê°€ëŠ¥
}

// ê¸°ë³¸ ì´ë¦„ì€ "Companion" (ì§ì ‘ ì´ë¦„ì„ ì¤„ ìˆ˜ë„ ìˆìŒ)
fun A.Companion.foo() { /* ... */ }

fun main() {
    A.foo()                 // âœ… companion í™•ì¥ì„ íƒ€ì…ëª…ìœ¼ë¡œ í˜¸ì¶œ
    val a: A.Companion = A
    a.foo()                 // âœ… companion ì°¸ì¡°ë¡œë„ í˜¸ì¶œ
}
```

**ì¤‘ìš”**

- companion í™•ì¥ì„ ë§Œë“¤ë ¤ë©´ **companion objectê°€ ì‹¤ì œë¡œ ìˆì–´ì•¼** í•©ë‹ˆë‹¤(ëª¸ì²´ê°€ ë¹„ì–´ë„ OK).
- í™•ì¥ í•¨ìˆ˜ëŠ” **private/protected ë©¤ë²„ì— ì ‘ê·¼ ë¶ˆê°€**.
- ìë°”ì—ì„œ ë¶€ë¥´ë©´ `A.foo()`ê°€ ì•„ë‹ˆë¼ **`PlaygroundKt.foo(A.Companion)`** ê°™ì€ ì •ì  í•¨ìˆ˜ í˜¸ì¶œ í˜•íƒœê°€ ë©ë‹ˆë‹¤(Interop ì°¸ê³ ).

## 5. Member extension functions

It is possible to define extension functions inside classes. Such
functions are known as member extension functions.

```kotlin
class Telephone {
    // 'String'ì— ëŒ€í•œ í™•ì¥ì„ 'Telephone' í´ë˜ìŠ¤ ë‚´ë¶€ì— ì •ì˜
    fun String.call() {
        // this       â†’ í™•ì¥ ë¦¬ì‹œë²„(String)
        // this@Telephone â†’ ë””ìŠ¤íŒ¨ì¹˜ ë¦¬ì‹œë²„(Telephone)
        // ...
    }

    fun demo() {
        "123".call()     // âœ… í´ë˜ìŠ¤ ë‚´ë¶€ë¼ì„œ í˜¸ì¶œ ê°€ëŠ¥
    }
}

val t = Telephone()
with(t) { "456".call() }  // âœ… të¥¼ ë””ìŠ¤íŒ¨ì¹˜ ë¦¬ì‹œë²„ë¡œ ë‘” ìŠ¤ì½”í”„ì—ì„œ í˜¸ì¶œ
"789".call()              // âŒ ì»´íŒŒì¼ ì—ëŸ¬: ë””ìŠ¤íŒ¨ì¹˜ ë¦¬ì‹œë²„ ë²”ìœ„ ë°–

```

Member extension functions are considered a code smell, and
we should avoid using them if we donâ€™t have a good reason.

### ì™œ â€œì½”ë“œ ìŠ¤ë©œâ€ë¡œ ì—¬ê²¨ì§€ë‚˜?

- *ì´ì¤‘ ë¦¬ì‹œë²„(í™•ì¥/ë””ìŠ¤íŒ¨ì¹˜)**ë¡œ ì¸í•´ ê°€ë…ì„±ì´ ë–¨ì–´ì§€ê³ , **í•´ê²° ê·œì¹™(this/this@Outer)**ì´ í—·ê°ˆë¦¬ê¸° ì‰½ìŠµë‹ˆë‹¤.
- í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ê°€ **ìŠ¤ì½”í”„ì— ìˆì–´ì•¼ë§Œ** ì“¸ ìˆ˜ ìˆì–´ **API ë…¸ì¶œ/ì¬ì‚¬ìš©ì„±**ì´ ë‚®ì•„ì§‘ë‹ˆë‹¤.
- **ì˜¤ë²„ë¡œë“œ/ì„€ë„ì‰** ì‹œ í•´ì„ì´ ì–´ë µê³ , í…ŒìŠ¤íŠ¸/ê²€ìƒ‰ì„±ë„ ë–¨ì–´ì§‘ë‹ˆë‹¤.

> ë‹¤ë§Œ, DSL(ë„ë©”ì¸ ì „ìš© ì–¸ì–´) ìŠ¤íƒ€ì¼(API ë¹Œë”, HTML DSL, Gradle ìŠ¤í¬ë¦½íŠ¸ ë“±)ì—ì„œëŠ” ì˜ë„ì ìœ¼ë¡œ ì“°ì´ê¸°ë„ í•©ë‹ˆë‹¤.
> 
> 
> ì¼ë°˜ ë¡œì§ì—ì„œëŠ” **ë°”ê¹¥(ìµœìƒìœ„)ì˜ í™•ì¥ í•¨ìˆ˜** ë˜ëŠ” **ì§„ì§œ ë©¤ë²„ í•¨ìˆ˜**ê°€ ë” ëª…ë£Œí•œ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.
> 

## 6. Use cases

The most important use-case for extensions is adding meth-
ods and properties to APIs that we donâ€™t control. A good

example is displaying a toast or hiding a view on Android.
Both these operations are unnecessarily complicated, so we
like to define extensions to simplify them.

## 1) ë‚´ê°€ ì†Œìœ í•˜ì§€ ì•Šì€ íƒ€ì…(API)ì— ê¸°ëŠ¥ â€œë§ë¶™ì´ê¸°â€

- **í•µì‹¬**: Android SDK ê°™ì€ **ì™¸ë¶€ íƒ€ì…**(Context, View)ì— **í¸ì˜ ê¸°ëŠ¥**ì„ í™•ì¥ìœ¼ë¡œ ì¶”ê°€í•´ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ë¥¼ ì¤„ì„.
- **íš¨ê³¼**: `Toast.makeText(...).show()` / `view.visibility = GONE` ê°™ì€ ì¥í™©í•œ í˜¸ì¶œì„ **ì§§ê³  ì¼ê´€ëœ API**ë¡œ ìº¡ìŠí™”.
- **í¬ì¸íŠ¸**: í™•ì¥ì€ **í´ë˜ìŠ¤ ë°–(ìµœìƒìœ„)**ì— ì •ì˜ë˜ê³ , **ë¦¬ì‹œë²„ íƒ€ì…**(ì•ì— ë¶™ì€ `Context`, `View`)ì„ í†µí•´ â€œë¶™ì—¬ ì“°ëŠ”â€ ë¬¸ë²•ì„ ì œê³µ.

```kotlin
fun Context.toast(message: String) {
    // this == í˜¸ì¶œí•œ Context (ì˜ˆ: Activity, Application)
    Toast.makeText(this, message, Toast.LENGTH_LONG).show()
}

fun View.hide() {
    // this == í˜¸ì¶œí•œ View (ì˜ˆ: Button, TextView ë“±)
    this.visibility = View.GONE
}
```

However, there are also cases where we prefer to use exten-
sions instead of members. Consider the Iterable interface,

which has only one member function, iterator; however, it
has many methods, which are defined in the standard library
as extensions67, like onEach or joinToString. The fact that these
are defined as extensions allows for smaller and more concise
interfaces.

## 2) ë©¤ë²„ë³´ë‹¤ í™•ì¥ì„ ì„ í˜¸í•˜ëŠ” ê²½ìš° â€” â€œì–‡ì€ ì¸í„°í˜ì´ìŠ¤â€

- **í•µì‹¬**: í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `Iterable`ì€ **í•µì‹¬ ê³„ì•½ë§Œ ë©¤ë²„ë¡œ**(= `iterator`) ë‘ê³ ,
    
    `onEach`, `joinToString` ë“± **ìˆ˜ë§ì€ ìœ í‹¸ì€ í™•ì¥ í•¨ìˆ˜ë¡œ** ì œê³µ â†’ **ì‘ê³  ê°„ê²°í•œ ì¸í„°í˜ì´ìŠ¤** ìœ ì§€.
    

```kotlin
interface Iterable<out T> {
    operator fun iterator(): Iterator<T>
    // ë‚˜ë¨¸ì§€ map/filter/joinToString/onEach ... ë“±ì€ í™•ì¥ í•¨ìˆ˜ë¡œ ì œê³µë¨
}
```

Extension functions are also more elastic than regular
functions. This is mainly because they are defined on types,
so we can define extensions on types like Iterable<Int> or
Iterable<T>.

## 3) í™•ì¥ì€ â€œí´ë˜ìŠ¤ê°€ ì•„ë‹ˆë¼ íƒ€ì…â€ì— ë¶™ëŠ”ë‹¤ â€” ì œë„¤ë¦­/íŠ¹ìˆ˜í™”ì— ìœ ì—°

- **í•µì‹¬**: í™•ì¥ì€ **íƒ€ì…** ëŒ€ìƒì´ë¼ `Iterable<T>`, `Iterable<Int>` ê°™ì€ **ì œë„¤ë¦­/íŠ¹ìˆ˜ íƒ€ì…**ì— ì •í™•í•˜ê²Œ ë¶™ì¼ ìˆ˜ ìˆìŒ.
- **íš¨ê³¼**: í˜¸ì¶œ ì¸¡ ë¬¸ë§¥ì´ **ìì—°ìŠ¤ëŸ½ê³  ì½ê¸° ì‰¬ì›€**.

```kotlin
fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {
    // this == í˜¸ì¶œí•œ Iterable<T>
    if (this is Collection) {
        if (size <= 1) return this.toList()
        @Suppress("UNCHECKED_CAST")
        return (toTypedArray<Comparable<T>>() as Array<T>)
            .apply { sort() } // ë°°ì—´ ì •ë ¬ (Comparable<T> í•„ìš”)
            .asList()
    }
    // ì»¬ë ‰ì…˜ì´ ì•„ë‹ ê²½ìš°, ë³€ê²½ ê°€ëŠ¥í•œ ë¦¬ìŠ¤íŠ¸ë¡œ ë³µì‚¬ í›„ ì •ë ¬
    return toMutableList().apply { sort() }
}

fun Iterable<Int>.sum(): Int {
    var sum: Int = 0
    for (element in this) { // this == í˜¸ì¶œí•œ Iterable<Int>
        sum += element
    }
    return sum
}

```

In bigger projects, we often have similar classes for differ-
ent parts of our application. Letâ€™s say that you implement a

backend for an online shop, and you have a class Product to
represent all the products.

## 4) ë„ë©”ì¸ ëª¨ë¸ â†” ì „ì†¡ ëª¨ë¸(DTO) ë¶„ë¦¬ & ë³€í™˜

- **ìƒí™©**: ë‚´ë¶€ ë„ë©”ì¸ `Product`ì™€ API ì „ì†¡ìš© `ProductJson`ì„ **ë¶„ë¦¬**í•´ì•¼ í•¨(ë‚´ë¶€ ë³€ê²½ì´ API ìŠ¤í‚¤ë§ˆì— ì „íŒŒë˜ì§€ ì•Šë„ë¡).
- **ë¬¸ì œ**: ë³€í™˜ì„ **ë©¤ë²„**ë¡œ ë„£ìœ¼ë©´ í´ë˜ìŠ¤ê°€ **ë¬´ê±°ì›Œì§€ê³  ê²°í•©ë„â†‘**.
- **í•´ê²°**: **í™•ì¥ í•¨ìˆ˜**ë¡œ `toProduct`/`toProductJson`ì„ ì •ì˜í•´ **í•œ ê³³ì— ì‘ì§‘**(ëŒ€ì¹­ì ì´ê³  ë¶„ë¦¬ëœ ë³€í™˜ ë ˆì´ì–´).

```kotlin
import java.math.BigDecimal

class Product(
    val id: String,
    val title: String,
    val imgSrc: String,
    val description: String,
    val price: BigDecimal,
    val type: ProductType,
    // ...
)
```

You also have a similar (but not identical) class called
ProductJson, which is used to represent the objects you
use in your application API responses or that you read from
API requests.

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
)
```

Instances of Product are used in your application, and
instances of ProductJson are used in the API. These objects
need to be separated because, for instance, you donâ€™t want to
change your API response when you change a property name
in an internal class. Yet, we often need to transform between
Product and ProductJson. For this, we could define a member
function toProduct.

**(ëŒ€ì•ˆ 1) ë©¤ë²„ë¡œ ë„£ëŠ” ë°©ì‹ â€” í´ë˜ìŠ¤ê°€ ë¹„ëŒ€í•´ì§**

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
) {
    fun toProduct() = Product(
        id = this.id,
        title = this.title,
        imgSrc = this.img,
        description = this.desc,
        price = BigDecimal(price), // String â†’ BigDecimalë¡œ íŒŒì‹±
        type = enumValueOf<ProductType>(this.type) // String â†’ enum
    )
}

```

Not everyone likes this solution as it makes ProductJson bigger
and more complicated. It is also not useful in transforming 

from Product to ProductJson because in most modern architec-
tures we donâ€™t want domain classes (like Product) to be aware

of details such as their API representation. A better solution

is to define bothtoProduct and toProductJson as extension func-
tions, then locate them together next to the ProductJson class.

It is good to locate those transformation functions next to
each other, because they have a lot in common.

**(ê¶Œì¥) í™•ì¥ í•¨ìˆ˜ë¡œ ë¶„ë¦¬ â€” ë³€í™˜ ë¡œì§ ì‘ì§‘/ëŒ€ì¹­/ë¶„ë¦¬**

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
)

// DTO â†’ ë„ë©”ì¸
fun ProductJson.toProduct() = Product(
    id = this.id,
    title = this.title,
    imgSrc = this.img,
    description = this.desc,
    price = BigDecimal(this.price),               // String â†’ BigDecimal
    type = enumValueOf<ProductType>(this.type)    // String â†’ enum
)

// ë„ë©”ì¸ â†’ DTO
fun Product.toProductJson() = ProductJson(
    id = this.id,
    title = this.title,
    img = this.imgSrc,
    desc = this.description,
    price = this.price.toString(), // BigDecimal â†’ String
    type = this.type.name          // enum â†’ String
)
```

**ì¥ì  ìš”ì•½**

- ë³€í™˜ ë¡œì§ì„ **í•œ íŒŒì¼/íŒ¨í‚¤ì§€ì— ëª¨ì•„** ì‘ì§‘ë„â†‘, ê°€ë…ì„±â†‘
- **ì–‘ë°©í–¥ ë³€í™˜**ì„ ëŒ€ì¹­ì ìœ¼ë¡œ ê´€ë¦¬
- ë„ë©”ì¸ ëª¨ë¸ì´ **API í‘œí˜„ ì„¸ë¶€ì‚¬í•­**(ë¬¸ìì—´ íŒŒì‹±/enum ë³€í™˜ ë“±)ì— **ì˜¤ì—¼ë˜ì§€ ì•ŠìŒ**

This seems to be a popular pattern, both on the backend and
in Android applications.

## 7. Summary

In this chapter, weâ€™ve learned about extensions - a powerful
Kotlin feature that is often used to create convenient and
meaningful utils and to control our code better. However,
with great power comes great responsibility. We should not
be worried about using extensions, but we should use them
consciously and only where they make sense.
In the next chapter, we will finally introduce collections so
that we can talk about lists, sets, maps, and arrays. Thereâ€™s a
lot ahead, so get ready.

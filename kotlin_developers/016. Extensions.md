The most intuitive way to definemethods and properties is in-
side classes. Such elements are called classmembers or, more

concretely, member functions and member properties.

```kotlin
class Telephone(
		// member property
		val number: String
) {
		// member function
		fun call() {
				print("Calling $number")
		}
}

fun main() {
		// Usage
		val telephone = Telephone("123456789")
		println(telephone.number) // 123456789
		telephone.call() // Calling 123456789
}
```

On the other hand, Kotlin allows another way to define func-
tions and properties that are called on an instance: extensions.

Extension functions are defined like regular functions, but
they additionally have an extra type (and dot) before the
function name. In the example below, the call function is
defined as an extension function on Telephone, so it needs to
be called on an instance of this type.

```kotlin
class Telephone(
		val number: String
)

fun Telephone.call() {
		print("Calling $number")
}

fun main() {
		// Usage
		val telephone = Telephone("123456789")
		telephone.call() // Calling 123456789
}
```

**확장 함수**: 클래스 바깥에서, 마치 그 클래스의 멤버인 것처럼 동작하는 함수

👉 두 경우 모두 `telephone.call()`처럼 똑같이 호출 가능.

👉 차이: 멤버 함수는 클래스 내부 정의, 확장 함수는 클래스 외부에서 "붙이는 것처럼" 정의.

Both member functions and extension functions
are referred to as methods.

Extension functions can be defined on types we don’t control,
for instance String. This gives us the power to extend external
APIs with our own functions.

```kotlin
fun String.remove(value: String) = this.replace(value, "")

fun main() {
		println("Who Framed Roger Rabbit?".remove(" "))
		// WhoFramedRogerRabbit?
}
```

- **Receiver type**: 확장을 적용할 대상 타입 → `String`, `Telephone` 등
- **Receiver**: 함수가 실제로 실행될 때 그 인스턴스 (`this`)
- `String` → Receiver type
- `this` (`"Who Framed Roger Rabbit?"`) → Receiver

Take a look at the example above. We defined the extension
function remove on String, so we need to call this function on
an object of type String. Inside the function, we reference
this object using the this keyword, just like inside member
functions. The this keyword can also be used implicitly.

```kotlin
// explicit this
fun String.remove(value: String) = this.replace(value, "")
// implicit this
fun String.remove(value: String) = replace(value, "")
```

- `fun <ReceiverType>.<함수명>(파라미터): 반환타입`
- 함수 본문에서 `this` 키워드 사용 → Receiver 객체를 가리킴
- `this`는 **명시적으로 써도 되고, 생략 가능**

The this keyword is known as the receiver. Inside extension
functions, we call it an extension receiver. Inside member
functions, we call it a dispatch receiver. The type we extend
with the extension function is called the receiver type.

![스크린샷 2025-08-29 오전 10.24.35.png](attachment:a444b868-b4fe-42e8-80ff-a8997150446d:스크린샷_2025-08-29_오전_10.24.35.png)

- 사실 확장 함수는 단순히 **정적(Static) 함수**일 뿐.
- 차이: 첫 번째 매개변수(Receiver 객체)를 “앞에 점(.) 찍고 호출”하는 문법적 편의를 제공.
- 즉, 아래 두 코드는 동일:

```kotlin
"abc".remove("a")
remove("abc", "a") // 내부적으로 이렇게 변환됨
```

- 확장 함수는 **클래스의 private, protected 멤버에 접근 불가**.
- 즉, 안전하게 “외부에서 덧붙이는 기능”만 제공.

- 확장 함수 = **외부에서 타입에 메서드를 “붙여 쓰는” 문법적 설탕**
- Receiver type으로 대상을 지정하고, `this`로 해당 인스턴스에 접근.
- 멤버 함수처럼 보이지만, 실제론 단순한 정적 함수 → 안전하게 외부 API를 확장 가능.

Extension functions behave a lot like member functions.
When developers learn this, they are often concerned about
objects’ safety, but this isn’t a problem as extensions do not
have any special access to class elements. The only difference
between top-level extension functions and other top-level
functions is that they are called on an instance instead of
receiving this instance as a regular argument. To see this
more clearly, let’s take a look under the hood of extension
functions.

## 1. Extension functions under the hood

To understand extension functions, let’s again use “Tools > Kotlin > Show Kotlin bytecode” and “Decompile” (as ex-plained in chapter Your first program in Kotlin in section What is under the hood on JVM?). We will compile and decompile to Java our remove function definition and its call:

```kotlin
fun String.remove(value: String) = this.replace(value, "")

fun main() {
		println("A B C".remove(" ")) // ABC
}
```

As a result, you should see the following code:

```kotlin
public final class PlaygroundKt {
		@NotNull
		public static final String remove(
				@NotNull String $this$remove, // ← 원래는 Receiver type (String)
				@NotNull String value
		) {
				// parameters not-null checks
				return StringsKt.replace$default(
						$this$remove, // ← 실제 Receiver가 첫 번째 인자로 전달됨
						value,
						"" // 교체할 문자열
						// plus default values
				);
		}

		public static final void main(@NotNull String[] args) {
				// parameter not-null check
        String var1 = remove("A B C", " "); // ← static 메서드 호출
				System.out.println(var1);
		}
}
```

- **Receiver type(String)** → 단순히 **첫 번째 매개변수**로 변환됨 (`$this$remove`).
- **확장 함수 호출 `"A B C".remove(" ")`** → 사실상 `remove("A B C", " ")`로 변환됨.
- 즉, **확장 함수 = 단순한 정적 함수 + 특별한 문법적 설탕**.

Notice what happened to the receiver type: it became a param-
eter. You can also see that, under the hood, remove is not called

on an object. It is just a regular static function.
When you define an extension function, you do not really add
anything to a class. It is just syntactic sugar. Let’s compare the
two following implementations of remove.

```kotlin
fun remove(text: String, value: String) = text.replace(value, "")
fun String.remove(value: String) = this.replace(value, "")
```

- **실제로 생성되는 바이트코드**는 거의 동일.
- **차이점**: 호출 방식
    - 일반 함수 → `remove("A B C", " ")`
    - 확장 함수 → `"A B C".remove(" ")` (더 자연스럽고 객체지향적으로 보임)

Under the hood, they are nearly identical. The difference is
in how Kotlin expects them to be called. Regular functions
receive all their arguments in regular argument positions.
Extension functions are called “on” a value.

## 2. Extension properties

An extension cannot hold a state, so it cannot have fields.
Although properties do not need fields, they can be defined by
their getters and setters. This is why we can define extension
properties if they do not need a backing field and are defined
by accessors.

- 확장 함수처럼 **기존 타입에 프로퍼티를 “붙이는 것처럼” 정의** 가능.
- 단, **상태(state)**를 가질 수 없으므로 **백킹 필드(backing field)**는 없음.
- 대신 **getter/setter**로만 동작.

```kotlin
val <T> List<T>.lastIndex: Int
		get() = size - 1
```

List<T>에 lastIndex 프로퍼티를 확장으로 추가.

실제로는 함수처럼 동작하는 문법적 설탕일 뿐 → 내부적으로 getLastIndex(list) 같은 static 함수로 변환됨.

호출 예시:

```kotlin
val nums = listOf(10, 20, 30)
println(nums.lastIndex) // 2
```

Extension properties are very popular on Android, where ac-
cessing different services is complex and repetitive. Defining

extension properties lets us do this much more easily.

- Android API는 서비스 접근이 번거롭고 보일러플레이트 코드가 많음.
- 확장 프로퍼티를 쓰면 훨씬 간단하게 접근 가능.

```kotlin
val Context.inflater: LayoutInflater
    get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater

val Context.notificationManager: NotificationManager
    get() = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

val Context.alarmManager: AlarmManager
    get() = getSystemService(Context.ALARM_SERVICE) as AlarmManager
```

👉 원래는 `getSystemService(...) as ...` 를 매번 써야 하지만,

👉 확장 프로퍼티 덕분에 `context.inflater`, `context.notificationManager`처럼 간단하게 사용 가능.

Extension properties can define both a getter and a setter.

Here is an extension property that provides a different repre-
sentation of a user birthdate:

확장 프로퍼티도 **읽기(get)**, **쓰기(set)** 모두 정의 가능.

```kotlin
class User {
		// ...
		var birthdateMillis: Long? = null
}

var User.birthdate: Date?
		get() {
				val millis = birthdateMillis
				return if (millis == null) null else Date(millis)
		}
		set(value) {
				birthdateMillis = value?.time
		}
```

- `User.birthdate`라는 **Date? 타입의 프로퍼티**를 새로 제공.
- 내부에서는 원래 가지고 있던 `birthdateMillis` (Long)를 사용.
- 호출 예시:

```kotlin
val user = User()
user.birthdate = Date()       // setter 동작
println(user.birthdate)       // getter 동작

```

1. 클래스 안에 있는건 프로퍼티
2. Kotlin은 자동으로 백킹필드를 만들어서 값을 저장함
    - `user.birthdateMillis = 1000L` → 값을 백킹 필드에 기록
    - `println(user.birthdateMillis)` → 백킹 필드에서 값을 읽음
    - 즉, 별도의 로직을 안 쓰면 단순히 “값을 저장/꺼내는 통”이라고 보시면 돼요.
3. `birthdate`라는 **새로운 프로퍼티**를 User 클래스에 “확장”으로 붙인 겁니다. **확장 프로퍼티에는 백킹 필드가 없음** → 값을 직접 저장할 수 없어요. 대신 내부적으로 이미 존재하는 `birthdateMillis`를 이용해서 동작합니다.
4. **setter** = 값을 넣을 때 실행되는 코드. **getter** = 값을 꺼낼 때 실행되는 코드.
5. 위의 코드는 원래 Long타입의 백킹필드를 갖는 클래스다. 
    - 확장 프로퍼티 `birthdate`는 **실제 저장소는 `birthdateMillis(Long)`** 를 사용한다. 그래서
    - **setter**는 개발자가 넣은 `Date` 값을 내부 저장소에 맞게 `Long`으로 변환해 저장하고,
    - **getter**는 내부에 저장된 `Long` 값을 꺼내서 사람이 쓰기 좋은 `Date` 객체로 변환해 반환한다.
    - 즉, 이 확장 프로퍼티는 **저장용 타입(Long)과 표현용 타입(Date)을 이어주는 변환기** 역할을 하며, 개발자가 더 직관적으로 사용할 수 있게 해준다.

👉 즉, **서로 다른 타입(저장용 Long ↔ 표현용 Date)을 맞춰주는 변환기 역할**을 getter/setter가 하는 거예요.

## 3. Extensions vs members

The biggest difference between members and extensions in terms of use is that extensions need to be imported separately. For this reason, they can be located in a different package. This fact is used when we cannot add a member ourselves. It is also used in projects designed to separate data and behavior. Properties with fields need to be located in a class, but methods can be located separately as long as they only access the public API of the class. Thanks to the fact that extensions need to be imported, we can have many extensions with the same name for the same
type. This is good because different libraries can provide extra methods without causing a conflict. On the other hand, it would be dangerous to have two extensions with the same name but different behaviors. If you have such a situation, it is a code smell and is a clue that someone has abused the extension function capability. Another significant difference is that extensions are not virtual, meaning that they cannot be redefined in derived classes. This is why if you have an extension defined on both a supertype and a subtype, the compiler decides which function is chosen based on how the variable is typed, not what its actual class is.

## 1) 쓰임의 차이 — “어디에 두고, 어떻게 불러오나”

- **멤버**: 클래스 안에 정의. 그 클래스가 곧 API.
- **확장**: 클래스 밖(보통 최상위)에 정의하고 **import**해서 씀 → 다른 패키지/모듈에 둬도 됨.
    - 이 덕분에 **내가 소유하지 않은 타입**(예: 표준/외부 라이브러리)에 “내 메서드”를 **덧붙이는 느낌**으로 확장 가능.
    - 데이터(필드)는 클래스로, **행동(메서드)**는 확장으로 분리하는 설계도 가능.

> 같은 이름의 확장을 여러 곳에서 제공해도 import로 선택해 쓸 수 있어 충돌을 피함(하지만 같은 이름·다른 동작을 여러 군데서 쓰게 되면 코드 스멜!).
> 

---

## 2) 디스패치의 차이 — “누가 호출될지 어떻게 결정되나”

- **멤버 함수**: **가상(virtual) 디스패치** → **런타임의 실제 타입** 기준으로 오버라이드가 동작.

**예제 1) 확장 함수는 정적 디스패치 (주석 포함)**

```kotlin
open class View
class Button : View()

fun View.printMe() {
    println("I'm a View")
}

fun Button.printMe() {
    println("I'm a Button")
}

fun main() {
    val button: Button = Button()
    button.printMe()      // ✅ 컴파일타임 타입이 Button → "I'm a Button"

    val view: View = button
    view.printMe()        // ✅ 컴파일타임 타입이 View   → "I'm a View"
    // 주의: 실제 객체는 Button이어도, 변수 타입이 View라서 View 확장이 선택됨(정적).
}

```

The behavior of extension functions is different from member functions. Member functions are virtual, so up-casting the type of an object does not influence which member function is chosen.

**예제 2) 멤버 함수는 가상 디스패치 (주석 포함)**

```kotlin
open class View {
    open fun printMe() { println("I'm a View") }
}
class Button : View() {
    override fun printMe() { println("I'm a Button") }
}
fun main() {
    val button: Button = Button()
    button.printMe()      // "I'm a Button"

    val view: View = button
    view.printMe()        // ✅ 실제 객체(Button) 기준 → "I'm a Button"
}

```

This behavior is the result of the fact that extension functions are compiled under the hood into normal functions in which the extension’s receiver is placed as the first argument:

왜 다를까? 확장은 **바이트코드에서 그냥 일반 정적 함수**(첫 번째 인자에 리시버가 들어가는)로 컴파일되기 때문이에요.

## 3) “확장은 정적 오버로드”로 이해하기 (언더더후드 대응 예시)

```kotlin
open class View
class Button : View()

// 확장처럼 보이지만, 실제론 이런 오버로드된 정적 함수 두 개일 뿐:
fun printMe(view: View)   { println("I'm a View") }
fun printMe(button: Button) { println("I'm a Button") }

fun main() {
    val button: Button = Button()
    printMe(button)   // Button 오버로드
    val view: View = button
    printMe(view)     // View 오버로드
}
```

Another consequence of what extensions are under the hood
is that we define extensions on types, not on classes. This

gives us more freedom. For instance, we can define an exten-
sion on a nullable or generic type:

## 4) 타입을 대상으로 확장한다 — “클래스가 아니라 ‘타입’”

확장은 **클래스 정의를 바꾸는 게 아니라, 타입 시그니처**에 붙습니다. 그래서 **nullable**이나 **제네릭 타입**에도 확장 가능!

```kotlin
// inline fun CharSequence?.isNullOrBlank(): Boolean {
// // (skipped contract definition)
// return this == null || this.isBlank()
// }
// fun Iterable<Int>.sum(): Int {
// var sum: Int = 0
// for (element in this) {
// sum += element
// }
// return sum
// }

// nullable 리시버 확장
inline fun CharSequence?.isNullOrBlank(): Boolean =
    this == null || this.isBlank()

// 제네릭 리시버 확장
fun Iterable<Int>.sum(): Int {
    var s = 0
    for (e in this) s += e
    return s
}

```

## 4) 확장은 클래스의 멤버가 아니다 — “리플렉션/프로세서 관점”

- 확장은 **클래스 참조(리플렉션) 상 멤버 목록에 나타나지 않음**.
- 그래서 **어노테이션 프로세서가 클래스 멤버를 스캔할 때 확장은 고려되지 않음**.
    - 반대로 말하면, **비핵심 로직을 확장으로 분리**하면 프로세서 스캔 대상에서 자연스럽게 빠짐.

The last important difference is that extensions are not listed
as members in the class reference. This is why they are not
considered by annotation processors; it is also why, when
we process a class using annotation processing, we cannot
extract elements that should be processed into extensions.
On the other hand, if we extract non-essential elements into
extensions, we don’t need to worry about them being seen by
those processors.We don’t need to hide them because they are
not in the class they extend anyway.

## 5) 중요한 팁 & 주의점

- **멤버가 이기고, 확장은 진다**: 같은 시그니처의 **멤버 함수가 존재하면 멤버가 항상 우선**입니다.
- **이름 충돌**: 서로 다른 라이브러리의 같은 이름 확장을 함께 쓰면 혼란. 필요하면 **명시적 import**나 **import alias**로 구분하세요.
- **캡슐화**: 확장은 **private/protected 멤버에 접근 불가** → 반드시 **공개된 API**로만 구현하세요.
- **상태 없음**: 확장 프로퍼티에는 **백킹 필드가 없다**(getter/setter로만 구현).
- **설계 원칙**: 클래스를 소유/제어할 수 있으면 **멤버**를, 그렇지 않거나 API를 가볍게 유지하고 싶다면 **확장**을 고려.

## 4. Extension functions on object declarations

We can define extensions on object declarations.

4-1) object 선언에 확장 함수 붙이기

```kotlin
object A

// A 싱글톤에 "foo" 기능을 '덧붙임'
fun A.foo() { /* ... */ }

fun main() {
    A.foo()           // ✅ A는 싱글톤이므로 이렇게 바로 호출
    val a: A = A
    a.foo()           // ✅ 변수로 받아도 동일
}
```

확장 함수는 **클래스에 진짜로 추가되는 게 아니라** 바깥의 **정적 함수**로 컴파일됩니다(리시버를 첫 번째 인자로 받는 형태).

To define an extension function on a companion object, we
need to use the companion object’s real name. If this name is
not set explicitly, the default one is “Companion”. To define
an extension function on a companion object, this companion
object must exist. This is why some classes define companion
objects without bodies.

**4-2) companion 객체에 확장 함수 붙이기**

```kotlin
class A {
    companion object // ← 비어 있어도 'companion'이 '존재'해야 확장 가능
}

// 기본 이름은 "Companion" (직접 이름을 줄 수도 있음)
fun A.Companion.foo() { /* ... */ }

fun main() {
    A.foo()                 // ✅ companion 확장을 타입명으로 호출
    val a: A.Companion = A
    a.foo()                 // ✅ companion 참조로도 호출
}
```

**중요**

- companion 확장을 만들려면 **companion object가 실제로 있어야** 합니다(몸체가 비어도 OK).
- 확장 함수는 **private/protected 멤버에 접근 불가**.
- 자바에서 부르면 `A.foo()`가 아니라 **`PlaygroundKt.foo(A.Companion)`** 같은 정적 함수 호출 형태가 됩니다(Interop 참고).

## 5. Member extension functions

It is possible to define extension functions inside classes. Such
functions are known as member extension functions.

```kotlin
class Telephone {
    // 'String'에 대한 확장을 'Telephone' 클래스 내부에 정의
    fun String.call() {
        // this       → 확장 리시버(String)
        // this@Telephone → 디스패치 리시버(Telephone)
        // ...
    }

    fun demo() {
        "123".call()     // ✅ 클래스 내부라서 호출 가능
    }
}

val t = Telephone()
with(t) { "456".call() }  // ✅ t를 디스패치 리시버로 둔 스코프에서 호출
"789".call()              // ❌ 컴파일 에러: 디스패치 리시버 범위 밖

```

Member extension functions are considered a code smell, and
we should avoid using them if we don’t have a good reason.

### 왜 “코드 스멜”로 여겨지나?

- *이중 리시버(확장/디스패치)**로 인해 가독성이 떨어지고, **해결 규칙(this/this@Outer)**이 헷갈리기 쉽습니다.
- 클래스 인스턴스가 **스코프에 있어야만** 쓸 수 있어 **API 노출/재사용성**이 낮아집니다.
- **오버로드/섀도잉** 시 해석이 어렵고, 테스트/검색성도 떨어집니다.

> 다만, DSL(도메인 전용 언어) 스타일(API 빌더, HTML DSL, Gradle 스크립트 등)에서는 의도적으로 쓰이기도 합니다.
> 
> 
> 일반 로직에서는 **바깥(최상위)의 확장 함수** 또는 **진짜 멤버 함수**가 더 명료한 경우가 많습니다.
> 

## 6. Use cases

The most important use-case for extensions is adding meth-
ods and properties to APIs that we don’t control. A good

example is displaying a toast or hiding a view on Android.
Both these operations are unnecessarily complicated, so we
like to define extensions to simplify them.

## 1) 내가 소유하지 않은 타입(API)에 기능 “덧붙이기”

- **핵심**: Android SDK 같은 **외부 타입**(Context, View)에 **편의 기능**을 확장으로 추가해 보일러플레이트를 줄임.
- **효과**: `Toast.makeText(...).show()` / `view.visibility = GONE` 같은 장황한 호출을 **짧고 일관된 API**로 캡슐화.
- **포인트**: 확장은 **클래스 밖(최상위)**에 정의되고, **리시버 타입**(앞에 붙은 `Context`, `View`)을 통해 “붙여 쓰는” 문법을 제공.

```kotlin
fun Context.toast(message: String) {
    // this == 호출한 Context (예: Activity, Application)
    Toast.makeText(this, message, Toast.LENGTH_LONG).show()
}

fun View.hide() {
    // this == 호출한 View (예: Button, TextView 등)
    this.visibility = View.GONE
}
```

However, there are also cases where we prefer to use exten-
sions instead of members. Consider the Iterable interface,

which has only one member function, iterator; however, it
has many methods, which are defined in the standard library
as extensions67, like onEach or joinToString. The fact that these
are defined as extensions allows for smaller and more concise
interfaces.

## 2) 멤버보다 확장을 선호하는 경우 — “얇은 인터페이스”

- **핵심**: 표준 라이브러리의 `Iterable`은 **핵심 계약만 멤버로**(= `iterator`) 두고,
    
    `onEach`, `joinToString` 등 **수많은 유틸은 확장 함수로** 제공 → **작고 간결한 인터페이스** 유지.
    

```kotlin
interface Iterable<out T> {
    operator fun iterator(): Iterator<T>
    // 나머지 map/filter/joinToString/onEach ... 등은 확장 함수로 제공됨
}
```

Extension functions are also more elastic than regular
functions. This is mainly because they are defined on types,
so we can define extensions on types like Iterable<Int> or
Iterable<T>.

## 3) 확장은 “클래스가 아니라 타입”에 붙는다 — 제네릭/특수화에 유연

- **핵심**: 확장은 **타입** 대상이라 `Iterable<T>`, `Iterable<Int>` 같은 **제네릭/특수 타입**에 정확하게 붙일 수 있음.
- **효과**: 호출 측 문맥이 **자연스럽고 읽기 쉬움**.

```kotlin
fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {
    // this == 호출한 Iterable<T>
    if (this is Collection) {
        if (size <= 1) return this.toList()
        @Suppress("UNCHECKED_CAST")
        return (toTypedArray<Comparable<T>>() as Array<T>)
            .apply { sort() } // 배열 정렬 (Comparable<T> 필요)
            .asList()
    }
    // 컬렉션이 아닐 경우, 변경 가능한 리스트로 복사 후 정렬
    return toMutableList().apply { sort() }
}

fun Iterable<Int>.sum(): Int {
    var sum: Int = 0
    for (element in this) { // this == 호출한 Iterable<Int>
        sum += element
    }
    return sum
}

```

In bigger projects, we often have similar classes for differ-
ent parts of our application. Let’s say that you implement a

backend for an online shop, and you have a class Product to
represent all the products.

## 4) 도메인 모델 ↔ 전송 모델(DTO) 분리 & 변환

- **상황**: 내부 도메인 `Product`와 API 전송용 `ProductJson`을 **분리**해야 함(내부 변경이 API 스키마에 전파되지 않도록).
- **문제**: 변환을 **멤버**로 넣으면 클래스가 **무거워지고 결합도↑**.
- **해결**: **확장 함수**로 `toProduct`/`toProductJson`을 정의해 **한 곳에 응집**(대칭적이고 분리된 변환 레이어).

```kotlin
import java.math.BigDecimal

class Product(
    val id: String,
    val title: String,
    val imgSrc: String,
    val description: String,
    val price: BigDecimal,
    val type: ProductType,
    // ...
)
```

You also have a similar (but not identical) class called
ProductJson, which is used to represent the objects you
use in your application API responses or that you read from
API requests.

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
)
```

Instances of Product are used in your application, and
instances of ProductJson are used in the API. These objects
need to be separated because, for instance, you don’t want to
change your API response when you change a property name
in an internal class. Yet, we often need to transform between
Product and ProductJson. For this, we could define a member
function toProduct.

**(대안 1) 멤버로 넣는 방식 — 클래스가 비대해짐**

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
) {
    fun toProduct() = Product(
        id = this.id,
        title = this.title,
        imgSrc = this.img,
        description = this.desc,
        price = BigDecimal(price), // String → BigDecimal로 파싱
        type = enumValueOf<ProductType>(this.type) // String → enum
    )
}

```

Not everyone likes this solution as it makes ProductJson bigger
and more complicated. It is also not useful in transforming 

from Product to ProductJson because in most modern architec-
tures we don’t want domain classes (like Product) to be aware

of details such as their API representation. A better solution

is to define bothtoProduct and toProductJson as extension func-
tions, then locate them together next to the ProductJson class.

It is good to locate those transformation functions next to
each other, because they have a lot in common.

**(권장) 확장 함수로 분리 — 변환 로직 응집/대칭/분리**

```kotlin
class ProductJson(
    val id: String,
    val title: String,
    val img: String,
    val desc: String,
    val price: String,
    val type: String,
    // ...
)

// DTO → 도메인
fun ProductJson.toProduct() = Product(
    id = this.id,
    title = this.title,
    imgSrc = this.img,
    description = this.desc,
    price = BigDecimal(this.price),               // String → BigDecimal
    type = enumValueOf<ProductType>(this.type)    // String → enum
)

// 도메인 → DTO
fun Product.toProductJson() = ProductJson(
    id = this.id,
    title = this.title,
    img = this.imgSrc,
    desc = this.description,
    price = this.price.toString(), // BigDecimal → String
    type = this.type.name          // enum → String
)
```

**장점 요약**

- 변환 로직을 **한 파일/패키지에 모아** 응집도↑, 가독성↑
- **양방향 변환**을 대칭적으로 관리
- 도메인 모델이 **API 표현 세부사항**(문자열 파싱/enum 변환 등)에 **오염되지 않음**

This seems to be a popular pattern, both on the backend and
in Android applications.

## 7. Summary

In this chapter, we’ve learned about extensions - a powerful
Kotlin feature that is often used to create convenient and
meaningful utils and to control our code better. However,
with great power comes great responsibility. We should not
be worried about using extensions, but we should use them
consciously and only where they make sense.
In the next chapter, we will finally introduce collections so
that we can talk about lists, sets, maps, and arrays. There’s a
lot ahead, so get ready.

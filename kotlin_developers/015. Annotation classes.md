Another special kind of class in Kotlin is annotations, which
we use to provide additional information about an element.
Here is an example class that uses the JvmField, JvmStatic, and
Throws annotations.

- **어노테이션(Annotation)** = 코드 요소(클래스, 함수, 프로퍼티 등)에 **추가 정보(메타데이터)**를 붙이는 특수한 클래스.
- **중요한 점**: 어노테이션 **자체로는 동작하지 않음** → 단순히 정보만 담음.
- 실제 동작은 **컴파일러 / 라이브러리 / 툴**이 어노테이션을 읽고 처리할 때 발생.

```kotlin
import java.math.BigDecimal
import java.math.MathContext

class Money(
		val amount: BigDecimal,
		val currency: String,
) {
		@Throws(IllegalArgumentException::class)
		operator fun plus(other: Money): Money {
			require(currency == other.currency)
			return Money(amount + other.amount, currency)
		}
		
		companion object {
			@JvmField
			val MATH = MathContext(2)
			@JvmStatic
			fun eur(amount: Double) =
			Money(amount.toBigDecimal(MATH), "EUR")
			@JvmStatic
			fun usd(amount: Double) =
			Money(amount.toBigDecimal(MATH), "USD")
			@JvmStatic
			fun pln(amount: Double) =
			Money(amount.toBigDecimal(MATH), "PLN")
		}
}
```

- **@Throws**: 함수가 어떤 예외를 던질 수 있는지 Java에 노출
- **@JvmField**: 프로퍼티를 getter 없는 **직접 필드**로 노출
- **@JvmStatic**: `companion object` 메서드를 Java의 `static` 메서드처럼 노출

👉 **주로 Kotlin-Java 상호 운용성**(Interop)에서 많이 쓰임.

You can also define your own annotations. This is an example
of annotation declaration and usage:

```kotlin
annotation class Factory
annotation class FactoryFunction(val name: String)

@Factory
class CarFactory {
		@FactoryFunction(name = "toyota")
		fun makeToyota(): Car = Toyota()

		@FactoryFunction(name = "skoda")
		fun makeSkoda(): Car = Skoda()
}

abstract class Car
class Toyota : Car()
class Skoda : Car()
```

- 어노테이션 클래스는 `annotation class` 키워드로 정의.
- 파라미터도 받을 수 있음 (`val name: String`).
- 코드 자체는 바뀌지 않고, **라이브러리/툴이 어노테이션을 읽고 동작**을 추가.

You might be asking yourself what these annotations do. The

answer is surprisingly simple: absolutely nothing. Annota-
tions, by themselves, are not active and do not change how

our code works. They only hold information. However, many
libraries depend on annotations and behave according to
what we specify with them.
Many important libraries use a mechanism called annotation
processing. How it works is simple: there are classes called
annotation processors that are running when we build our
code. They analyze our code and generate extra code. They
generally strongly depend on annotations. This new code is
not part of our project sources, but we can access it once it
has been generated. This fact is used by libraries that use
annotation processing. So, take a look at this class, which uses
the Java Mockito library with an annotation processor:

```kotlin
class DoctorServiceTest {
		@Mock lateinit var doctorRepository: DoctorRepository
		lateinit var doctorService: DoctorService

		@Before fun init() {
			MockitoAnnotations.initMocks(this)
			doctorService = DoctorService(doctorRepository)
		}
		// ...
}
```

- 어노테이션은 “정보”일 뿐 → **Annotation Processor**가 이를 해석해 코드 생성/변환.
- `@Mock` → Mockito의 프로세서가 읽어 `doctorRepository`에 mock 객체를 자동 생성.
- `initMocks()` → 리플렉션을 통해 생성된 코드를 실행.

👉 많은 라이브러리(Dagger, Room, Hilt, etc.)가 **어노테이션 처리 + 코드 생성**을 활용.

The doctorRepository property is annotated as Mock, which
is interpreted by the Mock processor so that this variable
can get a mock value. This processor generates a class that
creates and sets a value for the doctorRepository property
in DoctorServiceTest. Of course, this generated class will
not work by itself as it needs to be started. This is what
MockitoAnnotations.initMocks(this) is for: it uses reflection to
call this generated class.
Annotation processing is better described in Advanced Kotlin,
in the Annotation Processing chapter.

맨위의  `Money` 코드에 붙어 있는 `@Throws`, `@JvmField`, `@JvmStatic` 같은 어노테이션들은 **Kotlin 자체 기능을 쓰기 위해 꼭 필요한 건 아니고**, 주로 **Java ↔ Kotlin 호환성(Interop)**을 보장하려고 붙어 있는 거예요.

`@Jvm*` 같은 어노테이션은 “Interop이 필요할 때” 찾아보면 충분해요.

- 안드로이드 개발이나 JVM 라이브러리를 Kotlin으로 다루다 보면,
    
    “어? Java 문서에는 static인데, Kotlin에서는 어떻게 쓰지?” → 이런 의문이 생기게 돼요.
    
- 그때 **@JvmStatic / @JvmField / @Throws** 같은 걸 찾아서 쓰면 돼요.
- Android SDK가 **Java 기반**이라서, 실무에서는 거의 무조건 Java와 Kotlin을 섞어 쓰게 됩니다.
- 그래서 이런 어노테이션들은 나중에 “왜 필요하지?” 하고 부딪히면서 배우는 게 가장 자연스러워요.

## 1. Meta-annotations

Annotations that are used to annotate other annotations

are known as meta-annotations. There are four key meta-
annotations from Kotlin stdlib:

- Target indicates the kinds of code elements that are pos-
sible targets of an annotation. As arguments, it accepts
    
    AnnotationTarget enum values, which include values like
    CLASS, PROPERTY, FUNCTION, etc.
    
- Retention determines whether an annotation is stored
in the binary output of compilation and is visible for
reflection. By default, both are true.
- Repeatable determines that an annotation is applicable
twice or more in a single code element.
- MustBeDocumented determines that an annotation is part
of a public API and should therefore be included in the
generated documentation for the element to which the
annotation is applied.

- **어노테이션을 꾸미는 어노테이션**
- Kotlin 표준 라이브러리에서 제공하는 주요 4개:
1. **@Target**
    - 적용 가능한 위치 제한
    - 값: `AnnotationTarget.CLASS`, `PROPERTY`, `FUNCTION` 등
    
    ```kotlin
    @Target(AnnotationTarget.CLASS)
    annotation class Factory
    
    ```
    
2. **@Retention**
    - 어노테이션 유지 정책 결정
    - (기본값: 바이너리에 포함 + 리플렉션으로 조회 가능)
3. **@Repeatable**
    - 같은 요소에 어노테이션을 여러 번 적용 가능
    
    ```kotlin
    @Repeatable
    @Target(AnnotationTarget.FUNCTION)
    annotation class FactoryFunction(val name: String)
    
    ```
    
4. **@MustBeDocumented**
    - 공개 API 문서에 포함되도록 강제

Here are example usages of some of these annotations:

```kotlin
@MustBeDocumented
@Target(AnnotationTarget.CLASS)
annotation class Factory
@Repeatable
@Target(AnnotationTarget.FUNCTION)
annotation class FactoryFunction(val name: String)
```

## 2. Annotating the primary constructor

To annotate the primary constructor, it is necessary to use
the constructor keyword as part of its definition, before the
parentheses.

```kotlin
// JvmOverloads annotates primary constructor
class User @JvmOverloads constructor(
		val name: String,
		val surname: String,
		val age: Int = -1,
)

// Kotlin에서 호출
val u1 = User("Tom", "Hanks")     // age 기본값 -1
val u2 = User("Tom", "Hanks", 66) // age 지정

// Java에서 호출 가능 (오버로드 생성자 덕분)
new User("Tom", "Hanks");
new User("Tom", "Hanks", 66);
```

- 클래스의 **주 생성자(primary constructor)** 에 어노테이션을 붙이려면 `constructor` 키워드를 명시해야 함.
- 예: `@JvmOverloads`
    - **역할**: 기본값이 있는 매개변수들을 이용해 **여러 생성자 오버로드**를 자동 생성.
    - 주로 **Java와의 호환성** 때문에 사용됨 → Java에서는 default parameter를 지원하지 않으므로.

👉 **없으면?** Java 쪽에서 `age` 기본값을 가진 생성자가 없어서 직접 다 써줘야 함.

👉 **있으면?** Kotlin의 default parameter를 Java도 활용할 수 있음.

## 3. List literals

When we specify an annotation with an array value, we can
use a special syntax called “array literal”. This means that
instead of using arrayOf, we can declare an array using square
brackets.

- 어노테이션의 매개변수가 **배열(Array)** 인 경우, 특별히 `[]` 표기법을 사용할 수 있음.
- 일반 코드에서는 `arrayOf("A","B")` 를 써야 하지만, 어노테이션 안에서는 `["A","B"]` 가능.

```kotlin
annotation class AnnotationWithList(
    val elements: Array<String>
)

// 여러 방법 모두 허용
@AnnotationWithList(["A", "B", "C"])
val str1 = "ABC"

@AnnotationWithList(elements = ["D", "E"])
val str2 = "ABC"

@AnnotationWithList(arrayOf("F", "G"))
val str3 = "ABC"

```

👉 이 `[]` 문법은 **어노테이션 안에서만 허용**.

👉 일반 코드에서는 `val arr = arrayOf("A","B")` 를 써야 함.

This notation is only allowed for annotations and does not
work for defining arrays in any other context in our code.

## 4. Summary

Annotations are used to describe our code. They might be

interpreted by annotation processors or by classes using run-
time reflection. Tools and libraries use this to automate some

actions for us. Annotations by themselves are a simple fea-
ture, but the possibilities offered by them are amazing.

Let’s now move on to a famous Kotlin feature that gives us
the ability to extend any type with methods or properties:
extensions.

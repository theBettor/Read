Another special kind of class in Kotlin is annotations, which
we use to provide additional information about an element.
Here is an example class that uses the JvmField, JvmStatic, and
Throws annotations.

- **ì–´ë…¸í…Œì´ì…˜(Annotation)** = ì½”ë“œ ìš”ì†Œ(í´ë˜ìŠ¤, í•¨ìˆ˜, í”„ë¡œí¼í‹° ë“±)ì— **ì¶”ê°€ ì •ë³´(ë©”íƒ€ë°ì´í„°)**ë¥¼ ë¶™ì´ëŠ” íŠ¹ìˆ˜í•œ í´ë˜ìŠ¤.
- **ì¤‘ìš”í•œ ì **: ì–´ë…¸í…Œì´ì…˜ **ìì²´ë¡œëŠ” ë™ì‘í•˜ì§€ ì•ŠìŒ** â†’ ë‹¨ìˆœíˆ ì •ë³´ë§Œ ë‹´ìŒ.
- ì‹¤ì œ ë™ì‘ì€ **ì»´íŒŒì¼ëŸ¬ / ë¼ì´ë¸ŒëŸ¬ë¦¬ / íˆ´**ì´ ì–´ë…¸í…Œì´ì…˜ì„ ì½ê³  ì²˜ë¦¬í•  ë•Œ ë°œìƒ.

```kotlin
import java.math.BigDecimal
import java.math.MathContext

class Money(
		val amount: BigDecimal,
		val currency: String,
) {
		@Throws(IllegalArgumentException::class)
		operator fun plus(other: Money): Money {
			require(currency == other.currency)
			return Money(amount + other.amount, currency)
		}
		
		companion object {
			@JvmField
			val MATH = MathContext(2)
			@JvmStatic
			fun eur(amount: Double) =
			Money(amount.toBigDecimal(MATH), "EUR")
			@JvmStatic
			fun usd(amount: Double) =
			Money(amount.toBigDecimal(MATH), "USD")
			@JvmStatic
			fun pln(amount: Double) =
			Money(amount.toBigDecimal(MATH), "PLN")
		}
}
```

- **@Throws**: í•¨ìˆ˜ê°€ ì–´ë–¤ ì˜ˆì™¸ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆëŠ”ì§€ Javaì— ë…¸ì¶œ
- **@JvmField**: í”„ë¡œí¼í‹°ë¥¼ getter ì—†ëŠ” **ì§ì ‘ í•„ë“œ**ë¡œ ë…¸ì¶œ
- **@JvmStatic**: `companion object` ë©”ì„œë“œë¥¼ Javaì˜ `static` ë©”ì„œë“œì²˜ëŸ¼ ë…¸ì¶œ

ğŸ‘‰ **ì£¼ë¡œ Kotlin-Java ìƒí˜¸ ìš´ìš©ì„±**(Interop)ì—ì„œ ë§ì´ ì“°ì„.

You can also define your own annotations. This is an example
of annotation declaration and usage:

```kotlin
annotation class Factory
annotation class FactoryFunction(val name: String)

@Factory
class CarFactory {
		@FactoryFunction(name = "toyota")
		fun makeToyota(): Car = Toyota()

		@FactoryFunction(name = "skoda")
		fun makeSkoda(): Car = Skoda()
}

abstract class Car
class Toyota : Car()
class Skoda : Car()
```

- ì–´ë…¸í…Œì´ì…˜ í´ë˜ìŠ¤ëŠ” `annotation class` í‚¤ì›Œë“œë¡œ ì •ì˜.
- íŒŒë¼ë¯¸í„°ë„ ë°›ì„ ìˆ˜ ìˆìŒ (`val name: String`).
- ì½”ë“œ ìì²´ëŠ” ë°”ë€Œì§€ ì•Šê³ , **ë¼ì´ë¸ŒëŸ¬ë¦¬/íˆ´ì´ ì–´ë…¸í…Œì´ì…˜ì„ ì½ê³  ë™ì‘**ì„ ì¶”ê°€.

You might be asking yourself what these annotations do. The

answer is surprisingly simple: absolutely nothing. Annota-
tions, by themselves, are not active and do not change how

our code works. They only hold information. However, many
libraries depend on annotations and behave according to
what we specify with them.
Many important libraries use a mechanism called annotation
processing. How it works is simple: there are classes called
annotation processors that are running when we build our
code. They analyze our code and generate extra code. They
generally strongly depend on annotations. This new code is
not part of our project sources, but we can access it once it
has been generated. This fact is used by libraries that use
annotation processing. So, take a look at this class, which uses
the Java Mockito library with an annotation processor:

```kotlin
class DoctorServiceTest {
		@Mock lateinit var doctorRepository: DoctorRepository
		lateinit var doctorService: DoctorService

		@Before fun init() {
			MockitoAnnotations.initMocks(this)
			doctorService = DoctorService(doctorRepository)
		}
		// ...
}
```

- ì–´ë…¸í…Œì´ì…˜ì€ â€œì •ë³´â€ì¼ ë¿ â†’ **Annotation Processor**ê°€ ì´ë¥¼ í•´ì„í•´ ì½”ë“œ ìƒì„±/ë³€í™˜.
- `@Mock` â†’ Mockitoì˜ í”„ë¡œì„¸ì„œê°€ ì½ì–´ `doctorRepository`ì— mock ê°ì²´ë¥¼ ìë™ ìƒì„±.
- `initMocks()` â†’ ë¦¬í”Œë ‰ì…˜ì„ í†µí•´ ìƒì„±ëœ ì½”ë“œë¥¼ ì‹¤í–‰.

ğŸ‘‰ ë§ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬(Dagger, Room, Hilt, etc.)ê°€ **ì–´ë…¸í…Œì´ì…˜ ì²˜ë¦¬ + ì½”ë“œ ìƒì„±**ì„ í™œìš©.

The doctorRepository property is annotated as Mock, which
is interpreted by the Mock processor so that this variable
can get a mock value. This processor generates a class that
creates and sets a value for the doctorRepository property
in DoctorServiceTest. Of course, this generated class will
not work by itself as it needs to be started. This is what
MockitoAnnotations.initMocks(this) is for: it uses reflection to
call this generated class.
Annotation processing is better described in Advanced Kotlin,
in the Annotation Processing chapter.

ë§¨ìœ„ì˜  `Money` ì½”ë“œì— ë¶™ì–´ ìˆëŠ” `@Throws`, `@JvmField`, `@JvmStatic` ê°™ì€ ì–´ë…¸í…Œì´ì…˜ë“¤ì€ **Kotlin ìì²´ ê¸°ëŠ¥ì„ ì“°ê¸° ìœ„í•´ ê¼­ í•„ìš”í•œ ê±´ ì•„ë‹ˆê³ **, ì£¼ë¡œ **Java â†” Kotlin í˜¸í™˜ì„±(Interop)**ì„ ë³´ì¥í•˜ë ¤ê³  ë¶™ì–´ ìˆëŠ” ê±°ì˜ˆìš”.

`@Jvm*` ê°™ì€ ì–´ë…¸í…Œì´ì…˜ì€ â€œInteropì´ í•„ìš”í•  ë•Œâ€ ì°¾ì•„ë³´ë©´ ì¶©ë¶„í•´ìš”.

- ì•ˆë“œë¡œì´ë“œ ê°œë°œì´ë‚˜ JVM ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ Kotlinìœ¼ë¡œ ë‹¤ë£¨ë‹¤ ë³´ë©´,
    
    â€œì–´? Java ë¬¸ì„œì—ëŠ” staticì¸ë°, Kotlinì—ì„œëŠ” ì–´ë–»ê²Œ ì“°ì§€?â€ â†’ ì´ëŸ° ì˜ë¬¸ì´ ìƒê¸°ê²Œ ë¼ìš”.
    
- ê·¸ë•Œ **@JvmStatic / @JvmField / @Throws** ê°™ì€ ê±¸ ì°¾ì•„ì„œ ì“°ë©´ ë¼ìš”.
- Android SDKê°€ **Java ê¸°ë°˜**ì´ë¼ì„œ, ì‹¤ë¬´ì—ì„œëŠ” ê±°ì˜ ë¬´ì¡°ê±´ Javaì™€ Kotlinì„ ì„ì–´ ì“°ê²Œ ë©ë‹ˆë‹¤.
- ê·¸ë˜ì„œ ì´ëŸ° ì–´ë…¸í…Œì´ì…˜ë“¤ì€ ë‚˜ì¤‘ì— â€œì™œ í•„ìš”í•˜ì§€?â€ í•˜ê³  ë¶€ë”ªíˆë©´ì„œ ë°°ìš°ëŠ” ê²Œ ê°€ì¥ ìì—°ìŠ¤ëŸ¬ì›Œìš”.

## 1. Meta-annotations

Annotations that are used to annotate other annotations

are known as meta-annotations. There are four key meta-
annotations from Kotlin stdlib:

- Target indicates the kinds of code elements that are pos-
sible targets of an annotation. As arguments, it accepts
    
    AnnotationTarget enum values, which include values like
    CLASS, PROPERTY, FUNCTION, etc.
    
- Retention determines whether an annotation is stored
in the binary output of compilation and is visible for
reflection. By default, both are true.
- Repeatable determines that an annotation is applicable
twice or more in a single code element.
- MustBeDocumented determines that an annotation is part
of a public API and should therefore be included in the
generated documentation for the element to which the
annotation is applied.

- **ì–´ë…¸í…Œì´ì…˜ì„ ê¾¸ë¯¸ëŠ” ì–´ë…¸í…Œì´ì…˜**
- Kotlin í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” ì£¼ìš” 4ê°œ:
1. **@Target**
    - ì ìš© ê°€ëŠ¥í•œ ìœ„ì¹˜ ì œí•œ
    - ê°’: `AnnotationTarget.CLASS`, `PROPERTY`, `FUNCTION` ë“±
    
    ```kotlin
    @Target(AnnotationTarget.CLASS)
    annotation class Factory
    
    ```
    
2. **@Retention**
    - ì–´ë…¸í…Œì´ì…˜ ìœ ì§€ ì •ì±… ê²°ì •
    - (ê¸°ë³¸ê°’: ë°”ì´ë„ˆë¦¬ì— í¬í•¨ + ë¦¬í”Œë ‰ì…˜ìœ¼ë¡œ ì¡°íšŒ ê°€ëŠ¥)
3. **@Repeatable**
    - ê°™ì€ ìš”ì†Œì— ì–´ë…¸í…Œì´ì…˜ì„ ì—¬ëŸ¬ ë²ˆ ì ìš© ê°€ëŠ¥
    
    ```kotlin
    @Repeatable
    @Target(AnnotationTarget.FUNCTION)
    annotation class FactoryFunction(val name: String)
    
    ```
    
4. **@MustBeDocumented**
    - ê³µê°œ API ë¬¸ì„œì— í¬í•¨ë˜ë„ë¡ ê°•ì œ

Here are example usages of some of these annotations:

```kotlin
@MustBeDocumented
@Target(AnnotationTarget.CLASS)
annotation class Factory
@Repeatable
@Target(AnnotationTarget.FUNCTION)
annotation class FactoryFunction(val name: String)
```

## 2. Annotating the primary constructor

To annotate the primary constructor, it is necessary to use
the constructor keyword as part of its definition, before the
parentheses.

```kotlin
// JvmOverloads annotates primary constructor
class User @JvmOverloads constructor(
		val name: String,
		val surname: String,
		val age: Int = -1,
)

// Kotlinì—ì„œ í˜¸ì¶œ
val u1 = User("Tom", "Hanks")     // age ê¸°ë³¸ê°’ -1
val u2 = User("Tom", "Hanks", 66) // age ì§€ì •

// Javaì—ì„œ í˜¸ì¶œ ê°€ëŠ¥ (ì˜¤ë²„ë¡œë“œ ìƒì„±ì ë•ë¶„)
new User("Tom", "Hanks");
new User("Tom", "Hanks", 66);
```

- í´ë˜ìŠ¤ì˜ **ì£¼ ìƒì„±ì(primary constructor)** ì— ì–´ë…¸í…Œì´ì…˜ì„ ë¶™ì´ë ¤ë©´ `constructor` í‚¤ì›Œë“œë¥¼ ëª…ì‹œí•´ì•¼ í•¨.
- ì˜ˆ: `@JvmOverloads`
    - **ì—­í• **: ê¸°ë³¸ê°’ì´ ìˆëŠ” ë§¤ê°œë³€ìˆ˜ë“¤ì„ ì´ìš©í•´ **ì—¬ëŸ¬ ìƒì„±ì ì˜¤ë²„ë¡œë“œ**ë¥¼ ìë™ ìƒì„±.
    - ì£¼ë¡œ **Javaì™€ì˜ í˜¸í™˜ì„±** ë•Œë¬¸ì— ì‚¬ìš©ë¨ â†’ Javaì—ì„œëŠ” default parameterë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ.

ğŸ‘‰Â **ì—†ìœ¼ë©´?** Java ìª½ì—ì„œ `age` ê¸°ë³¸ê°’ì„ ê°€ì§„ ìƒì„±ìê°€ ì—†ì–´ì„œ ì§ì ‘ ë‹¤ ì¨ì¤˜ì•¼ í•¨.

ğŸ‘‰Â **ìˆìœ¼ë©´?** Kotlinì˜ default parameterë¥¼ Javaë„ í™œìš©í•  ìˆ˜ ìˆìŒ.

## 3. List literals

When we specify an annotation with an array value, we can
use a special syntax called â€œarray literalâ€. This means that
instead of using arrayOf, we can declare an array using square
brackets.

- ì–´ë…¸í…Œì´ì…˜ì˜ ë§¤ê°œë³€ìˆ˜ê°€ **ë°°ì—´(Array)** ì¸ ê²½ìš°, íŠ¹ë³„íˆ `[]` í‘œê¸°ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
- ì¼ë°˜ ì½”ë“œì—ì„œëŠ” `arrayOf("A","B")` ë¥¼ ì¨ì•¼ í•˜ì§€ë§Œ, ì–´ë…¸í…Œì´ì…˜ ì•ˆì—ì„œëŠ” `["A","B"]` ê°€ëŠ¥.

```kotlin
annotation class AnnotationWithList(
    val elements: Array<String>
)

// ì—¬ëŸ¬ ë°©ë²• ëª¨ë‘ í—ˆìš©
@AnnotationWithList(["A", "B", "C"])
val str1 = "ABC"

@AnnotationWithList(elements = ["D", "E"])
val str2 = "ABC"

@AnnotationWithList(arrayOf("F", "G"))
val str3 = "ABC"

```

ğŸ‘‰ ì´ `[]` ë¬¸ë²•ì€ **ì–´ë…¸í…Œì´ì…˜ ì•ˆì—ì„œë§Œ í—ˆìš©**.

ğŸ‘‰ ì¼ë°˜ ì½”ë“œì—ì„œëŠ” `val arr = arrayOf("A","B")` ë¥¼ ì¨ì•¼ í•¨.

This notation is only allowed for annotations and does not
work for defining arrays in any other context in our code.

## 4. Summary

Annotations are used to describe our code. They might be

interpreted by annotation processors or by classes using run-
time reflection. Tools and libraries use this to automate some

actions for us. Annotations by themselves are a simple fea-
ture, but the possibilities offered by them are amazing.

Letâ€™s now move on to a famous Kotlin feature that gives us
the ability to extend any type with methods or properties:
extensions.
